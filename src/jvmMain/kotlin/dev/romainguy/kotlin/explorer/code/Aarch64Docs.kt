// NOTE: AUTO-GENERATED FILE, DO NOT MODIFY!

package dev.romainguy.kotlin.explorer.code
                
val Aarch64Docs = HashMap<String, OpCodeDoc>(2023).apply {
    this["abs"] = OpCodeDoc(
        "ABS",
        """Absolute value computes the absolute value of the signed integer value in the
source register, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ABS--Absolute-value-"
    )
    this["adc"] = OpCodeDoc(
        "ADC",
        """Add with Carry adds two register values and the Carry flag value, and writes
the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADC--Add-with-carry-"
    )
    this["adclb"] = OpCodeDoc(
        "ADCLB",
        """Add the even-numbered elements of the first source vector and the 1-bit carry
from the least-significant bit of the odd-numbered elements of the second
source vector to the even-numbered elements of the destination and accumulator
vector. The 1-bit carry output is placed in the corresponding odd-numbered
element of the destination vector.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADCLB---"
    )
    this["adclt"] = OpCodeDoc(
        "ADCLT",
        """Add the odd-numbered elements of the first source vector and the 1-bit carry
from the least-significant bit of the odd-numbered elements of the second
source vector to the even-numbered elements of the destination and accumulator
vector. The 1-bit carry output is placed in the corresponding odd-numbered
element of the destination vector.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADCLT---"
    )
    this["adcs"] = OpCodeDoc(
        "ADCS",
        """Add with Carry, setting flags, adds two register values and the Carry flag
value, and writes the result to the destination register. It updates the
condition flags based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADCS--Add-with-carry--setting-flags-"
    )
    this["add"] = OpCodeDoc(
        "ADD",
        """Add (extended register) adds a register value and a sign or zero-extended
register value, followed by an optional left shift amount, and writes the
result to the destination register. The argument that is extended from the
<Rm> register can be a byte, halfword, word, or doubleword.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADD--extended-register---Add--extended-register--"
    )
    this["add"] = OpCodeDoc(
        "ADD",
        """Add (immediate) adds a register value and an optionally-shifted immediate
value, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADD--immediate---Add--immediate--"
    )
    this["add"] = OpCodeDoc(
        "ADD",
        """Add an unsigned immediate to each element of the source vector, and
destructively place the results in the corresponding elements of the source
vector. This instruction is unpredicated.

The immediate is an unsigned value in the range 0 to 255, and for element
widths of 16 bits or higher it may also be a positive multiple of 256 in the
range 256 to 65280.

The immediate is encoded in 8 bits with an optional left shift by 8. The
preferred disassembly when the shift option is specified is "#<uimm8>, LSL
#8". However an assembler and disassembler may also allow use of the shifted
16-bit value unless the immediate is 0 and the shift amount is 8, which must
be unambiguously described as "#0, LSL #8".

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADD--immediate----"
    )
    this["addg"] = OpCodeDoc(
        "ADDG",
        """Add with Tag adds an immediate value scaled by the Tag granule to the address
in the source register, modifies the Logical Address Tag of the address using
an immediate value, and writes the result to the destination register. Tags
specified in GCR_EL1.Exclude are excluded from the possible outputs when
modifying the Logical Address Tag.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDG--Add-with-tag-"
    )
    this["addha"] = OpCodeDoc(
        "ADDHA",
        """Add each element of the source vector to the corresponding active element of
each horizontal slice of a ZA tile. The tile elements are predicated by a pair
of governing predicates. An element of a horizontal slice is considered active
if its corresponding element in the second governing predicate is TRUE and the
element corresponding to its horizontal slice number in the first governing
predicate is TRUE. Inactive elements in the destination tile remain
unmodified.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 64-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDHA---"
    )
    this["addhn"] = OpCodeDoc(
        "ADDHN",
        """Add returning High Narrow. This instruction adds each vector element in the
first source SIMD&FP register to the corresponding vector element in the
second source SIMD&FP register, places the most significant half of the result
into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register.

The results are truncated. For rounded results, see RADDHN.

The `ADDHN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `ADDHN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDHN--ADDHN---Add-returning-high-narrow-"
    )
    this["addhn2"] = OpCodeDoc(
        "ADDHN2",
        """Add returning High Narrow. This instruction adds each vector element in the
first source SIMD&FP register to the corresponding vector element in the
second source SIMD&FP register, places the most significant half of the result
into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register.

The results are truncated. For rounded results, see RADDHN.

The `ADDHN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `ADDHN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDHN--ADDHN---Add-returning-high-narrow-"
    )
    this["addhnb"] = OpCodeDoc(
        "ADDHNB",
        """Add each vector element of the first source vector to the corresponding vector
element of the second source vector, and place the most significant half of
the result in the even-numbered half-width destination elements, while setting
the odd-numbered elements to zero. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDHNB---"
    )
    this["addhnt"] = OpCodeDoc(
        "ADDHNT",
        """Add each vector element of the first source vector to the corresponding vector
element of the second source vector, and place the most significant half of
the result in the odd-numbered half-width destination elements, leaving the
even-numbered elements unchanged. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDHNT---"
    )
    this["addp"] = OpCodeDoc(
        "ADDP",
        """Add Pair of elements (scalar). This instruction adds two vector elements in
the source SIMD&FP register and writes the scalar result into the destination
SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDP--scalar---Add-pair-of-elements--scalar--"
    )
    this["addpl"] = OpCodeDoc(
        "ADDPL",
        """Add the current predicate register size in bytes multiplied by an immediate in
the range -32 to 31 to the 64-bit source general-purpose register or current
stack pointer and place the result in the 64-bit destination general-purpose
register or current stack pointer.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDPL---"
    )
    this["addqv"] = OpCodeDoc(
        "ADDQV",
        """Unsigned addition of the same element numbers from each 128-bit source vector
segment, placing each result into the corresponding element number of the
128-bit SIMD&FP destination register. Inactive elements in the source vector
are treated as zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDQV---"
    )
    this["adds"] = OpCodeDoc(
        "ADDS",
        """Add (extended register), setting flags, adds a register value and a sign or
zero-extended register value, followed by an optional left shift amount, and
writes the result to the destination register. The argument that is extended
from the <Rm> register can be a byte, halfword, word, or doubleword. It
updates the condition flags based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDS--extended-register---Add--extended-register---setting-flags-"
    )
    this["adds"] = OpCodeDoc(
        "ADDS",
        """Add (immediate), setting flags, adds a register value and an optionally-
shifted immediate value, and writes the result to the destination register. It
updates the condition flags based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDS--immediate---Add--immediate---setting-flags-"
    )
    this["addspl"] = OpCodeDoc(
        "ADDSPL",
        """Add the Streaming SVE predicate register size in bytes multiplied by an
immediate in the range -32 to 31 to the 64-bit source general-purpose register
or current stack pointer and place the result in the 64-bit destination
general-purpose register or current stack pointer.

This instruction does not require the PE to be in Streaming SVE mode.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDSPL---"
    )
    this["addsvl"] = OpCodeDoc(
        "ADDSVL",
        """Add the Streaming SVE vector register size in bytes multiplied by an immediate
in the range -32 to 31 to the 64-bit source general-purpose register or
current stack pointer, and place the result in the 64-bit destination general-
purpose register or current stack pointer.

This instruction does not require the PE to be in Streaming SVE mode.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDSVL---"
    )
    this["addv"] = OpCodeDoc(
        "ADDV",
        """Add across Vector. This instruction adds every vector element in the source
SIMD&FP register together, and writes the scalar result to the destination
SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDV--Add-across-vector-"
    )
    this["addva"] = OpCodeDoc(
        "ADDVA",
        """Add each element of the source vector to the corresponding active element of
each vertical slice of a ZA tile. The tile elements are predicated by a pair
of governing predicates. An element of a vertical slice is considered active
if its corresponding element in the first governing predicate is TRUE and the
element corresponding to its vertical slice number in the second governing
predicate is TRUE. Inactive elements in the destination tile remain
unmodified.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 64-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDVA---"
    )
    this["addvl"] = OpCodeDoc(
        "ADDVL",
        """Add the current vector register size in bytes multiplied by an immediate in
the range -32 to 31 to the 64-bit source general-purpose register or current
stack pointer, and place the result in the 64-bit destination general-purpose
register or current stack pointer.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADDVL---"
    )
    this["adr"] = OpCodeDoc(
        "ADR",
        """Form PC-relative address adds an immediate value to the PC value to form a PC-
relative address, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADR--Form-pc-relative-address-"
    )
    this["adrp"] = OpCodeDoc(
        "ADRP",
        """Form PC-relative address to 4KB page adds an immediate value that is shifted
left by 12 bits, to the PC value to form a PC-relative address, with the
bottom 12 bits masked out, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ADRP--Form-pc-relative-address-to--kb-page-"
    )
    this["aesd"] = OpCodeDoc(
        "AESD",
        """AES single round decryption.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AESD--Aes-single-round-decryption-"
    )
    this["aese"] = OpCodeDoc(
        "AESE",
        """AES single round encryption.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AESE--Aes-single-round-encryption-"
    )
    this["aesimc"] = OpCodeDoc(
        "AESIMC",
        """AES inverse mix columns.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AESIMC--Aes-inverse-mix-columns-"
    )
    this["aesmc"] = OpCodeDoc(
        "AESMC",
        """AES mix columns.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AESMC--Aes-mix-columns-"
    )
    this["and"] = OpCodeDoc(
        "AND",
        """Bitwise AND (vector). This instruction performs a bitwise AND between the two
source SIMD&FP registers, and writes the result to the destination SIMD&FP
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AND--vector---Bitwise-and--vector--"
    )
    this["and"] = OpCodeDoc(
        "AND",
        """Bitwise AND (immediate) performs a bitwise AND of a register value and an
immediate value, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AND--immediate---Bitwise-and--immediate--"
    )
    this["and"] = OpCodeDoc(
        "AND",
        """Bitwise AND an immediate with each 64-bit element of the source vector, and
destructively place the results in the corresponding elements of the source
vector. The immediate is a 64-bit value consisting of a single run of ones or
zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AND--immediate----"
    )
    this["andqv"] = OpCodeDoc(
        "ANDQV",
        """Bitwise AND of the same element numbers from each 128-bit source vector
segment, placing each result into the corresponding element number of the
128-bit SIMD&FP destination register. Inactive elements in the source vector
are treated as all ones.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ANDQV---"
    )
    this["ands"] = OpCodeDoc(
        "ANDS",
        """Bitwise AND (immediate), setting flags, performs a bitwise AND of a register
value and an immediate value, and writes the result to the destination
register. It updates the condition flags based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ANDS--immediate---Bitwise-and--immediate---setting-flags-"
    )
    this["andv"] = OpCodeDoc(
        "ANDV",
        """Bitwise AND horizontally across all lanes of a vector, and place the result in
the SIMD&FP scalar destination register. Inactive elements in the source
vector are treated as all ones.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ANDV---"
    )
    this["asr"] = OpCodeDoc(
        "ASR",
        """Arithmetic Shift Right (register) shifts a register value right by a variable
number of bits, shifting in copies of its sign bit, and writes the result to
the destination register. The remainder obtained by dividing the second source
register by the data size defines the number of bits by which the first source
register is right-shifted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ASR--register---Arithmetic-shift-right--register--"
    )
    this["asr"] = OpCodeDoc(
        "ASR",
        """Arithmetic Shift Right (immediate) shifts a register value right by an
immediate number of bits, shifting in copies of the sign bit in the upper bits
and zeros in the lower bits, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ASR--immediate---Arithmetic-shift-right--immediate--"
    )
    this["asrd"] = OpCodeDoc(
        "ASRD",
        """Shift right by immediate, preserving the sign bit, each active element of the
source vector, and destructively place the results in the corresponding
elements of the source vector. The result rounds toward zero as in a signed
division. The immediate shift amount is an unsigned value in the range 1 to
number of bits per element. Inactive elements in the destination vector
register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ASRD---"
    )
    this["asrr"] = OpCodeDoc(
        "ASRR",
        """Reversed shift right, preserving the sign bit, active elements of the second
source vector by corresponding elements of the first source vector and
destructively place the results in the corresponding elements of the first
source vector. The shift amount operand is a vector of unsigned elements in
which all bits are significant, and not used modulo the element size. Inactive
elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ASRR---"
    )
    this["asrv"] = OpCodeDoc(
        "ASRV",
        """Arithmetic Shift Right Variable shifts a register value right by a variable
number of bits, shifting in copies of its sign bit, and writes the result to
the destination register. The remainder obtained by dividing the second source
register by the data size defines the number of bits by which the first source
register is right-shifted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ASRV--Arithmetic-shift-right-variable-"
    )
    this["at"] = OpCodeDoc(
        "AT",
        """Address Translate. For more information, see op0==0b01, cache maintenance, TLB
maintenance, and address translation instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AT--Address-translate-"
    )
    this["autda"] = OpCodeDoc(
        "AUTDA",
        """Authenticate Data address, using key A. This instruction authenticates a data
address, using a modifier and key A.

The address is in the general-purpose register that is specified by <Xd>.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTDA`.
  * The value zero, for `AUTDZA`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTDA--AUTDZA--Authenticate-data-address--using-key-a-"
    )
    this["autdza"] = OpCodeDoc(
        "AUTDZA",
        """Authenticate Data address, using key A. This instruction authenticates a data
address, using a modifier and key A.

The address is in the general-purpose register that is specified by <Xd>.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTDA`.
  * The value zero, for `AUTDZA`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTDA--AUTDZA--Authenticate-data-address--using-key-a-"
    )
    this["autdb"] = OpCodeDoc(
        "AUTDB",
        """Authenticate Data address, using key B. This instruction authenticates a data
address, using a modifier and key B.

The address is in the general-purpose register that is specified by <Xd>.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTDB`.
  * The value zero, for `AUTDZB`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTDB--AUTDZB--Authenticate-data-address--using-key-b-"
    )
    this["autdzb"] = OpCodeDoc(
        "AUTDZB",
        """Authenticate Data address, using key B. This instruction authenticates a data
address, using a modifier and key B.

The address is in the general-purpose register that is specified by <Xd>.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTDB`.
  * The value zero, for `AUTDZB`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTDB--AUTDZB--Authenticate-data-address--using-key-b-"
    )
    this["autia"] = OpCodeDoc(
        "AUTIA",
        """Authenticate Instruction address, using key A. This instruction authenticates
an instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIA` and `AUTIZA`.
  * In X17, for `AUTIA1716`.
  * In X30, for `AUTIASP` and `AUTIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIA`.
  * The value zero, for `AUTIZA` and `AUTIAZ`.
  * In X16, for `AUTIA1716`.
  * In SP, for `AUTIASP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIA--AUTIA------AUTIASP--AUTIAZ--AUTIZA--Authenticate-instruction-address--using-key-a-"
    )
    this["autia1716"] = OpCodeDoc(
        "AUTIA1716",
        """Authenticate Instruction address, using key A. This instruction authenticates
an instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIA` and `AUTIZA`.
  * In X17, for `AUTIA1716`.
  * In X30, for `AUTIASP` and `AUTIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIA`.
  * The value zero, for `AUTIZA` and `AUTIAZ`.
  * In X16, for `AUTIA1716`.
  * In SP, for `AUTIASP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIA--AUTIA------AUTIASP--AUTIAZ--AUTIZA--Authenticate-instruction-address--using-key-a-"
    )
    this["autiasp"] = OpCodeDoc(
        "AUTIASP",
        """Authenticate Instruction address, using key A. This instruction authenticates
an instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIA` and `AUTIZA`.
  * In X17, for `AUTIA1716`.
  * In X30, for `AUTIASP` and `AUTIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIA`.
  * The value zero, for `AUTIZA` and `AUTIAZ`.
  * In X16, for `AUTIA1716`.
  * In SP, for `AUTIASP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIA--AUTIA------AUTIASP--AUTIAZ--AUTIZA--Authenticate-instruction-address--using-key-a-"
    )
    this["autiaz"] = OpCodeDoc(
        "AUTIAZ",
        """Authenticate Instruction address, using key A. This instruction authenticates
an instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIA` and `AUTIZA`.
  * In X17, for `AUTIA1716`.
  * In X30, for `AUTIASP` and `AUTIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIA`.
  * The value zero, for `AUTIZA` and `AUTIAZ`.
  * In X16, for `AUTIA1716`.
  * In SP, for `AUTIASP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIA--AUTIA------AUTIASP--AUTIAZ--AUTIZA--Authenticate-instruction-address--using-key-a-"
    )
    this["autiza"] = OpCodeDoc(
        "AUTIZA",
        """Authenticate Instruction address, using key A. This instruction authenticates
an instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIA` and `AUTIZA`.
  * In X17, for `AUTIA1716`.
  * In X30, for `AUTIASP` and `AUTIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIA`.
  * The value zero, for `AUTIZA` and `AUTIAZ`.
  * In X16, for `AUTIA1716`.
  * In SP, for `AUTIASP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIA--AUTIA------AUTIASP--AUTIAZ--AUTIZA--Authenticate-instruction-address--using-key-a-"
    )
    this["autib"] = OpCodeDoc(
        "AUTIB",
        """Authenticate Instruction address, using key B. This instruction authenticates
an instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIB` and `AUTIZB`.
  * In X17, for `AUTIB1716`.
  * In X30, for `AUTIBSP` and `AUTIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIB`.
  * The value zero, for `AUTIZB` and `AUTIBZ`.
  * In X16, for `AUTIB1716`.
  * In SP, for `AUTIBSP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIB--AUTIB------AUTIBSP--AUTIBZ--AUTIZB--Authenticate-instruction-address--using-key-b-"
    )
    this["autib1716"] = OpCodeDoc(
        "AUTIB1716",
        """Authenticate Instruction address, using key B. This instruction authenticates
an instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIB` and `AUTIZB`.
  * In X17, for `AUTIB1716`.
  * In X30, for `AUTIBSP` and `AUTIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIB`.
  * The value zero, for `AUTIZB` and `AUTIBZ`.
  * In X16, for `AUTIB1716`.
  * In SP, for `AUTIBSP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIB--AUTIB------AUTIBSP--AUTIBZ--AUTIZB--Authenticate-instruction-address--using-key-b-"
    )
    this["autibsp"] = OpCodeDoc(
        "AUTIBSP",
        """Authenticate Instruction address, using key B. This instruction authenticates
an instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIB` and `AUTIZB`.
  * In X17, for `AUTIB1716`.
  * In X30, for `AUTIBSP` and `AUTIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIB`.
  * The value zero, for `AUTIZB` and `AUTIBZ`.
  * In X16, for `AUTIB1716`.
  * In SP, for `AUTIBSP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIB--AUTIB------AUTIBSP--AUTIBZ--AUTIZB--Authenticate-instruction-address--using-key-b-"
    )
    this["autibz"] = OpCodeDoc(
        "AUTIBZ",
        """Authenticate Instruction address, using key B. This instruction authenticates
an instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIB` and `AUTIZB`.
  * In X17, for `AUTIB1716`.
  * In X30, for `AUTIBSP` and `AUTIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIB`.
  * The value zero, for `AUTIZB` and `AUTIBZ`.
  * In X16, for `AUTIB1716`.
  * In SP, for `AUTIBSP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIB--AUTIB------AUTIBSP--AUTIBZ--AUTIZB--Authenticate-instruction-address--using-key-b-"
    )
    this["autizb"] = OpCodeDoc(
        "AUTIZB",
        """Authenticate Instruction address, using key B. This instruction authenticates
an instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `AUTIB` and `AUTIZB`.
  * In X17, for `AUTIB1716`.
  * In X30, for `AUTIBSP` and `AUTIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `AUTIB`.
  * The value zero, for `AUTIZB` and `AUTIBZ`.
  * In X16, for `AUTIB1716`.
  * In SP, for `AUTIBSP`.

If the authentication passes, the upper bits of the address are restored to
enable subsequent use of the address. For information on behavior if the
authentication fails, see Faulting on pointer authentication.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AUTIB--AUTIB------AUTIBSP--AUTIBZ--AUTIZB--Authenticate-instruction-address--using-key-b-"
    )
    this["axflag"] = OpCodeDoc(
        "AXFLAG",
        """Convert floating-point condition flags from Arm to external format. This
instruction converts the state of the PSTATE.{N,Z,C,V} flags from a form
representing the result of an Arm floating-point scalar compare instruction to
an alternative representation required by some software.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/AXFLAG--Convert-floating-point-condition-flags-from-arm-to-external-format-"
    )
    this["b.al"] = OpCodeDoc(
        "B.AL",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.cc"] = OpCodeDoc(
        "B.CC",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.cs"] = OpCodeDoc(
        "B.CS",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.eq"] = OpCodeDoc(
        "B.EQ",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.ge"] = OpCodeDoc(
        "B.GE",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.gt"] = OpCodeDoc(
        "B.GT",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.hi"] = OpCodeDoc(
        "B.HI",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.le"] = OpCodeDoc(
        "B.LE",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.ls"] = OpCodeDoc(
        "B.LS",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.lt"] = OpCodeDoc(
        "B.LT",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.mi"] = OpCodeDoc(
        "B.MI",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.ne"] = OpCodeDoc(
        "B.NE",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.pl"] = OpCodeDoc(
        "B.PL",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.vc"] = OpCodeDoc(
        "B.VC",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.vs"] = OpCodeDoc(
        "B.VS",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b.cond"] = OpCodeDoc(
        "B.cond",
        """Branch conditionally to a label at a PC-relative offset, with a hint that this
is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B-cond--Branch-conditionally-"
    )
    this["b"] = OpCodeDoc(
        "B",
        """Branch causes an unconditional branch to a label at a PC-relative offset, with
a hint that this is not a subroutine call or return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/B--Branch-"
    )
    this["bc.al"] = OpCodeDoc(
        "BC.AL",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.cc"] = OpCodeDoc(
        "BC.CC",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.cs"] = OpCodeDoc(
        "BC.CS",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.eq"] = OpCodeDoc(
        "BC.EQ",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.ge"] = OpCodeDoc(
        "BC.GE",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.gt"] = OpCodeDoc(
        "BC.GT",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.hi"] = OpCodeDoc(
        "BC.HI",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.le"] = OpCodeDoc(
        "BC.LE",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.ls"] = OpCodeDoc(
        "BC.LS",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.lt"] = OpCodeDoc(
        "BC.LT",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.mi"] = OpCodeDoc(
        "BC.MI",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.ne"] = OpCodeDoc(
        "BC.NE",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.pl"] = OpCodeDoc(
        "BC.PL",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.vc"] = OpCodeDoc(
        "BC.VC",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.vs"] = OpCodeDoc(
        "BC.VS",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bc.cond"] = OpCodeDoc(
        "BC.cond",
        """Branch Consistent conditionally to a label at a PC-relative offset, with a
hint that this branch will behave very consistently and is very unlikely to
change direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BC-cond--Branch-consistent-conditionally-"
    )
    this["bcax"] = OpCodeDoc(
        "BCAX",
        """Bit Clear and exclusive-OR performs a bitwise AND of the 128-bit vector in a
source SIMD&FP register and the complement of the vector in another source
SIMD&FP register, then performs a bitwise exclusive-OR of the resulting vector
and the vector in a third source SIMD&FP register, and writes the result to
the destination SIMD&FP register.

This instruction is implemented only when FEAT_SHA3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BCAX--Bit-clear-and-exclusive-or-"
    )
    this["bdep"] = OpCodeDoc(
        "BDEP",
        """This instruction scatters the lowest-numbered contiguous bits within each
element of the first source vector to the bit positions indicated by non-zero
bits in the corresponding mask element of the second source vector, preserving
their order, and set the bits corresponding to a zero mask bit to zero. This
instruction is unpredicated.

ID_AA64ZFR0_EL1.BitPerm indicates whether this instruction is implemented.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BDEP---"
    )
    this["bext"] = OpCodeDoc(
        "BEXT",
        """This instruction gathers bits in each element of the first source vector from
the bit positions indicated by non-zero bits in the corresponding mask element
of the second source vector to the lowest-numbered contiguous bits of the
corresponding destination element, preserving their order, and sets the
remaining higher-numbered bits to zero. This instruction is unpredicated.

ID_AA64ZFR0_EL1.BitPerm indicates whether this instruction is implemented.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BEXT---"
    )
    this["bfadd"] = OpCodeDoc(
        "BFADD",
        """Add active BFloat16 elements of the second source vector to corresponding
elements of the first source vector and destructively place the results in the
corresponding elements of the first source vector. Inactive elements in the
destination vector register remain unmodified.

This instruction follows SVE2.1 non-widening BFloat16 numerical behaviors.

ID_AA64ZFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFADD--predicated----"
    )
    this["bfc"] = OpCodeDoc(
        "BFC",
        """Bitfield Clear sets a bitfield of <width> bits at bit position <lsb> of the
destination register to zero, leaving the other destination bits unchanged.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFC--Bitfield-clear-"
    )
    this["bfclamp"] = OpCodeDoc(
        "BFCLAMP",
        """Clamp each BFloat16 element in the two or four destination vectors to between
the BFloat16 minimum value in the corresponding element of the first source
vector and the BFloat16 maximum value in the corresponding element of the
second source vector and destructively place the clamped results in the
corresponding elements of the two or four destination vectors.

Regardless of the value of FPCR.AH, the behavior is as follows for each
minimum number and maximum number operation:

  * Negative zero compares less than positive zero. 
  * If one value is numeric and the other is a quiet NaN, the result is the numeric value. 
  * When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN. 

This instruction follows SME2.1 non-widening BFloat16 numerical behaviors
corresponding to instructions that place their results in two or four SVE Z
vectors.

This instruction is unpredicated.

ID_AA64SMFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFCLAMP---"
    )
    this["bfcvt"] = OpCodeDoc(
        "BFCVT",
        """Floating-point convert from single-precision to BFloat16 format (scalar)
converts the single-precision floating-point value in the 32-bit SIMD&FP
source register to BFloat16 format and writes the result in the 16-bit SIMD&FP
destination register.

ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFCVT--Floating-point-convert-from-single-precision-to-bfloat---format--scalar--"
    )
    this["bfcvtn"] = OpCodeDoc(
        "BFCVTN",
        """Floating-point convert from single-precision to BFloat16 format (vector) reads
each single-precision element in the SIMD&FP source vector, converts each
value to BFloat16 format, and writes the results in the lower or upper half of
the SIMD&FP destination vector. The result elements are half the width of the
source elements.

The BFCVTN instruction writes the half-width results to the lower half of the
destination vector and clears the upper half to zero, while the BFCVTN2
instruction writes the results to the upper half of the destination vector
without affecting the other bits in the register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFCVTN--BFCVTN---Floating-point-convert-from-single-precision-to-bfloat---format--vector--"
    )
    this["bfcvtn2"] = OpCodeDoc(
        "BFCVTN2",
        """Floating-point convert from single-precision to BFloat16 format (vector) reads
each single-precision element in the SIMD&FP source vector, converts each
value to BFloat16 format, and writes the results in the lower or upper half of
the SIMD&FP destination vector. The result elements are half the width of the
source elements.

The BFCVTN instruction writes the half-width results to the lower half of the
destination vector and clears the upper half to zero, while the BFCVTN2
instruction writes the results to the upper half of the destination vector
without affecting the other bits in the register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFCVTN--BFCVTN---Floating-point-convert-from-single-precision-to-bfloat---format--vector--"
    )
    this["bfcvtnt"] = OpCodeDoc(
        "BFCVTNT",
        """Convert to BFloat16 from single-precision in each active floating-point
element of the source vector, and place the results in the odd-numbered 16-bit
elements of the destination vector, leaving the even-numbered elements
unchanged. Inactive elements in the destination vector register remain
unmodified.

ID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFCVTNT---"
    )
    this["bfdot"] = OpCodeDoc(
        "BFDOT",
        """BFloat16 floating-point dot product (vector, by element). This instruction
delimits the source vectors into pairs of BFloat16 elements. The BFloat16 pair
within the second source vector is specified using an immediate index. The
index range is from 0 to 3 inclusive.

If FEAT_EBF16 is not implemented or FPCR.EBF is 0, this instruction:

  * Performs an unfused sum-of-products of each pair of adjacent BFloat16 elements in the first source vector with the specified pair of elements in the second source vector. The intermediate single-precision products are rounded before they are summed, and the intermediate sum is rounded before accumulation into the single-precision destination element that overlaps with the corresponding pair of BFloat16 elements in the first source vector.
  * Uses the non-IEEE 754 Round-to-Odd rounding mode, which forces bit 0 of an inexact result to 1, and rounds an overflow to an appropriately signed Infinity.
  * Flushes denormalized inputs and results to zero, as if FPCR.{FZ, FIZ} is {1, 1}.
  * Disables alternative floating point behaviors, as if FPCR.AH is 0.

If FEAT_EBF16 is implemented and FPCR.EBF is 1, then this instruction:

  * Performs a fused sum-of-products of each pair of adjacent BFloat16 elements in the first source vector with the specified pair of elements in the second source vector. The intermediate single-precision products are not rounded before they are summed, but the intermediate sum is rounded before accumulation into the single-precision destination element that overlaps with the corresponding pair of BFloat16 elements in the first source vector.
  * Follows all other floating-point behaviors that apply to single-precision arithmetic, as governed by FPCR.RMode, FPCR.FZ, FPCR.AH, and FPCR.FIZ.

Irrespective of FEAT_EBF16 and FPCR.EBF, this instruction:

  * Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
  * Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.
  * Generates only the default NaN, as if FPCR.DN is 1.

ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFDOT--by-element---Bfloat---floating-point-dot-product--vector--by-element--"
    )
    this["bfi"] = OpCodeDoc(
        "BFI",
        """Bitfield Insert copies a bitfield of <width> bits from the least significant
bits of the source register to bit position <lsb> of the destination register,
leaving the other destination bits unchanged.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFI--Bitfield-insert-"
    )
    this["bfm"] = OpCodeDoc(
        "BFM",
        """Bitfield Move is usually accessed via one of its aliases, which are always
preferred for disassembly.

If <imms> is greater than or equal to <immr>, this copies a bitfield of
(<imms>-<immr>+1) bits starting from bit position <immr> in the source
register to the least significant bits of the destination register.

If <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from
the least significant bits of the source register to bit position
(regsize-<immr>) of the destination register, where regsize is the destination
register size of 32 or 64 bits.

In both cases the other bits of the destination register remain unchanged.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFM--Bitfield-move-"
    )
    this["bfmax"] = OpCodeDoc(
        "BFMAX",
        """Determine the maximum of BFloat16 elements of the second source vector and the
corresponding BFloat16 elements of the two or four first source vectors and
destructively place the results in the corresponding elements of the two or
four first source vectors.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either element is a NaN, the result is Default NaN. 

When FPCR.AH is 1, the behavior is as follows:

  * If both elements are zeros, regardless of the sign of either zero, the result is the second element. 
  * If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element. 

This instruction follows SME2.1 non-widening BFloat16 numerical behaviors
corresponding to instructions that place their results in two or four SVE Z
vectors.

This instruction is unpredicated.

ID_AA64SMFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMAX--multiple-and-single-vector----"
    )
    this["bfmaxnm"] = OpCodeDoc(
        "BFMAXNM",
        """Determine the maximum number value of BFloat16 elements of the second source
vector and the corresponding BFloat16 elements of the two or four first source
vectors and destructively place the results in the corresponding elements of
the two or four first source vectors.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * If one element is numeric and the other is a quiet NaN, the result is the numeric value. 
  * When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN. 

This instruction follows SME2.1 non-widening BFloat16 numerical behaviors
corresponding to instructions that place their results in two or four SVE Z
vectors.

This instruction is unpredicated.

ID_AA64SMFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMAXNM--multiple-and-single-vector----"
    )
    this["bfmin"] = OpCodeDoc(
        "BFMIN",
        """Determine the mininum of BFloat16 elements of the second source vector and the
corresponding BFloat16 elements of the two or four first source vectors and
destructively place the results in the corresponding elements of the two or
four first source vectors.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either element is a NaN, the result is Default NaN. 

When FPCR.AH is 1, the behavior is as follows:

  * If both elements are zeros, regardless of the sign of either zero, the result is the second element. 
  * If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element. 

This instruction follows SME2.1 non-widening BFloat16 numerical behaviors
corresponding to instructions that place their results in two or four SVE Z
vectors.

This instruction is unpredicated.

ID_AA64SMFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMIN--multiple-and-single-vector----"
    )
    this["bfminnm"] = OpCodeDoc(
        "BFMINNM",
        """Determine the minimum number value of BFloat16 elements of the second source
vector and the corresponding BFloat16 elements of the two or four first source
vectors and destructively place the results in the corresponding elements of
the two or four first source vectors.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * If one element is numeric and the other is a quiet NaN, the result is the numeric value. 
  * When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN. 

This instruction follows SME2.1 non-widening BFloat16 numerical behaviors
corresponding to instructions that place their results in two or four SVE Z
vectors.

This instruction is unpredicated.

ID_AA64SMFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMINNM--multiple-and-single-vector----"
    )
    this["bfmla"] = OpCodeDoc(
        "BFMLA",
        """Multiply the corresponding active BFloat16 elements of the first and second
source vectors and add to elements of the third source (addend) vector without
intermediate rounding. Destructively place the results in the destination and
third source (addend) vector. Inactive elements in the destination vector
register remain unmodified.

This instruction follows SVE2.1 non-widening BFloat16 numerical behaviors.

ID_AA64ZFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMLA--vectors----"
    )
    this["bfmlalb"] = OpCodeDoc(
        "BFMLALB",
        """BFloat16 floating-point widening multiply-add long (by element) widens the
even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first
source vector, and the indexed element in the second source vector from
Bfloat16 to single-precision format. The instruction then multiplies and adds
these values without intermediate rounding to single-precision elements of the
destination vector that overlap with the corresponding BFloat16 elements in
the first source vector.

ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMLALB--BFMLALT--by-element---Bfloat---floating-point-widening-multiply-add-long--by-element--"
    )
    this["bfmlalt"] = OpCodeDoc(
        "BFMLALT",
        """BFloat16 floating-point widening multiply-add long (by element) widens the
even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first
source vector, and the indexed element in the second source vector from
Bfloat16 to single-precision format. The instruction then multiplies and adds
these values without intermediate rounding to single-precision elements of the
destination vector that overlap with the corresponding BFloat16 elements in
the first source vector.

ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMLALB--BFMLALT--by-element---Bfloat---floating-point-widening-multiply-add-long--by-element--"
    )
    this["bfmlal"] = OpCodeDoc(
        "BFMLAL",
        """This BFloat16 floating-point multiply-add long instruction widens all 16-bit
BFloat16 elements in the one, two, or four first source vectors and the
indexed element of the second source vector to single-precision format, then
multiplies the corresponding elements and destructively adds these values
without intermediate rounding to the overlapping 32-bit single-precision
elements of the ZA double-vector groups.

The BF16 elements within the second source vector are specified using a 3-bit
immediate index which selects the same element position within each 128-bit
vector segment.

The lowest of the two consecutive vector numbers forming the double-vector
group within all of, each half of, or each quarter of the ZA array are
selected by the sum of the vector select register and immediate offset, modulo
all, half, or quarter the number of ZA array vectors.

The vector group symbol, VGx2 or VGx4, indicates that the ZA operand consists
of two or four ZA double-vector groups respectively. The vector group symbol
is preferred for disassembly, but optional in assembler source code.

This instruction follows SME ZA-targeting floating-point behaviors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMLAL--multiple-and-indexed-vector----"
    )
    this["bfmls"] = OpCodeDoc(
        "BFMLS",
        """Multiply the corresponding active BFloat16 elements of the first and second
source vectors and subtract from elements of the third source (addend) vector
without intermediate rounding. Destructively place the results in the
destination and third source (addend) vector. Inactive elements in the
destination vector register remain unmodified.

This instruction follows SVE2.1 non-widening BFloat16 numerical behaviors.

ID_AA64ZFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMLS--vectors----"
    )
    this["bfmlsl"] = OpCodeDoc(
        "BFMLSL",
        """This BFloat16 floating-point multiply-subtract long instruction widens all
16-bit BFloat16 elements in the one, two, or four first source vectors and the
indexed element of the second source vector to single-precision format, then
multiplies the corresponding elements and destructively subtracts these values
without intermediate rounding from the overlapping 32-bit single-precision
elements of the ZA double-vector groups.

The BF16 elements within the second source vector are specified using a 3-bit
immediate index which selects the same element position within each 128-bit
vector segment.

The lowest of the two consecutive vector numbers forming the double-vector
group within all of, each half of, or each quarter of the ZA array are
selected by the sum of the vector select register and immediate offset, modulo
all, half, or quarter the number of ZA array vectors.

The vector group symbol, VGx2 or VGx4, indicates that the ZA operand consists
of two or four ZA double-vector groups respectively. The vector group symbol
is preferred for disassembly, but optional in assembler source code.

This instruction follows SME ZA-targeting floating-point behaviors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMLSL--multiple-and-indexed-vector----"
    )
    this["bfmlslb"] = OpCodeDoc(
        "BFMLSLB",
        """This BFloat16 floating-point multiply-subtract long instruction widens the
even-numbered BFloat16 elements in the first source vector and the
corresponding elements in the second source vector to single-precision format
and then destructively multiplies and subtracts these values without
intermediate rounding from the single-precision elements of the destination
vector that overlap with the corresponding BFloat16 elements in the source
vectors. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMLSLB--vectors----"
    )
    this["bfmlslt"] = OpCodeDoc(
        "BFMLSLT",
        """This BFloat16 floating-point multiply-subtract long instruction widens the
odd-numbered BFloat16 elements in the first source vector and the
corresponding elements in the second source vector to single-precision format
and then destructively multiplies and subtracts these values without
intermediate rounding from the single-precision elements of the destination
vector that overlap with the corresponding BFloat16 elements in the source
vectors. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMLSLT--vectors----"
    )
    this["bfmmla"] = OpCodeDoc(
        "BFMMLA",
        """BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix.

If FEAT_EBF16 is not implemented or FPCR.EBF is 0, this instruction:

  * Performs two unfused sums-of-products within each two pairs of adjacent BFloat16 elements while multiplying the 2x4 matrix of BFloat16 values in the first source vector with the 4x2 matrix of BFloat16 values in the second source vector. The intermediate single-precision products are rounded before they are summed and the intermediate sum is rounded before accumulation into the 2x2 single-precision matrix in the destination vector. This is equivalent to accumulating two 2-way unfused dot products per destination element.
  * Uses the non-IEEE 754 Round-to-Odd rounding mode, which forces bit 0 of an inexact result to 1, and rounds an overflow to an appropriately signed Infinity.
  * Flushes denormalized inputs and results to zero, as if FPCR.{FZ, FIZ} is {1, 1}.
  * Disables alternative floating point behaviors, as if FPCR.AH is 0.

If FEAT_EBF16 is implemented and FPCR.EBF is 1, then this instruction:

  * Performs two fused sums-of-products within each two pairs of adjacent BFloat16 elements while multiplying the 2x4 matrix of BFloat16 values in the first source vector with the 4x2 matrix of BFloat16 values in the second source vector. The intermediate single-precision products are not rounded before they are summed, but the intermediate sum is rounded before accumulation into the 2x2 single-precision matrix in the destination vector. This is equivalent to accumulating two 2-way fused dot products per destination element.
  * Follows all other floating-point behaviors that apply to single-precision arithmetic, as governed by FPCR.RMode, FPCR.FZ, FPCR.AH, and FPCR.FIZ.

Irrespective of FEAT_EBF16 and FPCR.EBF, this instruction:

  * Does not modify the cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC, and IOC).
  * Disables trapped floating-point exceptions, as if the FPCR trap enable bits (IDE, IXE, UFE, OFE, DZE, and IOE) are all zero.
  * Generates only the default NaN, as if FPCR.DN is 1.

ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMMLA--Bfloat---floating-point-matrix-multiply-accumulate-into--x--matrix-"
    )
    this["bfmopa"] = OpCodeDoc(
        "BFMOPA",
        """The BFloat16 floating-point sum of outer products and accumulate instruction
works with a 32-bit element ZA tile.

This instruction multiplies the SVLS2 sub-matrix of BFloat16 values held in
the first source vector by the 2SVLS sub-matrix of BFloat16 values in the
second source vector.

Each source vector is independently predicated by a corresponding governing
predicate. When a 16-bit source element is Inactive it is treated as having
the value +0.0, but if both pairs of source vector elements that correspond to
a 32-bit destination element contain Inactive elements, then the destination
element remains unmodified.

The resulting SVLSSVLS single-precision floating-point sum of outer products
is then destructively added to the single-precision floating-point destination
tile. This is equivalent to performing a 2-way dot product and accumulate to
each of the destination tile elements.

Each 32-bit container of the first source vector holds 2 consecutive column
elements of each row of a SVLS2 sub-matrix. Similarly, each 32-bit container
of the second source vector holds 2 consecutive row elements of each column of
a 2SVLS sub-matrix.

This instruction follows SME BFloat16 numerical behaviors.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMOPA--widening----"
    )
    this["bfmops"] = OpCodeDoc(
        "BFMOPS",
        """The BFloat16 floating-point sum of outer products and subtract instruction
works with a 32-bit element ZA tile.

This instruction multiplies the SVLS2 sub-matrix of BFloat16 values held in
the first source vector by the 2SVLS sub-matrix of BFloat16 values in the
second source vector.

Each source vector is independently predicated by a corresponding governing
predicate. When a 16-bit source element is Inactive it is treated as having
the value +0.0, but if both pairs of source vector elements that correspond to
a 32-bit destination element contain Inactive elements, then the destination
element remains unmodified.

The resulting SVLSSVLS single-precision floating-point sum of outer products
is then destructively subtracted from the single-precision floating-point
destination tile. This is equivalent to performing a 2-way dot product and
subtract from each of the destination tile elements.

Each 32-bit container of the first source vector holds 2 consecutive column
elements of each row of a SVLS2 sub-matrix. Similarly, each 32-bit container
of the second source vector holds 2 consecutive row elements of each column of
a 2SVLS sub-matrix.

This instruction follows SME BFloat16 numerical behaviors.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMOPS--widening----"
    )
    this["bfmul"] = OpCodeDoc(
        "BFMUL",
        """Multiply active BFloat16 elements of the second source vector to corresponding
elements of the first source vector and destructively place the results in the
corresponding elements of the first source vector. Inactive elements in the
destination vector register remain unmodified.

This instruction follows SVE2.1 non-widening BFloat16 numerical behaviors.

ID_AA64ZFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFMUL--vectors--predicated----"
    )
    this["bfsub"] = OpCodeDoc(
        "BFSUB",
        """Subtract active BFloat16 elements of the second source vector from
corresponding BFloat16 elements of the first source vector and destructively
place the results in the corresponding elements of the first source vector.
Inactive elements in the destination vector register remain unmodified.

This instruction follows SVE2.1 non-widening BFloat16 numerical behaviors.

ID_AA64ZFR0_EL1.B16B16 indicates whether this instruction is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFSUB--predicated----"
    )
    this["bfvdot"] = OpCodeDoc(
        "BFVDOT",
        """The instruction computes the sum-of-products of each vertical pair of BFloat16
values in the corresponding elements of the two first source vectors with the
pair of BFloat16 values in the indexed 32-bit group of the corresponding
128-bit segment of the second source vector. The single-precision sum-of-
products results are destructively added to the corresponding single-precision
elements of the two ZA single-vector groups.

The BF16 pairs within the second source vector are specified using an
immediate index which selects the same BF16 pair position within each 128-bit
vector segment. The element index range is from 0 to 3.

The vector numbers forming the single-vector group within each half of the ZA
array are selected by the sum of the vector select register and immediate
offset, modulo half the number of ZA array vectors.

The vector group symbol VGx2 indicates that the ZA operand consists of two ZA
single-vector groups. The vector group symbol is preferred for disassembly,
but optional in assembler source code.

This instruction follows SME2 ZA-targeting BFloat16 numerical behaviors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFVDOT---"
    )
    this["bfxil"] = OpCodeDoc(
        "BFXIL",
        """Bitfield Extract and Insert Low copies a bitfield of <width> bits starting
from bit position <lsb> in the source register to the least significant bits
of the destination register, leaving the other destination bits unchanged.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BFXIL--Bitfield-extract-and-insert-at-low-end-"
    )
    this["bgrp"] = OpCodeDoc(
        "BGRP",
        """This instruction separates bits in each element of the first source vector by
gathering from the bit positions indicated by non-zero bits in the
corresponding mask element of the second source vector to the lowest-numbered
contiguous bits of the corresponding destination element, and from positions
indicated by zero bits to the highest-numbered bits of the destination
element, preserving the bit order within each group. This instruction is
unpredicated.

ID_AA64ZFR0_EL1.BitPerm indicates whether this instruction is implemented.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BGRP---"
    )
    this["bic"] = OpCodeDoc(
        "BIC",
        """Bitwise bit Clear (vector, immediate). This instruction reads each vector
element from the destination SIMD&FP register, performs a bitwise AND between
each result and the complement of an immediate constant, places the result
into a vector, and writes the vector to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BIC--vector--immediate---Bitwise-bit-clear--vector--immediate--"
    )
    this["bic"] = OpCodeDoc(
        "BIC",
        """Bitwise clear bits using immediate with each 64-bit element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. The immediate is a 64-bit value consisting of a single run
of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction
is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BIC--immediate----"
    )
    this["bics"] = OpCodeDoc(
        "BICS",
        """Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of
a register value and the complement of an optionally-shifted register value,
and writes the result to the destination register. It updates the condition
flags based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BICS--shifted-register---Bitwise-bit-clear--shifted-register---setting-flags-"
    )
    this["bif"] = OpCodeDoc(
        "BIF",
        """Bitwise Insert if False. This instruction inserts each bit from the first
source SIMD&FP register into the destination SIMD&FP register if the
corresponding bit of the second source SIMD&FP register is 0, otherwise leaves
the bit in the destination register unchanged.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BIF--Bitwise-insert-if-false-"
    )
    this["bit"] = OpCodeDoc(
        "BIT",
        """Bitwise Insert if True. This instruction inserts each bit from the first
source SIMD&FP register into the SIMD&FP destination register if the
corresponding bit of the second source SIMD&FP register is 1, otherwise leaves
the bit in the destination register unchanged.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BIT--Bitwise-insert-if-true-"
    )
    this["bl"] = OpCodeDoc(
        "BL",
        """Branch with Link branches to a PC-relative offset, setting the register X30 to
PC+4. It provides a hint that this is a subroutine call.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BL--Branch-with-link-"
    )
    this["blr"] = OpCodeDoc(
        "BLR",
        """Branch with Link to Register calls a subroutine at an address in a register,
setting register X30 to PC+4.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BLR--Branch-with-link-to-register-"
    )
    this["blraa"] = OpCodeDoc(
        "BLRAA",
        """Branch with Link to Register, with pointer authentication. This instruction
authenticates the address in the general-purpose register that is specified by
<Xn>, using a modifier and the specified key, and calls a subroutine at the
authenticated address, setting register X30 to PC+4.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xm|SP> for `BLRAA` and `BLRAB`.
  * The value zero, for `BLRAAZ` and `BLRABZ`.

Key A is used for `BLRAA` and `BLRAAZ`. Key B is used for `BLRAB` and
`BLRABZ`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to the general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BLRAA--BLRAAZ--BLRAB--BLRABZ--Branch-with-link-to-register--with-pointer-authentication-"
    )
    this["blraaz"] = OpCodeDoc(
        "BLRAAZ",
        """Branch with Link to Register, with pointer authentication. This instruction
authenticates the address in the general-purpose register that is specified by
<Xn>, using a modifier and the specified key, and calls a subroutine at the
authenticated address, setting register X30 to PC+4.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xm|SP> for `BLRAA` and `BLRAB`.
  * The value zero, for `BLRAAZ` and `BLRABZ`.

Key A is used for `BLRAA` and `BLRAAZ`. Key B is used for `BLRAB` and
`BLRABZ`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to the general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BLRAA--BLRAAZ--BLRAB--BLRABZ--Branch-with-link-to-register--with-pointer-authentication-"
    )
    this["blrab"] = OpCodeDoc(
        "BLRAB",
        """Branch with Link to Register, with pointer authentication. This instruction
authenticates the address in the general-purpose register that is specified by
<Xn>, using a modifier and the specified key, and calls a subroutine at the
authenticated address, setting register X30 to PC+4.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xm|SP> for `BLRAA` and `BLRAB`.
  * The value zero, for `BLRAAZ` and `BLRABZ`.

Key A is used for `BLRAA` and `BLRAAZ`. Key B is used for `BLRAB` and
`BLRABZ`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to the general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BLRAA--BLRAAZ--BLRAB--BLRABZ--Branch-with-link-to-register--with-pointer-authentication-"
    )
    this["blrabz"] = OpCodeDoc(
        "BLRABZ",
        """Branch with Link to Register, with pointer authentication. This instruction
authenticates the address in the general-purpose register that is specified by
<Xn>, using a modifier and the specified key, and calls a subroutine at the
authenticated address, setting register X30 to PC+4.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xm|SP> for `BLRAA` and `BLRAB`.
  * The value zero, for `BLRAAZ` and `BLRABZ`.

Key A is used for `BLRAA` and `BLRAAZ`. Key B is used for `BLRAB` and
`BLRABZ`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to the general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BLRAA--BLRAAZ--BLRAB--BLRABZ--Branch-with-link-to-register--with-pointer-authentication-"
    )
    this["bmopa"] = OpCodeDoc(
        "BMOPA",
        """This instruction works with 32-bit element ZA tile. This instruction generates
an outer product of the first source SVLS1 vector and the second source
1SVLS vector. Each outer product element is obtained as population count of
the bitwise XNOR result of the corresponding 32-bit elements of the first
source vector and the second source vector. Each source vector is
independently predicated by a corresponding governing predicate. When either
source vector element is inactive the corresponding destination tile element
remains unmodified. The resulting SVLSSVLS product is then destructively
added to the destination tile.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BMOPA---"
    )
    this["bmops"] = OpCodeDoc(
        "BMOPS",
        """This instruction works with 32-bit element ZA tile. This instruction generates
an outer product of the first source SVLS1 vector and the second source
1SVLS vector. Each outer product element is obtained as population count of
the bitwise XNOR result of the corresponding 32-bit elements of the first
source vector and the second source vector. Each source vector is
independently predicated by a corresponding governing predicate. When either
source vector element is inactive the corresponding destination tile element
remains unmodified. The resulting SVLSSVLS product is then destructively
subtracted from the destination tile.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BMOPS---"
    )
    this["br"] = OpCodeDoc(
        "BR",
        """Branch to Register branches unconditionally to an address in a register, with
a hint that this is not a subroutine return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BR--Branch-to-register-"
    )
    this["braa"] = OpCodeDoc(
        "BRAA",
        """Branch to Register, with pointer authentication. This instruction
authenticates the address in the general-purpose register that is specified by
<Xn>, using a modifier and the specified key, and branches to the
authenticated address.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xm|SP> for `BRAA` and `BRAB`.
  * The value zero, for `BRAAZ` and `BRABZ`.

Key A is used for `BRAA` and `BRAAZ`. Key B is used for `BRAB` and `BRABZ`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to the general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRAA--BRAAZ--BRAB--BRABZ--Branch-to-register--with-pointer-authentication-"
    )
    this["braaz"] = OpCodeDoc(
        "BRAAZ",
        """Branch to Register, with pointer authentication. This instruction
authenticates the address in the general-purpose register that is specified by
<Xn>, using a modifier and the specified key, and branches to the
authenticated address.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xm|SP> for `BRAA` and `BRAB`.
  * The value zero, for `BRAAZ` and `BRABZ`.

Key A is used for `BRAA` and `BRAAZ`. Key B is used for `BRAB` and `BRABZ`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to the general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRAA--BRAAZ--BRAB--BRABZ--Branch-to-register--with-pointer-authentication-"
    )
    this["brab"] = OpCodeDoc(
        "BRAB",
        """Branch to Register, with pointer authentication. This instruction
authenticates the address in the general-purpose register that is specified by
<Xn>, using a modifier and the specified key, and branches to the
authenticated address.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xm|SP> for `BRAA` and `BRAB`.
  * The value zero, for `BRAAZ` and `BRABZ`.

Key A is used for `BRAA` and `BRAAZ`. Key B is used for `BRAB` and `BRABZ`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to the general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRAA--BRAAZ--BRAB--BRABZ--Branch-to-register--with-pointer-authentication-"
    )
    this["brabz"] = OpCodeDoc(
        "BRABZ",
        """Branch to Register, with pointer authentication. This instruction
authenticates the address in the general-purpose register that is specified by
<Xn>, using a modifier and the specified key, and branches to the
authenticated address.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xm|SP> for `BRAA` and `BRAB`.
  * The value zero, for `BRAAZ` and `BRABZ`.

Key A is used for `BRAA` and `BRAAZ`. Key B is used for `BRAB` and `BRABZ`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to the general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRAA--BRAAZ--BRAB--BRABZ--Branch-to-register--with-pointer-authentication-"
    )
    this["brb"] = OpCodeDoc(
        "BRB",
        """Branch Record Buffer. For more information, see op0==0b01, cache maintenance,
TLB maintenance, and address translation instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRB--Branch-record-buffer-"
    )
    this["brk"] = OpCodeDoc(
        "BRK",
        """Breakpoint instruction. A `BRK` instruction generates a Breakpoint Instruction
exception. The PE records the exception in ESR_ELx, using the EC value 0x3c,
and captures the value of the immediate argument in ESR_ELx.ISS.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRK--Breakpoint-instruction-"
    )
    this["brka"] = OpCodeDoc(
        "BRKA",
        """Sets destination predicate elements up to and including the first active and
true source element to true, then sets subsequent elements to false. Inactive
elements in the destination predicate register remain unmodified or are set to
zero, depending on whether merging or zeroing predication is selected. Does
not set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKA---"
    )
    this["brkas"] = OpCodeDoc(
        "BRKAS",
        """Sets destination predicate elements up to and including the first active and
true source element to true, then sets subsequent elements to false. Inactive
elements in the destination predicate register are set to zero. Sets the First
(N), None (Z), !Last (C) condition flags based on the predicate result, and
the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKAS---"
    )
    this["brkb"] = OpCodeDoc(
        "BRKB",
        """Sets destination predicate elements up to but not including the first active
and true source element to true, then sets subsequent elements to false.
Inactive elements in the destination predicate register remain unmodified or
are set to zero, depending on whether merging or zeroing predication is
selected. Does not set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKB---"
    )
    this["brkbs"] = OpCodeDoc(
        "BRKBS",
        """Sets destination predicate elements up to but not including the first active
and true source element to true, then sets subsequent elements to false.
Inactive elements in the destination predicate register are set to zero. Sets
the First (N), None (Z), !Last (C) condition flags based on the predicate
result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKBS---"
    )
    this["brkn"] = OpCodeDoc(
        "BRKN",
        """If the last active element of the first source predicate is false then set the
destination predicate to all-false. Otherwise leaves the destination and
second source predicate unchanged. Does not set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKN---"
    )
    this["brkns"] = OpCodeDoc(
        "BRKNS",
        """If the last active element of the first source predicate is false then set the
destination predicate to all-false. Otherwise leaves the destination and
second source predicate unchanged. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKNS---"
    )
    this["brkpa"] = OpCodeDoc(
        "BRKPA",
        """If the last active element of the first source predicate is false then set the
destination predicate to all-false. Otherwise sets destination predicate
elements up to and including the first active and true source element to true,
then sets subsequent elements to false. Inactive elements in the destination
predicate register are set to zero. Does not set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKPA---"
    )
    this["brkpas"] = OpCodeDoc(
        "BRKPAS",
        """If the last active element of the first source predicate is false then set the
destination predicate to all-false. Otherwise sets destination predicate
elements up to and including the first active and true source element to true,
then sets subsequent elements to false. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKPAS---"
    )
    this["brkpb"] = OpCodeDoc(
        "BRKPB",
        """If the last active element of the first source predicate is false then set the
destination predicate to all-false. Otherwise sets destination predicate
elements up to but not including the first active and true source element to
true, then sets subsequent elements to false. Inactive elements in the
destination predicate register are set to zero. Does not set the condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKPB---"
    )
    this["brkpbs"] = OpCodeDoc(
        "BRKPBS",
        """If the last active element of the first source predicate is false then set the
destination predicate to all-false. Otherwise sets destination predicate
elements up to but not including the first active and true source element to
true, then sets subsequent elements to false. Inactive elements in the
destination predicate register are set to zero. Sets the First (N), None (Z),
!Last (C) condition flags based on the predicate result, and the V flag to
zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BRKPBS---"
    )
    this["bsl1n"] = OpCodeDoc(
        "BSL1N",
        """Selects bits from the inverted first source vector where the corresponding bit
in the third source vector is '1', and from the second source vector where the
corresponding bit in the third source vector is '0'. The result is placed
destructively in the destination and first source vector. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BSL-N---"
    )
    this["bsl2n"] = OpCodeDoc(
        "BSL2N",
        """Selects bits from the first source vector where the corresponding bit in the
third source vector is '1', and from the inverted second source vector where
the corresponding bit in the third source vector is '0'. The result is placed
destructively in the destination and first source vector. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BSL-N---"
    )
    this["bsl"] = OpCodeDoc(
        "BSL",
        """Bitwise Select. This instruction sets each bit in the destination SIMD&FP
register to the corresponding bit from the first source SIMD&FP register when
the original destination bit was 1, otherwise from the second source SIMD&FP
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BSL--Bitwise-select-"
    )
    this["bti"] = OpCodeDoc(
        "BTI",
        """Branch Target Identification. A `BTI` instruction is used to guard against the
execution of instructions which are not the intended target of a branch.

Outside of a guarded memory region, a `BTI` instruction executes as a `NOP`.
Within a guarded memory region while PSTATE.BTYPE != 0b00, a `BTI` instruction
compatible with the current value of PSTATE.BTYPE will not generate a Branch
Target Exception and will allow execution of subsequent instructions within
the memory region.

The operand <targets> passed to a `BTI` instruction determines the values of
PSTATE.BTYPE which the `BTI` instruction is compatible with.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BTI--Branch-target-identification-"
    )
    this["cadd"] = OpCodeDoc(
        "CADD",
        """Add the real and imaginary components of the integral complex numbers from the
first source vector to the complex numbers from the second source vector which
have first been rotated by 90 or 270 degrees in the direction from the
positive real axis towards the positive imaginary axis, when considered in
polar representation, equivalent to multiplying the complex numbers in the
second source vector by j beforehand. Destructively place the results in the
corresponding elements of the first source vector. This instruction is
unpredicated.

Each complex number is represented in a vector register as an even/odd pair of
elements with the real part in the even-numbered element and the imaginary
part in the odd-numbered element.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CADD---"
    )
    this["cas"] = OpCodeDoc(
        "CAS",
        """Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit
doubleword from memory, and compares it against the value held in a first
register. If the comparison is equal, the value in a second register is
written to memory. If the write is performed, the read and write occur
atomically such that no other modification of the memory location can take
place between the read and write.

  * `CASA` and `CASAL` load from memory with acquire semantics.
  * `CASL` and `CASAL` store to memory with release semantics.
  * `CAS` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, or <Xs>, is restored to the value held in
the register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CAS--CASA--CASAL--CASL--Compare-and-swap-word-or-doubleword-in-memory-"
    )
    this["casa"] = OpCodeDoc(
        "CASA",
        """Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit
doubleword from memory, and compares it against the value held in a first
register. If the comparison is equal, the value in a second register is
written to memory. If the write is performed, the read and write occur
atomically such that no other modification of the memory location can take
place between the read and write.

  * `CASA` and `CASAL` load from memory with acquire semantics.
  * `CASL` and `CASAL` store to memory with release semantics.
  * `CAS` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, or <Xs>, is restored to the value held in
the register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CAS--CASA--CASAL--CASL--Compare-and-swap-word-or-doubleword-in-memory-"
    )
    this["casal"] = OpCodeDoc(
        "CASAL",
        """Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit
doubleword from memory, and compares it against the value held in a first
register. If the comparison is equal, the value in a second register is
written to memory. If the write is performed, the read and write occur
atomically such that no other modification of the memory location can take
place between the read and write.

  * `CASA` and `CASAL` load from memory with acquire semantics.
  * `CASL` and `CASAL` store to memory with release semantics.
  * `CAS` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, or <Xs>, is restored to the value held in
the register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CAS--CASA--CASAL--CASL--Compare-and-swap-word-or-doubleword-in-memory-"
    )
    this["casl"] = OpCodeDoc(
        "CASL",
        """Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit
doubleword from memory, and compares it against the value held in a first
register. If the comparison is equal, the value in a second register is
written to memory. If the write is performed, the read and write occur
atomically such that no other modification of the memory location can take
place between the read and write.

  * `CASA` and `CASAL` load from memory with acquire semantics.
  * `CASL` and `CASAL` store to memory with release semantics.
  * `CAS` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, or <Xs>, is restored to the value held in
the register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CAS--CASA--CASAL--CASL--Compare-and-swap-word-or-doubleword-in-memory-"
    )
    this["casab"] = OpCodeDoc(
        "CASAB",
        """Compare and Swap byte in memory reads an 8-bit byte from memory, and compares
it against the value held in a first register. If the comparison is equal, the
value in a second register is written to memory. If the write is performed,
the read and write occur atomically such that no other modification of the
memory location can take place between the read and write.

  * `CASAB` and `CASALB` load from memory with acquire semantics.
  * `CASLB` and `CASALB` store to memory with release semantics.
  * `CASB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, is restored to the values held in the
register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASB--CASAB--CASALB--CASLB--Compare-and-swap-byte-in-memory-"
    )
    this["casalb"] = OpCodeDoc(
        "CASALB",
        """Compare and Swap byte in memory reads an 8-bit byte from memory, and compares
it against the value held in a first register. If the comparison is equal, the
value in a second register is written to memory. If the write is performed,
the read and write occur atomically such that no other modification of the
memory location can take place between the read and write.

  * `CASAB` and `CASALB` load from memory with acquire semantics.
  * `CASLB` and `CASALB` store to memory with release semantics.
  * `CASB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, is restored to the values held in the
register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASB--CASAB--CASALB--CASLB--Compare-and-swap-byte-in-memory-"
    )
    this["casb"] = OpCodeDoc(
        "CASB",
        """Compare and Swap byte in memory reads an 8-bit byte from memory, and compares
it against the value held in a first register. If the comparison is equal, the
value in a second register is written to memory. If the write is performed,
the read and write occur atomically such that no other modification of the
memory location can take place between the read and write.

  * `CASAB` and `CASALB` load from memory with acquire semantics.
  * `CASLB` and `CASALB` store to memory with release semantics.
  * `CASB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, is restored to the values held in the
register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASB--CASAB--CASALB--CASLB--Compare-and-swap-byte-in-memory-"
    )
    this["caslb"] = OpCodeDoc(
        "CASLB",
        """Compare and Swap byte in memory reads an 8-bit byte from memory, and compares
it against the value held in a first register. If the comparison is equal, the
value in a second register is written to memory. If the write is performed,
the read and write occur atomically such that no other modification of the
memory location can take place between the read and write.

  * `CASAB` and `CASALB` load from memory with acquire semantics.
  * `CASLB` and `CASALB` store to memory with release semantics.
  * `CASB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, is restored to the values held in the
register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASB--CASAB--CASALB--CASLB--Compare-and-swap-byte-in-memory-"
    )
    this["casah"] = OpCodeDoc(
        "CASAH",
        """Compare and Swap halfword in memory reads a 16-bit halfword from memory, and
compares it against the value held in a first register. If the comparison is
equal, the value in a second register is written to memory. If the write is
performed, the read and write occur atomically such that no other modification
of the memory location can take place between the read and write.

  * `CASAH` and `CASALH` load from memory with acquire semantics.
  * `CASLH` and `CASALH` store to memory with release semantics.
  * `CASH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, is restored to the values held in the
register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASH--CASAH--CASALH--CASLH--Compare-and-swap-halfword-in-memory-"
    )
    this["casalh"] = OpCodeDoc(
        "CASALH",
        """Compare and Swap halfword in memory reads a 16-bit halfword from memory, and
compares it against the value held in a first register. If the comparison is
equal, the value in a second register is written to memory. If the write is
performed, the read and write occur atomically such that no other modification
of the memory location can take place between the read and write.

  * `CASAH` and `CASALH` load from memory with acquire semantics.
  * `CASLH` and `CASALH` store to memory with release semantics.
  * `CASH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, is restored to the values held in the
register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASH--CASAH--CASALH--CASLH--Compare-and-swap-halfword-in-memory-"
    )
    this["cash"] = OpCodeDoc(
        "CASH",
        """Compare and Swap halfword in memory reads a 16-bit halfword from memory, and
compares it against the value held in a first register. If the comparison is
equal, the value in a second register is written to memory. If the write is
performed, the read and write occur atomically such that no other modification
of the memory location can take place between the read and write.

  * `CASAH` and `CASALH` load from memory with acquire semantics.
  * `CASLH` and `CASALH` store to memory with release semantics.
  * `CASH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, is restored to the values held in the
register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASH--CASAH--CASALH--CASLH--Compare-and-swap-halfword-in-memory-"
    )
    this["caslh"] = OpCodeDoc(
        "CASLH",
        """Compare and Swap halfword in memory reads a 16-bit halfword from memory, and
compares it against the value held in a first register. If the comparison is
equal, the value in a second register is written to memory. If the write is
performed, the read and write occur atomically such that no other modification
of the memory location can take place between the read and write.

  * `CASAH` and `CASALH` load from memory with acquire semantics.
  * `CASLH` and `CASALH` store to memory with release semantics.
  * `CASH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the register which is
compared and loaded, that is <Ws>, is restored to the values held in the
register before the instruction was executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASH--CASAH--CASALH--CASLH--Compare-and-swap-halfword-in-memory-"
    )
    this["casp"] = OpCodeDoc(
        "CASP",
        """Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit
words or 64-bit doublewords from memory, and compares them against the values
held in the first pair of registers. If the comparison is equal, the values in
the second pair of registers are written to memory. If the writes are
performed, the reads and writes occur atomically such that no other
modification of the memory location can take place between the reads and
writes.

  * `CASPA` and `CASPAL` load from memory with acquire semantics.
  * `CASPL` and `CASPAL` store to memory with release semantics.
  * `CASP` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the registers which are
compared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are
restored to the values held in the registers before the instruction was
executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASP--CASPA--CASPAL--CASPL--Compare-and-swap-pair-of-words-or-doublewords-in-memory-"
    )
    this["caspa"] = OpCodeDoc(
        "CASPA",
        """Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit
words or 64-bit doublewords from memory, and compares them against the values
held in the first pair of registers. If the comparison is equal, the values in
the second pair of registers are written to memory. If the writes are
performed, the reads and writes occur atomically such that no other
modification of the memory location can take place between the reads and
writes.

  * `CASPA` and `CASPAL` load from memory with acquire semantics.
  * `CASPL` and `CASPAL` store to memory with release semantics.
  * `CASP` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the registers which are
compared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are
restored to the values held in the registers before the instruction was
executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASP--CASPA--CASPAL--CASPL--Compare-and-swap-pair-of-words-or-doublewords-in-memory-"
    )
    this["caspal"] = OpCodeDoc(
        "CASPAL",
        """Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit
words or 64-bit doublewords from memory, and compares them against the values
held in the first pair of registers. If the comparison is equal, the values in
the second pair of registers are written to memory. If the writes are
performed, the reads and writes occur atomically such that no other
modification of the memory location can take place between the reads and
writes.

  * `CASPA` and `CASPAL` load from memory with acquire semantics.
  * `CASPL` and `CASPAL` store to memory with release semantics.
  * `CASP` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the registers which are
compared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are
restored to the values held in the registers before the instruction was
executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASP--CASPA--CASPAL--CASPL--Compare-and-swap-pair-of-words-or-doublewords-in-memory-"
    )
    this["caspl"] = OpCodeDoc(
        "CASPL",
        """Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit
words or 64-bit doublewords from memory, and compares them against the values
held in the first pair of registers. If the comparison is equal, the values in
the second pair of registers are written to memory. If the writes are
performed, the reads and writes occur atomically such that no other
modification of the memory location can take place between the reads and
writes.

  * `CASPA` and `CASPAL` load from memory with acquire semantics.
  * `CASPL` and `CASPAL` store to memory with release semantics.
  * `CASP` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

The architecture permits that the data read clears any exclusive monitors
associated with that location, even if the compare subsequently fails.

If the instruction generates a synchronous Data Abort, the registers which are
compared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are
restored to the values held in the registers before the instruction was
executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CASP--CASPA--CASPAL--CASPL--Compare-and-swap-pair-of-words-or-doublewords-in-memory-"
    )
    this["cbnz"] = OpCodeDoc(
        "CBNZ",
        """Compare and Branch on Nonzero compares the value in a register with zero, and
conditionally branches to a label at a PC-relative offset if the comparison is
not equal. It provides a hint that this is not a subroutine call or return.
This instruction does not affect the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CBNZ--Compare-and-branch-on-nonzero-"
    )
    this["cbz"] = OpCodeDoc(
        "CBZ",
        """Compare and Branch on Zero compares the value in a register with zero, and
conditionally branches to a label at a PC-relative offset if the comparison is
equal. It provides a hint that this is not a subroutine call or return. This
instruction does not affect condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CBZ--Compare-and-branch-on-zero-"
    )
    this["ccmn"] = OpCodeDoc(
        "CCMN",
        """Conditional Compare Negative (immediate) sets the value of the condition flags
to the result of the comparison of a register value and a negated immediate
value if the condition is TRUE, and an immediate value otherwise.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CCMN--immediate---Conditional-compare-negative--immediate--"
    )
    this["ccmn"] = OpCodeDoc(
        "CCMN",
        """Conditional Compare Negative (register) sets the value of the condition flags
to the result of the comparison of a register value and the inverse of another
register value if the condition is TRUE, and an immediate value otherwise.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CCMN--register---Conditional-compare-negative--register--"
    )
    this["ccmp"] = OpCodeDoc(
        "CCMP",
        """Conditional Compare (immediate) sets the value of the condition flags to the
result of the comparison of a register value and an immediate value if the
condition is TRUE, and an immediate value otherwise.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CCMP--immediate---Conditional-compare--immediate--"
    )
    this["ccmp"] = OpCodeDoc(
        "CCMP",
        """Conditional Compare (register) sets the value of the condition flags to the
result of the comparison of two registers if the condition is TRUE, and an
immediate value otherwise.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CCMP--register---Conditional-compare--register--"
    )
    this["cdot"] = OpCodeDoc(
        "CDOT",
        """The complex integer dot product instructions delimit the source vectors into
pairs of 8-bit or 16-bit signed integer complex numbers. Within each pair, the
complex numbers in the first source vector are multiplied by the corresponding
complex numbers in the second source vector and the resulting wide real or
wide imaginary part of the product is accumulated into a 32-bit or 64-bit
destination vector element which overlaps all four of the elements that
comprise a pair of complex number values in the first source vector.

As a result each instruction implicitly deinterleaves the real and imaginary
components of their complex number inputs, so that the destination vector
accumulates 4wide real sums or 4wide imaginary sums.

The complex numbers in the second source vector are rotated by 0, 90, 180 or
270 degrees in the direction from the positive real axis towards the positive
imaginary axis, when considered in polar representation, by performing the
following transformations prior to the dot product operations:

  * If the rotation is #0, the imaginary parts of the complex numbers in the second source vector are negated. The destination vector therefore accumulates the real parts of a complex dot product. 
  * If the rotation is #90, the real and imaginary parts of the complex numbers the second source vector are swapped. The destination vector therefore accumulates the imaginary parts of a complex dot product. 
  * If the rotation is #180, there is no transformation. The destination vector therefore accumulates the real parts of a complex conjugate dot product. 
  * If the rotation is #270, the real parts of the complex numbers in the second source vector are negated and then swapped with the imaginary parts. The destination vector therefore accumulates the imaginary parts of a complex conjugate dot product. 

Each complex number is represented in a vector register as an even/odd pair of
elements with the real part in the even-numbered element and the imaginary
part in the odd-numbered element.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CDOT--vectors----"
    )
    this["cfinv"] = OpCodeDoc(
        "CFINV",
        """Invert Carry Flag. This instruction inverts the value of the PSTATE.C flag.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CFINV--Invert-carry-flag-"
    )
    this["cfp"] = OpCodeDoc(
        "CFP",
        """Control Flow Prediction Restriction by Context prevents control flow
predictions that predict execution addresses based on information gathered
from earlier execution within a particular execution context. Control flow
predictions determined by the actions of code in the target execution context
or contexts appearing in program order before the instruction cannot be used
to exploitatively control speculative execution occurring after the
instruction is complete and synchronized.

For more information, see CFP RCTX, Control Flow Prediction Restriction by
Context.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CFP--Control-flow-prediction-restriction-by-context-"
    )
    this["chkfeat"] = OpCodeDoc(
        "CHKFEAT",
        """Check feature status. This instruction indicates the status of features.

If FEAT_CHK is not implemented, this instruction executes as a `NOP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CHKFEAT--Check-feature-status-"
    )
    this["cinc"] = OpCodeDoc(
        "CINC",
        """Conditional Increment returns, in the destination register, the value of the
source register incremented by 1 if the condition is TRUE, and otherwise
returns the value of the source register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CINC--Conditional-increment-"
    )
    this["cinv"] = OpCodeDoc(
        "CINV",
        """Conditional Invert returns, in the destination register, the bitwise inversion
of the value of the source register if the condition is TRUE, and otherwise
returns the value of the source register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CINV--Conditional-invert-"
    )
    this["clasta"] = OpCodeDoc(
        "CLASTA",
        """From the source vector register extract the element after the last active
element, or if the last active element is the final element extract element
zero, and then zero-extend that element to destructively place in the
destination and first source general-purpose register. If there are no active
elements then destructively zero-extend the least significant element-size
bits of the destination and first source general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CLASTA--scalar----"
    )
    this["clastb"] = OpCodeDoc(
        "CLASTB",
        """From the source vector register extract the last active element, and then
zero-extend that element to destructively place in the destination and first
source general-purpose register. If there are no active elements then
destructively zero-extend the least significant element-size bits of the
destination and first source general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CLASTB--scalar----"
    )
    this["clrbhb"] = OpCodeDoc(
        "CLRBHB",
        """Clear Branch History clears the branch history for the current context to the
extent that branch history information created before the `CLRBHB` instruction
cannot be used by code before the `CLRBHB` instruction to exploitatively
control the execution of any indirect branches in code in the current context
that appear in program order after the instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CLRBHB--Clear-branch-history-"
    )
    this["clrex"] = OpCodeDoc(
        "CLREX",
        """Clear Exclusive clears the local monitor of the executing PE.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CLREX--Clear-exclusive-"
    )
    this["cls"] = OpCodeDoc(
        "CLS",
        """Count Leading Sign bits (vector). This instruction counts the number of
consecutive bits following the most significant bit that are the same as the
most significant bit in each vector element in the source SIMD&FP register,
places the result into a vector, and writes the vector to the destination
SIMD&FP register. The count does not include the most significant bit itself.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CLS--vector---Count-leading-sign-bits--vector--"
    )
    this["clz"] = OpCodeDoc(
        "CLZ",
        """Count Leading Zero bits (vector). This instruction counts the number of
consecutive zeros, starting from the most significant bit, in each vector
element in the source SIMD&FP register, places the result into a vector, and
writes the vector to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CLZ--vector---Count-leading-zero-bits--vector--"
    )
    this["cmeq"] = OpCodeDoc(
        "CMEQ",
        """Compare bitwise Equal (vector). This instruction compares each vector element
from the first source SIMD&FP register with the corresponding vector element
from the second source SIMD&FP register, and if the comparison is equal sets
every bit of the corresponding vector element in the destination SIMD&FP
register to one, otherwise sets every bit of the corresponding vector element
in the destination SIMD&FP register to zero.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMEQ--register---Compare-bitwise-equal--vector--"
    )
    this["cmge"] = OpCodeDoc(
        "CMGE",
        """Compare signed Greater than or Equal (vector). This instruction compares each
vector element in the first source SIMD&FP register with the corresponding
vector element in the second source SIMD&FP register and if the first signed
integer value is greater than or equal to the second signed integer value sets
every bit of the corresponding vector element in the destination SIMD&FP
register to one, otherwise sets every bit of the corresponding vector element
in the destination SIMD&FP register to zero.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMGE--register---Compare-signed-greater-than-or-equal--vector--"
    )
    this["cmgt"] = OpCodeDoc(
        "CMGT",
        """Compare signed Greater than (vector). This instruction compares each vector
element in the first source SIMD&FP register with the corresponding vector
element in the second source SIMD&FP register and if the first signed integer
value is greater than the second signed integer value sets every bit of the
corresponding vector element in the destination SIMD&FP register to one,
otherwise sets every bit of the corresponding vector element in the
destination SIMD&FP register to zero.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMGT--register---Compare-signed-greater-than--vector--"
    )
    this["cmhi"] = OpCodeDoc(
        "CMHI",
        """Compare unsigned Higher (vector). This instruction compares each vector
element in the first source SIMD&FP register with the corresponding vector
element in the second source SIMD&FP register and if the first unsigned
integer value is greater than the second unsigned integer value sets every bit
of the corresponding vector element in the destination SIMD&FP register to
one, otherwise sets every bit of the corresponding vector element in the
destination SIMD&FP register to zero.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMHI--register---Compare-unsigned-higher--vector--"
    )
    this["cmhs"] = OpCodeDoc(
        "CMHS",
        """Compare unsigned Higher or Same (vector). This instruction compares each
vector element in the first source SIMD&FP register with the corresponding
vector element in the second source SIMD&FP register and if the first unsigned
integer value is greater than or equal to the second unsigned integer value
sets every bit of the corresponding vector element in the destination SIMD&FP
register to one, otherwise sets every bit of the corresponding vector element
in the destination SIMD&FP register to zero.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMHS--register---Compare-unsigned-higher-or-same--vector--"
    )
    this["cmla"] = OpCodeDoc(
        "CMLA",
        """Multiply the duplicated real components for rotations 0 and 180, or imaginary
components for rotations 90 and 270, of the integral numbers in the first
source vector by the corresponding complex number in the second source vector
rotated by 0, 90, 180 or 270 degrees in the direction from the positive real
axis towards the positive imaginary axis, when considered in polar
representation.

Then add the products to the corresponding components of the complex numbers
in the addend vector. Destructively place the results in the corresponding
elements of the addend vector. This instruction is unpredicated.

These transformations permit the creation of a variety of multiply-add and
multiply-subtract operations on complex numbers by combining two of these
instructions with the same vector operands but with rotations that are 90
degrees apart.

Each complex number is represented in a vector register as an even/odd pair of
elements with the real part in the even-numbered element and the imaginary
part in the odd-numbered element.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMLA--vectors----"
    )
    this["cmle"] = OpCodeDoc(
        "CMLE",
        """Compare signed Less than or Equal to zero (vector). This instruction reads
each vector element in the source SIMD&FP register and if the signed integer
value is less than or equal to zero sets every bit of the corresponding vector
element in the destination SIMD&FP register to one, otherwise sets every bit
of the corresponding vector element in the destination SIMD&FP register to
zero.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMLE--zero---Compare-signed-less-than-or-equal-to-zero--vector--"
    )
    this["cmlt"] = OpCodeDoc(
        "CMLT",
        """Compare signed Less than zero (vector). This instruction reads each vector
element in the source SIMD&FP register and if the signed integer value is less
than zero sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the
corresponding vector element in the destination SIMD&FP register to zero.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMLT--zero---Compare-signed-less-than-zero--vector--"
    )
    this["cmn"] = OpCodeDoc(
        "CMN",
        """Compare Negative (extended register) adds a register value and a sign or zero-
extended register value, followed by an optional left shift amount. The
argument that is extended from the <Rm> register can be a byte, halfword,
word, or doubleword. It updates the condition flags based on the result, and
discards the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMN--extended-register---Compare-negative--extended-register--"
    )
    this["cmn"] = OpCodeDoc(
        "CMN",
        """Compare Negative (immediate) adds a register value and an optionally-shifted
immediate value. It updates the condition flags based on the result, and
discards the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMN--immediate---Compare-negative--immediate--"
    )
    this["cmp"] = OpCodeDoc(
        "CMP",
        """Compare (extended register) subtracts a sign or zero-extended register value,
followed by an optional left shift amount, from a register value. The argument
that is extended from the <Rm> register can be a byte, halfword, word, or
doubleword. It updates the condition flags based on the result, and discards
the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP--extended-register---Compare--extended-register--"
    )
    this["cmp"] = OpCodeDoc(
        "CMP",
        """Compare (immediate) subtracts an optionally-shifted immediate value from a
register value. It updates the condition flags based on the result, and
discards the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP--immediate---Compare--immediate--"
    )
    this["cmp<cc>"] = OpCodeDoc(
        "CMP<cc>",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpal"] = OpCodeDoc(
        "CMPAL",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpcc"] = OpCodeDoc(
        "CMPCC",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpcs"] = OpCodeDoc(
        "CMPCS",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpeq"] = OpCodeDoc(
        "CMPEQ",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpge"] = OpCodeDoc(
        "CMPGE",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpgt"] = OpCodeDoc(
        "CMPGT",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmphi"] = OpCodeDoc(
        "CMPHI",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmple"] = OpCodeDoc(
        "CMPLE",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpls"] = OpCodeDoc(
        "CMPLS",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmplt"] = OpCodeDoc(
        "CMPLT",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpmi"] = OpCodeDoc(
        "CMPMI",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpne"] = OpCodeDoc(
        "CMPNE",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmppl"] = OpCodeDoc(
        "CMPPL",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpvc"] = OpCodeDoc(
        "CMPVC",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmpvs"] = OpCodeDoc(
        "CMPVS",
        """Compare active integer elements in the source vector with an immediate, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMP-cc---immediate----"
    )
    this["cmplo"] = OpCodeDoc(
        "CMPLO",
        """Compare active unsigned integer elements in the first source vector being
lower than corresponding unsigned elements in the second source vector, and
place the boolean results of the comparison in the corresponding elements of
the destination predicate. Inactive elements in the destination predicate
register are set to zero. Sets the First (N), None (Z), !Last (C) condition
flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMPLO--vectors----"
    )
    this["cmpp"] = OpCodeDoc(
        "CMPP",
        """Compare with Tag subtracts the 56-bit address held in the second source
register from the 56-bit address held in the first source register, updates
the condition flags based on the result of the subtraction, and discards the
result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMPP--Compare-with-tag-"
    )
    this["cmtst"] = OpCodeDoc(
        "CMTST",
        """Compare bitwise Test bits nonzero (vector). This instruction reads each vector
element in the first source SIMD&FP register, performs an AND with the
corresponding vector element in the second source SIMD&FP register, and if the
result is not zero, sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the
corresponding vector element in the destination SIMD&FP register to zero.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CMTST--Compare-bitwise-test-bits-nonzero--vector--"
    )
    this["cneg"] = OpCodeDoc(
        "CNEG",
        """Conditional Negate returns, in the destination register, the negated value of
the source register if the condition is TRUE, and otherwise returns the value
of the source register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CNEG--Conditional-negate-"
    )
    this["cnot"] = OpCodeDoc(
        "CNOT",
        """Logically invert the boolean value in each active element of the source
vector, and place the results in the corresponding elements of the destination
vector. Inactive elements in the destination vector register remain
unmodified.

Boolean TRUE is any non-zero value in a source, and one in a result element.
Boolean FALSE is always zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CNOT---"
    )
    this["cnt"] = OpCodeDoc(
        "CNT",
        """Count bits counts the number of binary one bits in the value of the source
register, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CNT--Count-bits-"
    )
    this["cntb"] = OpCodeDoc(
        "CNTB",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then places the result in the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CNTB--CNTD--CNTH--CNTW---"
    )
    this["cntd"] = OpCodeDoc(
        "CNTD",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then places the result in the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CNTB--CNTD--CNTH--CNTW---"
    )
    this["cnth"] = OpCodeDoc(
        "CNTH",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then places the result in the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CNTB--CNTD--CNTH--CNTW---"
    )
    this["cntw"] = OpCodeDoc(
        "CNTW",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then places the result in the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CNTB--CNTD--CNTH--CNTW---"
    )
    this["cntp"] = OpCodeDoc(
        "CNTP",
        """Counts the number of active and true elements in the source predicate and
places the scalar result in the destination general-purpose register. Inactive
predicate elements are not counted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CNTP--predicate----"
    )
    this["compact"] = OpCodeDoc(
        "COMPACT",
        """Read the active elements from the source vector and pack them into the lowest-
numbered elements of the destination vector. Then set any remaining elements
of the destination vector to zero.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/COMPACT---"
    )
    this["cosp"] = OpCodeDoc(
        "COSP",
        """Clear Other Speculative Predictions by Context prevents predictions, other
than Cache prefetch, Control flow, and Data Value predictions, that predict
execution addresses based on information gathered from earlier execution
within a particular execution context. Predictions, other than Cache prefetch,
Control flow, and Data Value predictions, determined by the actions of code in
the target execution context or contexts appearing in program order before the
instruction cannot exploitatively control any speculative access occurring
after the instruction is complete and synchronized.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/COSP--Clear-other-speculative-predictions-by-context-"
    )
    this["cpp"] = OpCodeDoc(
        "CPP",
        """Cache Prefetch Prediction Restriction by Context prevents cache allocation
predictions that predict execution addresses based on information gathered
from earlier execution within a particular execution context. The actions of
code in the target execution context or contexts appearing in program order
before the instruction cannot exploitatively control cache prefetch
predictions occurring after the instruction is complete and synchronized.

For more information, see CPP RCTX, Cache Prefetch Prediction Restriction by
Context.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPP--Cache-prefetch-prediction-restriction-by-context-"
    )
    this["cpy"] = OpCodeDoc(
        "CPY",
        """Copy a signed integer immediate to each active element in the destination
vector. Inactive elements in the destination vector register are set to zero.

The immediate operand is a signed value in the range -128 to +127, and for
element widths of 16 bits or higher it may also be a signed multiple of 256 in
the range -32768 to +32512 (excluding 0).

The immediate is encoded in 8 bits with an optional left shift by 8. The
preferred disassembly when the shift option is specified is "#<simm8>, LSL
#8". However an assembler and disassembler may also allow use of the shifted
16-bit value unless the immediate is 0 and the shift amount is 8, which must
be unambiguously described as "#0, LSL #8".

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPY--immediate--zeroing----"
    )
    this["cpyfe"] = OpCodeDoc(
        "CPYFE",
        """Memory Copy Forward-only. These instructions perform a memory copy. The
prologue, main, and epilogue instructions are expected to be run in succession
and to appear consecutively in memory: CPYFP, then CPYFM, and then CPYFE.

CPYFP performs some preconditioning of the arguments suitable for using the
CPYFM instruction, and performs an implementation defined amount of the memory
copy. CPYFM performs an implementation defined amount of the memory copy.
CPYFE performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFP, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFP, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFP--CPYFM--CPYFE--Memory-copy-forward-only-"
    )
    this["cpyfm"] = OpCodeDoc(
        "CPYFM",
        """Memory Copy Forward-only. These instructions perform a memory copy. The
prologue, main, and epilogue instructions are expected to be run in succession
and to appear consecutively in memory: CPYFP, then CPYFM, and then CPYFE.

CPYFP performs some preconditioning of the arguments suitable for using the
CPYFM instruction, and performs an implementation defined amount of the memory
copy. CPYFM performs an implementation defined amount of the memory copy.
CPYFE performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFP, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFP, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFP--CPYFM--CPYFE--Memory-copy-forward-only-"
    )
    this["cpyfp"] = OpCodeDoc(
        "CPYFP",
        """Memory Copy Forward-only. These instructions perform a memory copy. The
prologue, main, and epilogue instructions are expected to be run in succession
and to appear consecutively in memory: CPYFP, then CPYFM, and then CPYFE.

CPYFP performs some preconditioning of the arguments suitable for using the
CPYFM instruction, and performs an implementation defined amount of the memory
copy. CPYFM performs an implementation defined amount of the memory copy.
CPYFE performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFP, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFP, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFP--CPYFM--CPYFE--Memory-copy-forward-only-"
    )
    this["cpyfen"] = OpCodeDoc(
        "CPYFEN",
        """Memory Copy Forward-only, reads and writes non-temporal. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYFPN, then CPYFMN, and then CPYFEN.

CPYFPN performs some preconditioning of the arguments suitable for using the
CPYFMN instruction, and performs an implementation defined amount of the
memory copy. CPYFMN performs an implementation defined amount of the memory
copy. CPYFEN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPN--CPYFMN--CPYFEN--Memory-copy-forward-only--reads-and-writes-non-temporal-"
    )
    this["cpyfmn"] = OpCodeDoc(
        "CPYFMN",
        """Memory Copy Forward-only, reads and writes non-temporal. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYFPN, then CPYFMN, and then CPYFEN.

CPYFPN performs some preconditioning of the arguments suitable for using the
CPYFMN instruction, and performs an implementation defined amount of the
memory copy. CPYFMN performs an implementation defined amount of the memory
copy. CPYFEN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPN--CPYFMN--CPYFEN--Memory-copy-forward-only--reads-and-writes-non-temporal-"
    )
    this["cpyfpn"] = OpCodeDoc(
        "CPYFPN",
        """Memory Copy Forward-only, reads and writes non-temporal. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYFPN, then CPYFMN, and then CPYFEN.

CPYFPN performs some preconditioning of the arguments suitable for using the
CPYFMN instruction, and performs an implementation defined amount of the
memory copy. CPYFMN performs an implementation defined amount of the memory
copy. CPYFEN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPN--CPYFMN--CPYFEN--Memory-copy-forward-only--reads-and-writes-non-temporal-"
    )
    this["cpyfern"] = OpCodeDoc(
        "CPYFERN",
        """Memory Copy Forward-only, reads non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPRN, then
CPYFMRN, and then CPYFERN.

CPYFPRN performs some preconditioning of the arguments suitable for using the
CPYFMRN instruction, and performs an implementation defined amount of the
memory copy. CPYFMRN performs an implementation defined amount of the memory
copy. CPYFERN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRN--CPYFMRN--CPYFERN--Memory-copy-forward-only--reads-non-temporal-"
    )
    this["cpyfmrn"] = OpCodeDoc(
        "CPYFMRN",
        """Memory Copy Forward-only, reads non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPRN, then
CPYFMRN, and then CPYFERN.

CPYFPRN performs some preconditioning of the arguments suitable for using the
CPYFMRN instruction, and performs an implementation defined amount of the
memory copy. CPYFMRN performs an implementation defined amount of the memory
copy. CPYFERN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRN--CPYFMRN--CPYFERN--Memory-copy-forward-only--reads-non-temporal-"
    )
    this["cpyfprn"] = OpCodeDoc(
        "CPYFPRN",
        """Memory Copy Forward-only, reads non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPRN, then
CPYFMRN, and then CPYFERN.

CPYFPRN performs some preconditioning of the arguments suitable for using the
CPYFMRN instruction, and performs an implementation defined amount of the
memory copy. CPYFMRN performs an implementation defined amount of the memory
copy. CPYFERN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRN--CPYFMRN--CPYFERN--Memory-copy-forward-only--reads-non-temporal-"
    )
    this["cpyfert"] = OpCodeDoc(
        "CPYFERT",
        """Memory Copy Forward-only, reads unprivileged. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPRT, then
CPYFMRT, and then CPYFERT.

CPYFPRT performs some preconditioning of the arguments suitable for using the
CPYFMRT instruction, and performs an implementation defined amount of the
memory copy. CPYFMRT performs an implementation defined amount of the memory
copy. CPYFERT performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRT--CPYFMRT--CPYFERT--Memory-copy-forward-only--reads-unprivileged-"
    )
    this["cpyfmrt"] = OpCodeDoc(
        "CPYFMRT",
        """Memory Copy Forward-only, reads unprivileged. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPRT, then
CPYFMRT, and then CPYFERT.

CPYFPRT performs some preconditioning of the arguments suitable for using the
CPYFMRT instruction, and performs an implementation defined amount of the
memory copy. CPYFMRT performs an implementation defined amount of the memory
copy. CPYFERT performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRT--CPYFMRT--CPYFERT--Memory-copy-forward-only--reads-unprivileged-"
    )
    this["cpyfprt"] = OpCodeDoc(
        "CPYFPRT",
        """Memory Copy Forward-only, reads unprivileged. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPRT, then
CPYFMRT, and then CPYFERT.

CPYFPRT performs some preconditioning of the arguments suitable for using the
CPYFMRT instruction, and performs an implementation defined amount of the
memory copy. CPYFMRT performs an implementation defined amount of the memory
copy. CPYFERT performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRT--CPYFMRT--CPYFERT--Memory-copy-forward-only--reads-unprivileged-"
    )
    this["cpyfertn"] = OpCodeDoc(
        "CPYFERTN",
        """Memory Copy Forward-only, reads unprivileged, reads and writes non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPRTN, then CPYFMRTN, and then CPYFERTN.

CPYFPRTN performs some preconditioning of the arguments suitable for using the
CPYFMRTN instruction, and performs an implementation defined amount of the
memory copy. CPYFMRTN performs an implementation defined amount of the memory
copy. CPYFERTN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRTN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRTN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRTN--CPYFMRTN--CPYFERTN--Memory-copy-forward-only--reads-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpyfmrtn"] = OpCodeDoc(
        "CPYFMRTN",
        """Memory Copy Forward-only, reads unprivileged, reads and writes non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPRTN, then CPYFMRTN, and then CPYFERTN.

CPYFPRTN performs some preconditioning of the arguments suitable for using the
CPYFMRTN instruction, and performs an implementation defined amount of the
memory copy. CPYFMRTN performs an implementation defined amount of the memory
copy. CPYFERTN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRTN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRTN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRTN--CPYFMRTN--CPYFERTN--Memory-copy-forward-only--reads-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpyfprtn"] = OpCodeDoc(
        "CPYFPRTN",
        """Memory Copy Forward-only, reads unprivileged, reads and writes non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPRTN, then CPYFMRTN, and then CPYFERTN.

CPYFPRTN performs some preconditioning of the arguments suitable for using the
CPYFMRTN instruction, and performs an implementation defined amount of the
memory copy. CPYFMRTN performs an implementation defined amount of the memory
copy. CPYFERTN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRTN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRTN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRTN--CPYFMRTN--CPYFERTN--Memory-copy-forward-only--reads-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpyfertrn"] = OpCodeDoc(
        "CPYFERTRN",
        """Memory Copy Forward-only, reads unprivileged and non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPRTRN, then CPYFMRTRN, and then CPYFERTRN.

CPYFPRTRN performs some preconditioning of the arguments suitable for using
the CPYFMRTRN instruction, and performs an implementation defined amount of
the memory copy. CPYFMRTRN performs an implementation defined amount of the
memory copy. CPYFERTRN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRTRN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRTRN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERTRN option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRTRN--CPYFMRTRN--CPYFERTRN--Memory-copy-forward-only--reads-unprivileged-and-non-temporal-"
    )
    this["cpyfmrtrn"] = OpCodeDoc(
        "CPYFMRTRN",
        """Memory Copy Forward-only, reads unprivileged and non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPRTRN, then CPYFMRTRN, and then CPYFERTRN.

CPYFPRTRN performs some preconditioning of the arguments suitable for using
the CPYFMRTRN instruction, and performs an implementation defined amount of
the memory copy. CPYFMRTRN performs an implementation defined amount of the
memory copy. CPYFERTRN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRTRN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRTRN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERTRN option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRTRN--CPYFMRTRN--CPYFERTRN--Memory-copy-forward-only--reads-unprivileged-and-non-temporal-"
    )
    this["cpyfprtrn"] = OpCodeDoc(
        "CPYFPRTRN",
        """Memory Copy Forward-only, reads unprivileged and non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPRTRN, then CPYFMRTRN, and then CPYFERTRN.

CPYFPRTRN performs some preconditioning of the arguments suitable for using
the CPYFMRTRN instruction, and performs an implementation defined amount of
the memory copy. CPYFMRTRN performs an implementation defined amount of the
memory copy. CPYFERTRN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRTRN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRTRN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERTRN option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRTRN--CPYFMRTRN--CPYFERTRN--Memory-copy-forward-only--reads-unprivileged-and-non-temporal-"
    )
    this["cpyfertwn"] = OpCodeDoc(
        "CPYFERTWN",
        """Memory Copy Forward-only, reads unprivileged, writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPRTWN, then CPYFMRTWN, and then CPYFERTWN.

CPYFPRTWN performs some preconditioning of the arguments suitable for using
the CPYFMRTWN instruction, and performs an implementation defined amount of
the memory copy. CPYFMRTWN performs an implementation defined amount of the
memory copy. CPYFERTWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRTWN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRTWN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRTWN--CPYFMRTWN--CPYFERTWN--Memory-copy-forward-only--reads-unprivileged--writes-non-temporal-"
    )
    this["cpyfmrtwn"] = OpCodeDoc(
        "CPYFMRTWN",
        """Memory Copy Forward-only, reads unprivileged, writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPRTWN, then CPYFMRTWN, and then CPYFERTWN.

CPYFPRTWN performs some preconditioning of the arguments suitable for using
the CPYFMRTWN instruction, and performs an implementation defined amount of
the memory copy. CPYFMRTWN performs an implementation defined amount of the
memory copy. CPYFERTWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRTWN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRTWN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRTWN--CPYFMRTWN--CPYFERTWN--Memory-copy-forward-only--reads-unprivileged--writes-non-temporal-"
    )
    this["cpyfprtwn"] = OpCodeDoc(
        "CPYFPRTWN",
        """Memory Copy Forward-only, reads unprivileged, writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPRTWN, then CPYFMRTWN, and then CPYFERTWN.

CPYFPRTWN performs some preconditioning of the arguments suitable for using
the CPYFMRTWN instruction, and performs an implementation defined amount of
the memory copy. CPYFMRTWN performs an implementation defined amount of the
memory copy. CPYFERTWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPRTWN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPRTWN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMRTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMRTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFERTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFERTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPRTWN--CPYFMRTWN--CPYFERTWN--Memory-copy-forward-only--reads-unprivileged--writes-non-temporal-"
    )
    this["cpyfet"] = OpCodeDoc(
        "CPYFET",
        """Memory Copy Forward-only, reads and writes unprivileged. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYFPT, then CPYFMT, and then CPYFET.

CPYFPT performs some preconditioning of the arguments suitable for using the
CPYFMT instruction, and performs an implementation defined amount of the
memory copy. CPYFMT performs an implementation defined amount of the memory
copy. CPYFET performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFET, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFET, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPT--CPYFMT--CPYFET--Memory-copy-forward-only--reads-and-writes-unprivileged-"
    )
    this["cpyfmt"] = OpCodeDoc(
        "CPYFMT",
        """Memory Copy Forward-only, reads and writes unprivileged. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYFPT, then CPYFMT, and then CPYFET.

CPYFPT performs some preconditioning of the arguments suitable for using the
CPYFMT instruction, and performs an implementation defined amount of the
memory copy. CPYFMT performs an implementation defined amount of the memory
copy. CPYFET performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFET, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFET, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPT--CPYFMT--CPYFET--Memory-copy-forward-only--reads-and-writes-unprivileged-"
    )
    this["cpyfpt"] = OpCodeDoc(
        "CPYFPT",
        """Memory Copy Forward-only, reads and writes unprivileged. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYFPT, then CPYFMT, and then CPYFET.

CPYFPT performs some preconditioning of the arguments suitable for using the
CPYFMT instruction, and performs an implementation defined amount of the
memory copy. CPYFMT performs an implementation defined amount of the memory
copy. CPYFET performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFET, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFET, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPT--CPYFMT--CPYFET--Memory-copy-forward-only--reads-and-writes-unprivileged-"
    )
    this["cpyfetn"] = OpCodeDoc(
        "CPYFETN",
        """Memory Copy Forward-only, reads and writes unprivileged and non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPTN, then CPYFMTN, and then CPYFETN.

CPYFPTN performs some preconditioning of the arguments suitable for using the
CPYFMTN instruction, and performs an implementation defined amount of the
memory copy. CPYFMTN performs an implementation defined amount of the memory
copy. CPYFETN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPTN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPTN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPTN--CPYFMTN--CPYFETN--Memory-copy-forward-only--reads-and-writes-unprivileged-and-non-temporal-"
    )
    this["cpyfmtn"] = OpCodeDoc(
        "CPYFMTN",
        """Memory Copy Forward-only, reads and writes unprivileged and non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPTN, then CPYFMTN, and then CPYFETN.

CPYFPTN performs some preconditioning of the arguments suitable for using the
CPYFMTN instruction, and performs an implementation defined amount of the
memory copy. CPYFMTN performs an implementation defined amount of the memory
copy. CPYFETN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPTN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPTN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPTN--CPYFMTN--CPYFETN--Memory-copy-forward-only--reads-and-writes-unprivileged-and-non-temporal-"
    )
    this["cpyfptn"] = OpCodeDoc(
        "CPYFPTN",
        """Memory Copy Forward-only, reads and writes unprivileged and non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPTN, then CPYFMTN, and then CPYFETN.

CPYFPTN performs some preconditioning of the arguments suitable for using the
CPYFMTN instruction, and performs an implementation defined amount of the
memory copy. CPYFMTN performs an implementation defined amount of the memory
copy. CPYFETN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPTN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPTN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPTN--CPYFMTN--CPYFETN--Memory-copy-forward-only--reads-and-writes-unprivileged-and-non-temporal-"
    )
    this["cpyfetrn"] = OpCodeDoc(
        "CPYFETRN",
        """Memory Copy Forward-only, reads and writes unprivileged, reads non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPTRN, then CPYFMTRN, and then CPYFETRN.

CPYFPTRN performs some preconditioning of the arguments suitable for using the
CPYFMTRN instruction, and performs an implementation defined amount of the
memory copy. CPYFMTRN performs an implementation defined amount of the memory
copy. CPYFETRN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPTRN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPTRN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFETRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFETRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPTRN--CPYFMTRN--CPYFETRN--Memory-copy-forward-only--reads-and-writes-unprivileged--reads-non-temporal-"
    )
    this["cpyfmtrn"] = OpCodeDoc(
        "CPYFMTRN",
        """Memory Copy Forward-only, reads and writes unprivileged, reads non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPTRN, then CPYFMTRN, and then CPYFETRN.

CPYFPTRN performs some preconditioning of the arguments suitable for using the
CPYFMTRN instruction, and performs an implementation defined amount of the
memory copy. CPYFMTRN performs an implementation defined amount of the memory
copy. CPYFETRN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPTRN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPTRN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFETRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFETRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPTRN--CPYFMTRN--CPYFETRN--Memory-copy-forward-only--reads-and-writes-unprivileged--reads-non-temporal-"
    )
    this["cpyfptrn"] = OpCodeDoc(
        "CPYFPTRN",
        """Memory Copy Forward-only, reads and writes unprivileged, reads non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPTRN, then CPYFMTRN, and then CPYFETRN.

CPYFPTRN performs some preconditioning of the arguments suitable for using the
CPYFMTRN instruction, and performs an implementation defined amount of the
memory copy. CPYFMTRN performs an implementation defined amount of the memory
copy. CPYFETRN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPTRN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPTRN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFETRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFETRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPTRN--CPYFMTRN--CPYFETRN--Memory-copy-forward-only--reads-and-writes-unprivileged--reads-non-temporal-"
    )
    this["cpyfetwn"] = OpCodeDoc(
        "CPYFETWN",
        """Memory Copy Forward-only, reads and writes unprivileged, writes non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPTWN, then CPYFMTWN, and then CPYFETWN.

CPYFPTWN performs some preconditioning of the arguments suitable for using the
CPYFMTWN instruction, and performs an implementation defined amount of the
memory copy. CPYFMTWN performs an implementation defined amount of the memory
copy. CPYFETWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPTWN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPTWN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFETWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFETWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPTWN--CPYFMTWN--CPYFETWN--Memory-copy-forward-only--reads-and-writes-unprivileged--writes-non-temporal-"
    )
    this["cpyfmtwn"] = OpCodeDoc(
        "CPYFMTWN",
        """Memory Copy Forward-only, reads and writes unprivileged, writes non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPTWN, then CPYFMTWN, and then CPYFETWN.

CPYFPTWN performs some preconditioning of the arguments suitable for using the
CPYFMTWN instruction, and performs an implementation defined amount of the
memory copy. CPYFMTWN performs an implementation defined amount of the memory
copy. CPYFETWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPTWN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPTWN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFETWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFETWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPTWN--CPYFMTWN--CPYFETWN--Memory-copy-forward-only--reads-and-writes-unprivileged--writes-non-temporal-"
    )
    this["cpyfptwn"] = OpCodeDoc(
        "CPYFPTWN",
        """Memory Copy Forward-only, reads and writes unprivileged, writes non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPTWN, then CPYFMTWN, and then CPYFETWN.

CPYFPTWN performs some preconditioning of the arguments suitable for using the
CPYFMTWN instruction, and performs an implementation defined amount of the
memory copy. CPYFMTWN performs an implementation defined amount of the memory
copy. CPYFETWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPTWN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPTWN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFETWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFETWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPTWN--CPYFMTWN--CPYFETWN--Memory-copy-forward-only--reads-and-writes-unprivileged--writes-non-temporal-"
    )
    this["cpyfewn"] = OpCodeDoc(
        "CPYFEWN",
        """Memory Copy Forward-only, writes non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPWN, then
CPYFMWN, and then CPYFEWN.

CPYFPWN performs some preconditioning of the arguments suitable for using the
CPYFMWN instruction, and performs an implementation defined amount of the
memory copy. CPYFMWN performs an implementation defined amount of the memory
copy. CPYFEWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWN--CPYFMWN--CPYFEWN--Memory-copy-forward-only--writes-non-temporal-"
    )
    this["cpyfmwn"] = OpCodeDoc(
        "CPYFMWN",
        """Memory Copy Forward-only, writes non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPWN, then
CPYFMWN, and then CPYFEWN.

CPYFPWN performs some preconditioning of the arguments suitable for using the
CPYFMWN instruction, and performs an implementation defined amount of the
memory copy. CPYFMWN performs an implementation defined amount of the memory
copy. CPYFEWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWN--CPYFMWN--CPYFEWN--Memory-copy-forward-only--writes-non-temporal-"
    )
    this["cpyfpwn"] = OpCodeDoc(
        "CPYFPWN",
        """Memory Copy Forward-only, writes non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPWN, then
CPYFMWN, and then CPYFEWN.

CPYFPWN performs some preconditioning of the arguments suitable for using the
CPYFMWN instruction, and performs an implementation defined amount of the
memory copy. CPYFMWN performs an implementation defined amount of the memory
copy. CPYFEWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWN--CPYFMWN--CPYFEWN--Memory-copy-forward-only--writes-non-temporal-"
    )
    this["cpyfewt"] = OpCodeDoc(
        "CPYFEWT",
        """Memory Copy Forward-only, writes unprivileged. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPWT, then
CPYFMWT, and then CPYFEWT.

CPYFPWT performs some preconditioning of the arguments suitable for using the
CPYFMWT instruction, and performs an implementation defined amount of the
memory copy. CPYFMWT performs an implementation defined amount of the memory
copy. CPYFEWT performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWT--CPYFMWT--CPYFEWT--Memory-copy-forward-only--writes-unprivileged-"
    )
    this["cpyfmwt"] = OpCodeDoc(
        "CPYFMWT",
        """Memory Copy Forward-only, writes unprivileged. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPWT, then
CPYFMWT, and then CPYFEWT.

CPYFPWT performs some preconditioning of the arguments suitable for using the
CPYFMWT instruction, and performs an implementation defined amount of the
memory copy. CPYFMWT performs an implementation defined amount of the memory
copy. CPYFEWT performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWT--CPYFMWT--CPYFEWT--Memory-copy-forward-only--writes-unprivileged-"
    )
    this["cpyfpwt"] = OpCodeDoc(
        "CPYFPWT",
        """Memory Copy Forward-only, writes unprivileged. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYFPWT, then
CPYFMWT, and then CPYFEWT.

CPYFPWT performs some preconditioning of the arguments suitable for using the
CPYFMWT instruction, and performs an implementation defined amount of the
memory copy. CPYFMWT performs an implementation defined amount of the memory
copy. CPYFEWT performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWT--CPYFMWT--CPYFEWT--Memory-copy-forward-only--writes-unprivileged-"
    )
    this["cpyfewtn"] = OpCodeDoc(
        "CPYFEWTN",
        """Memory Copy Forward-only, writes unprivileged, reads and writes non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPWTN, then CPYFMWTN, and then CPYFEWTN.

CPYFPWTN performs some preconditioning of the arguments suitable for using the
CPYFMWTN instruction, and performs an implementation defined amount of the
memory copy. CPYFMWTN performs an implementation defined amount of the memory
copy. CPYFEWTN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWTN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWTN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWTN--CPYFMWTN--CPYFEWTN--Memory-copy-forward-only--writes-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpyfmwtn"] = OpCodeDoc(
        "CPYFMWTN",
        """Memory Copy Forward-only, writes unprivileged, reads and writes non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPWTN, then CPYFMWTN, and then CPYFEWTN.

CPYFPWTN performs some preconditioning of the arguments suitable for using the
CPYFMWTN instruction, and performs an implementation defined amount of the
memory copy. CPYFMWTN performs an implementation defined amount of the memory
copy. CPYFEWTN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWTN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWTN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWTN--CPYFMWTN--CPYFEWTN--Memory-copy-forward-only--writes-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpyfpwtn"] = OpCodeDoc(
        "CPYFPWTN",
        """Memory Copy Forward-only, writes unprivileged, reads and writes non-temporal.
These instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPWTN, then CPYFMWTN, and then CPYFEWTN.

CPYFPWTN performs some preconditioning of the arguments suitable for using the
CPYFMWTN instruction, and performs an implementation defined amount of the
memory copy. CPYFMWTN performs an implementation defined amount of the memory
copy. CPYFEWTN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWTN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWTN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWTN--CPYFMWTN--CPYFEWTN--Memory-copy-forward-only--writes-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpyfewtrn"] = OpCodeDoc(
        "CPYFEWTRN",
        """Memory Copy Forward-only, writes unprivileged, reads non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPWTRN, then CPYFMWTRN, and then CPYFEWTRN.

CPYFPWTRN performs some preconditioning of the arguments suitable for using
the CPYFMWTRN instruction, and performs an implementation defined amount of
the memory copy. CPYFMWTRN performs an implementation defined amount of the
memory copy. CPYFEWTRN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWTRN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWTRN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWTRN--CPYFMWTRN--CPYFEWTRN--Memory-copy-forward-only--writes-unprivileged--reads-non-temporal-"
    )
    this["cpyfmwtrn"] = OpCodeDoc(
        "CPYFMWTRN",
        """Memory Copy Forward-only, writes unprivileged, reads non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPWTRN, then CPYFMWTRN, and then CPYFEWTRN.

CPYFPWTRN performs some preconditioning of the arguments suitable for using
the CPYFMWTRN instruction, and performs an implementation defined amount of
the memory copy. CPYFMWTRN performs an implementation defined amount of the
memory copy. CPYFEWTRN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWTRN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWTRN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWTRN--CPYFMWTRN--CPYFEWTRN--Memory-copy-forward-only--writes-unprivileged--reads-non-temporal-"
    )
    this["cpyfpwtrn"] = OpCodeDoc(
        "CPYFPWTRN",
        """Memory Copy Forward-only, writes unprivileged, reads non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPWTRN, then CPYFMWTRN, and then CPYFEWTRN.

CPYFPWTRN performs some preconditioning of the arguments suitable for using
the CPYFMWTRN instruction, and performs an implementation defined amount of
the memory copy. CPYFMWTRN performs an implementation defined amount of the
memory copy. CPYFEWTRN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWTRN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWTRN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWTRN--CPYFMWTRN--CPYFEWTRN--Memory-copy-forward-only--writes-unprivileged--reads-non-temporal-"
    )
    this["cpyfewtwn"] = OpCodeDoc(
        "CPYFEWTWN",
        """Memory Copy Forward-only, writes unprivileged and non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPWTWN, then CPYFMWTWN, and then CPYFEWTWN.

CPYFPWTWN performs some preconditioning of the arguments suitable for using
the CPYFMWTWN instruction, and performs an implementation defined amount of
the memory copy. CPYFMWTWN performs an implementation defined amount of the
memory copy. CPYFEWTWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWTWN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWTWN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWTWN--CPYFMWTWN--CPYFEWTWN--Memory-copy-forward-only--writes-unprivileged-and-non-temporal-"
    )
    this["cpyfmwtwn"] = OpCodeDoc(
        "CPYFMWTWN",
        """Memory Copy Forward-only, writes unprivileged and non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPWTWN, then CPYFMWTWN, and then CPYFEWTWN.

CPYFPWTWN performs some preconditioning of the arguments suitable for using
the CPYFMWTWN instruction, and performs an implementation defined amount of
the memory copy. CPYFMWTWN performs an implementation defined amount of the
memory copy. CPYFEWTWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWTWN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWTWN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWTWN--CPYFMWTWN--CPYFEWTWN--Memory-copy-forward-only--writes-unprivileged-and-non-temporal-"
    )
    this["cpyfpwtwn"] = OpCodeDoc(
        "CPYFPWTWN",
        """Memory Copy Forward-only, writes unprivileged and non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYFPWTWN, then CPYFMWTWN, and then CPYFEWTWN.

CPYFPWTWN performs some preconditioning of the arguments suitable for using
the CPYFMWTWN instruction, and performs an implementation defined amount of
the memory copy. CPYFMWTWN performs an implementation defined amount of the
memory copy. CPYFEWTWN performs the last part of the memory copy.

The memory copy performed by these instructions is in the forward direction
only, so the instructions are suitable for a memory copy only where there is
no overlap between the source and destination locations, or where the source
address is greater than the destination address.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYFPWTWN, option A (which results in encoding PSTATE.C =
0):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of CPYFPWTWN, option B (which results in encoding PSTATE.C =
1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For CPYFMWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.

For CPYFMWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

For CPYFEWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number and holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYFEWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYFPWTWN--CPYFMWTWN--CPYFEWTWN--Memory-copy-forward-only--writes-unprivileged-and-non-temporal-"
    )
    this["cpye"] = OpCodeDoc(
        "CPYE",
        """Memory Copy. These instructions perform a memory copy. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: CPYP, then CPYM, and then CPYE.

CPYP performs some preconditioning of the arguments suitable for using the
CPYM instruction, and performs an implementation defined amount of the memory
copy. CPYM performs an implementation defined amount of the memory copy. CPYE
performs the last part of the memory copy.

For CPYP, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYP, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYP, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is copied to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is made to.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from.
  * Xd holds the highest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYP--CPYM--CPYE--Memory-copy-"
    )
    this["cpym"] = OpCodeDoc(
        "CPYM",
        """Memory Copy. These instructions perform a memory copy. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: CPYP, then CPYM, and then CPYE.

CPYP performs some preconditioning of the arguments suitable for using the
CPYM instruction, and performs an implementation defined amount of the memory
copy. CPYM performs an implementation defined amount of the memory copy. CPYE
performs the last part of the memory copy.

For CPYP, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYP, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYP, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is copied to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is made to.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from.
  * Xd holds the highest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYP--CPYM--CPYE--Memory-copy-"
    )
    this["cpyp"] = OpCodeDoc(
        "CPYP",
        """Memory Copy. These instructions perform a memory copy. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: CPYP, then CPYM, and then CPYE.

CPYP performs some preconditioning of the arguments suitable for using the
CPYM instruction, and performs an implementation defined amount of the memory
copy. CPYM performs an implementation defined amount of the memory copy. CPYE
performs the last part of the memory copy.

For CPYP, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYP, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYP, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is copied to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is made to.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from.
  * Xd holds the highest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYP--CPYM--CPYE--Memory-copy-"
    )
    this["cpyen"] = OpCodeDoc(
        "CPYEN",
        """Memory Copy, reads and writes non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYPN, then CPYMN,
and then CPYEN.

CPYPN performs some preconditioning of the arguments suitable for using the
CPYMN instruction, and performs an implementation defined amount of the memory
copy. CPYMN performs an implementation defined amount of the memory copy.
CPYEN performs the last part of the memory copy.

For CPYPN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPN--CPYMN--CPYEN--Memory-copy--reads-and-writes-non-temporal-"
    )
    this["cpymn"] = OpCodeDoc(
        "CPYMN",
        """Memory Copy, reads and writes non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYPN, then CPYMN,
and then CPYEN.

CPYPN performs some preconditioning of the arguments suitable for using the
CPYMN instruction, and performs an implementation defined amount of the memory
copy. CPYMN performs an implementation defined amount of the memory copy.
CPYEN performs the last part of the memory copy.

For CPYPN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPN--CPYMN--CPYEN--Memory-copy--reads-and-writes-non-temporal-"
    )
    this["cpypn"] = OpCodeDoc(
        "CPYPN",
        """Memory Copy, reads and writes non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYPN, then CPYMN,
and then CPYEN.

CPYPN performs some preconditioning of the arguments suitable for using the
CPYMN instruction, and performs an implementation defined amount of the memory
copy. CPYMN performs an implementation defined amount of the memory copy.
CPYEN performs the last part of the memory copy.

For CPYPN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPN--CPYMN--CPYEN--Memory-copy--reads-and-writes-non-temporal-"
    )
    this["cpyern"] = OpCodeDoc(
        "CPYERN",
        """Memory Copy, reads non-temporal. These instructions perform a memory copy. The
prologue, main, and epilogue instructions are expected to be run in succession
and to appear consecutively in memory: CPYPRN, then CPYMRN, and then CPYERN.

CPYPRN performs some preconditioning of the arguments suitable for using the
CPYMRN instruction, and performs an implementation defined amount of the
memory copy. CPYMRN performs an implementation defined amount of the memory
copy. CPYERN performs the last part of the memory copy.

For CPYPRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRN--CPYMRN--CPYERN--Memory-copy--reads-non-temporal-"
    )
    this["cpymrn"] = OpCodeDoc(
        "CPYMRN",
        """Memory Copy, reads non-temporal. These instructions perform a memory copy. The
prologue, main, and epilogue instructions are expected to be run in succession
and to appear consecutively in memory: CPYPRN, then CPYMRN, and then CPYERN.

CPYPRN performs some preconditioning of the arguments suitable for using the
CPYMRN instruction, and performs an implementation defined amount of the
memory copy. CPYMRN performs an implementation defined amount of the memory
copy. CPYERN performs the last part of the memory copy.

For CPYPRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRN--CPYMRN--CPYERN--Memory-copy--reads-non-temporal-"
    )
    this["cpyprn"] = OpCodeDoc(
        "CPYPRN",
        """Memory Copy, reads non-temporal. These instructions perform a memory copy. The
prologue, main, and epilogue instructions are expected to be run in succession
and to appear consecutively in memory: CPYPRN, then CPYMRN, and then CPYERN.

CPYPRN performs some preconditioning of the arguments suitable for using the
CPYMRN instruction, and performs an implementation defined amount of the
memory copy. CPYMRN performs an implementation defined amount of the memory
copy. CPYERN performs the last part of the memory copy.

For CPYPRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRN--CPYMRN--CPYERN--Memory-copy--reads-non-temporal-"
    )
    this["cpyert"] = OpCodeDoc(
        "CPYERT",
        """Memory Copy, reads unprivileged. These instructions perform a memory copy. The
prologue, main, and epilogue instructions are expected to be run in succession
and to appear consecutively in memory: CPYPRT, then CPYMRT, and then CPYERT.

CPYPRT performs some preconditioning of the arguments suitable for using the
CPYMRT instruction, and performs an implementation defined amount of the
memory copy. CPYMRT performs an implementation defined amount of the memory
copy. CPYERT performs the last part of the memory copy.

For CPYPRT, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRT, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRT, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRT--CPYMRT--CPYERT--Memory-copy--reads-unprivileged-"
    )
    this["cpymrt"] = OpCodeDoc(
        "CPYMRT",
        """Memory Copy, reads unprivileged. These instructions perform a memory copy. The
prologue, main, and epilogue instructions are expected to be run in succession
and to appear consecutively in memory: CPYPRT, then CPYMRT, and then CPYERT.

CPYPRT performs some preconditioning of the arguments suitable for using the
CPYMRT instruction, and performs an implementation defined amount of the
memory copy. CPYMRT performs an implementation defined amount of the memory
copy. CPYERT performs the last part of the memory copy.

For CPYPRT, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRT, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRT, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRT--CPYMRT--CPYERT--Memory-copy--reads-unprivileged-"
    )
    this["cpyprt"] = OpCodeDoc(
        "CPYPRT",
        """Memory Copy, reads unprivileged. These instructions perform a memory copy. The
prologue, main, and epilogue instructions are expected to be run in succession
and to appear consecutively in memory: CPYPRT, then CPYMRT, and then CPYERT.

CPYPRT performs some preconditioning of the arguments suitable for using the
CPYMRT instruction, and performs an implementation defined amount of the
memory copy. CPYMRT performs an implementation defined amount of the memory
copy. CPYERT performs the last part of the memory copy.

For CPYPRT, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRT, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRT, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRT--CPYMRT--CPYERT--Memory-copy--reads-unprivileged-"
    )
    this["cpyertn"] = OpCodeDoc(
        "CPYERTN",
        """Memory Copy, reads unprivileged, reads and writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPRTN, then CPYMRTN, and then CPYERTN.

CPYPRTN performs some preconditioning of the arguments suitable for using the
CPYMRTN instruction, and performs an implementation defined amount of the
memory copy. CPYMRTN performs an implementation defined amount of the memory
copy. CPYERTN performs the last part of the memory copy.

For CPYPRTN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRTN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRTN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRTN--CPYMRTN--CPYERTN--Memory-copy--reads-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpymrtn"] = OpCodeDoc(
        "CPYMRTN",
        """Memory Copy, reads unprivileged, reads and writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPRTN, then CPYMRTN, and then CPYERTN.

CPYPRTN performs some preconditioning of the arguments suitable for using the
CPYMRTN instruction, and performs an implementation defined amount of the
memory copy. CPYMRTN performs an implementation defined amount of the memory
copy. CPYERTN performs the last part of the memory copy.

For CPYPRTN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRTN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRTN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRTN--CPYMRTN--CPYERTN--Memory-copy--reads-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpyprtn"] = OpCodeDoc(
        "CPYPRTN",
        """Memory Copy, reads unprivileged, reads and writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPRTN, then CPYMRTN, and then CPYERTN.

CPYPRTN performs some preconditioning of the arguments suitable for using the
CPYMRTN instruction, and performs an implementation defined amount of the
memory copy. CPYMRTN performs an implementation defined amount of the memory
copy. CPYERTN performs the last part of the memory copy.

For CPYPRTN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRTN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRTN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRTN--CPYMRTN--CPYERTN--Memory-copy--reads-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpyertrn"] = OpCodeDoc(
        "CPYERTRN",
        """Memory Copy, reads unprivileged and non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYPRTRN, then
CPYMRTRN, and then CPYERTRN.

CPYPRTRN performs some preconditioning of the arguments suitable for using the
CPYMRTRN instruction, and performs an implementation defined amount of the
memory copy. CPYMRTRN performs an implementation defined amount of the memory
copy. CPYERTRN performs the last part of the memory copy.

For CPYPRTRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRTRN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRTRN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRTRN--CPYMRTRN--CPYERTRN--Memory-copy--reads-unprivileged-and-non-temporal-"
    )
    this["cpymrtrn"] = OpCodeDoc(
        "CPYMRTRN",
        """Memory Copy, reads unprivileged and non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYPRTRN, then
CPYMRTRN, and then CPYERTRN.

CPYPRTRN performs some preconditioning of the arguments suitable for using the
CPYMRTRN instruction, and performs an implementation defined amount of the
memory copy. CPYMRTRN performs an implementation defined amount of the memory
copy. CPYERTRN performs the last part of the memory copy.

For CPYPRTRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRTRN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRTRN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRTRN--CPYMRTRN--CPYERTRN--Memory-copy--reads-unprivileged-and-non-temporal-"
    )
    this["cpyprtrn"] = OpCodeDoc(
        "CPYPRTRN",
        """Memory Copy, reads unprivileged and non-temporal. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYPRTRN, then
CPYMRTRN, and then CPYERTRN.

CPYPRTRN performs some preconditioning of the arguments suitable for using the
CPYMRTRN instruction, and performs an implementation defined amount of the
memory copy. CPYMRTRN performs an implementation defined amount of the memory
copy. CPYERTRN performs the last part of the memory copy.

For CPYPRTRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRTRN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRTRN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRTRN--CPYMRTRN--CPYERTRN--Memory-copy--reads-unprivileged-and-non-temporal-"
    )
    this["cpyertwn"] = OpCodeDoc(
        "CPYERTWN",
        """Memory Copy, reads unprivileged, writes non-temporal. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYPRTWN, then CPYMRTWN, and then CPYERTWN.

CPYPRTWN performs some preconditioning of the arguments suitable for using the
CPYMRTWN instruction, and performs an implementation defined amount of the
memory copy. CPYMRTWN performs an implementation defined amount of the memory
copy. CPYERTWN performs the last part of the memory copy.

For CPYPRTWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRTWN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRTWN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRTWN--CPYMRTWN--CPYERTWN--Memory-copy--reads-unprivileged--writes-non-temporal-"
    )
    this["cpymrtwn"] = OpCodeDoc(
        "CPYMRTWN",
        """Memory Copy, reads unprivileged, writes non-temporal. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYPRTWN, then CPYMRTWN, and then CPYERTWN.

CPYPRTWN performs some preconditioning of the arguments suitable for using the
CPYMRTWN instruction, and performs an implementation defined amount of the
memory copy. CPYMRTWN performs an implementation defined amount of the memory
copy. CPYERTWN performs the last part of the memory copy.

For CPYPRTWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRTWN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRTWN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRTWN--CPYMRTWN--CPYERTWN--Memory-copy--reads-unprivileged--writes-non-temporal-"
    )
    this["cpyprtwn"] = OpCodeDoc(
        "CPYPRTWN",
        """Memory Copy, reads unprivileged, writes non-temporal. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYPRTWN, then CPYMRTWN, and then CPYERTWN.

CPYPRTWN performs some preconditioning of the arguments suitable for using the
CPYMRTWN instruction, and performs an implementation defined amount of the
memory copy. CPYMRTWN performs an implementation defined amount of the memory
copy. CPYERTWN performs the last part of the memory copy.

For CPYPRTWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPRTWN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPRTWN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMRTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMRTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYERTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYERTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPRTWN--CPYMRTWN--CPYERTWN--Memory-copy--reads-unprivileged--writes-non-temporal-"
    )
    this["cpyet"] = OpCodeDoc(
        "CPYET",
        """Memory Copy, reads and writes unprivileged. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYPT, then CPYMT,
and then CPYET.

CPYPT performs some preconditioning of the arguments suitable for using the
CPYMT instruction, and performs an implementation defined amount of the memory
copy. CPYMT performs an implementation defined amount of the memory copy.
CPYET performs the last part of the memory copy.

For CPYPT, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPT, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPT, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMT, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMT, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYET, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYET, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPT--CPYMT--CPYET--Memory-copy--reads-and-writes-unprivileged-"
    )
    this["cpymt"] = OpCodeDoc(
        "CPYMT",
        """Memory Copy, reads and writes unprivileged. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYPT, then CPYMT,
and then CPYET.

CPYPT performs some preconditioning of the arguments suitable for using the
CPYMT instruction, and performs an implementation defined amount of the memory
copy. CPYMT performs an implementation defined amount of the memory copy.
CPYET performs the last part of the memory copy.

For CPYPT, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPT, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPT, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMT, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMT, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYET, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYET, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPT--CPYMT--CPYET--Memory-copy--reads-and-writes-unprivileged-"
    )
    this["cpypt"] = OpCodeDoc(
        "CPYPT",
        """Memory Copy, reads and writes unprivileged. These instructions perform a
memory copy. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: CPYPT, then CPYMT,
and then CPYET.

CPYPT performs some preconditioning of the arguments suitable for using the
CPYMT instruction, and performs an implementation defined amount of the memory
copy. CPYMT performs an implementation defined amount of the memory copy.
CPYET performs the last part of the memory copy.

For CPYPT, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPT, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPT, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMT, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMT, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYET, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYET, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPT--CPYMT--CPYET--Memory-copy--reads-and-writes-unprivileged-"
    )
    this["cpyetn"] = OpCodeDoc(
        "CPYETN",
        """Memory Copy, reads and writes unprivileged and non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPTN, then CPYMTN, and then CPYETN.

CPYPTN performs some preconditioning of the arguments suitable for using the
CPYMTN instruction, and performs an implementation defined amount of the
memory copy. CPYMTN performs an implementation defined amount of the memory
copy. CPYETN performs the last part of the memory copy.

For CPYPTN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPTN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPTN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPTN--CPYMTN--CPYETN--Memory-copy--reads-and-writes-unprivileged-and-non-temporal-"
    )
    this["cpymtn"] = OpCodeDoc(
        "CPYMTN",
        """Memory Copy, reads and writes unprivileged and non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPTN, then CPYMTN, and then CPYETN.

CPYPTN performs some preconditioning of the arguments suitable for using the
CPYMTN instruction, and performs an implementation defined amount of the
memory copy. CPYMTN performs an implementation defined amount of the memory
copy. CPYETN performs the last part of the memory copy.

For CPYPTN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPTN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPTN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPTN--CPYMTN--CPYETN--Memory-copy--reads-and-writes-unprivileged-and-non-temporal-"
    )
    this["cpyptn"] = OpCodeDoc(
        "CPYPTN",
        """Memory Copy, reads and writes unprivileged and non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPTN, then CPYMTN, and then CPYETN.

CPYPTN performs some preconditioning of the arguments suitable for using the
CPYMTN instruction, and performs an implementation defined amount of the
memory copy. CPYMTN performs an implementation defined amount of the memory
copy. CPYETN performs the last part of the memory copy.

For CPYPTN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPTN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPTN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPTN--CPYMTN--CPYETN--Memory-copy--reads-and-writes-unprivileged-and-non-temporal-"
    )
    this["cpyetrn"] = OpCodeDoc(
        "CPYETRN",
        """Memory Copy, reads and writes unprivileged, reads non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPTRN, then CPYMTRN, and then CPYETRN.

CPYPTRN performs some preconditioning of the arguments suitable for using the
CPYMTRN instruction, and performs an implementation defined amount of the
memory copy. CPYMTRN performs an implementation defined amount of the memory
copy. CPYETRN performs the last part of the memory copy.

For CPYPTRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPTRN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPTRN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYETRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYETRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPTRN--CPYMTRN--CPYETRN--Memory-copy--reads-and-writes-unprivileged--reads-non-temporal-"
    )
    this["cpymtrn"] = OpCodeDoc(
        "CPYMTRN",
        """Memory Copy, reads and writes unprivileged, reads non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPTRN, then CPYMTRN, and then CPYETRN.

CPYPTRN performs some preconditioning of the arguments suitable for using the
CPYMTRN instruction, and performs an implementation defined amount of the
memory copy. CPYMTRN performs an implementation defined amount of the memory
copy. CPYETRN performs the last part of the memory copy.

For CPYPTRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPTRN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPTRN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYETRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYETRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPTRN--CPYMTRN--CPYETRN--Memory-copy--reads-and-writes-unprivileged--reads-non-temporal-"
    )
    this["cpyptrn"] = OpCodeDoc(
        "CPYPTRN",
        """Memory Copy, reads and writes unprivileged, reads non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPTRN, then CPYMTRN, and then CPYETRN.

CPYPTRN performs some preconditioning of the arguments suitable for using the
CPYMTRN instruction, and performs an implementation defined amount of the
memory copy. CPYMTRN performs an implementation defined amount of the memory
copy. CPYETRN performs the last part of the memory copy.

For CPYPTRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPTRN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPTRN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYETRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYETRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPTRN--CPYMTRN--CPYETRN--Memory-copy--reads-and-writes-unprivileged--reads-non-temporal-"
    )
    this["cpyetwn"] = OpCodeDoc(
        "CPYETWN",
        """Memory Copy, reads and writes unprivileged, writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPTWN, then CPYMTWN, and then CPYETWN.

CPYPTWN performs some preconditioning of the arguments suitable for using the
CPYMTWN instruction, and performs an implementation defined amount of the
memory copy. CPYMTWN performs an implementation defined amount of the memory
copy. CPYETWN performs the last part of the memory copy.

For CPYPTWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPTWN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPTWN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYETWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYETWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPTWN--CPYMTWN--CPYETWN--Memory-copy--reads-and-writes-unprivileged--writes-non-temporal-"
    )
    this["cpymtwn"] = OpCodeDoc(
        "CPYMTWN",
        """Memory Copy, reads and writes unprivileged, writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPTWN, then CPYMTWN, and then CPYETWN.

CPYPTWN performs some preconditioning of the arguments suitable for using the
CPYMTWN instruction, and performs an implementation defined amount of the
memory copy. CPYMTWN performs an implementation defined amount of the memory
copy. CPYETWN performs the last part of the memory copy.

For CPYPTWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPTWN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPTWN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYETWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYETWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPTWN--CPYMTWN--CPYETWN--Memory-copy--reads-and-writes-unprivileged--writes-non-temporal-"
    )
    this["cpyptwn"] = OpCodeDoc(
        "CPYPTWN",
        """Memory Copy, reads and writes unprivileged, writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPTWN, then CPYMTWN, and then CPYETWN.

CPYPTWN performs some preconditioning of the arguments suitable for using the
CPYMTWN instruction, and performs an implementation defined amount of the
memory copy. CPYMTWN performs an implementation defined amount of the memory
copy. CPYETWN performs the last part of the memory copy.

For CPYPTWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPTWN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPTWN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYETWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYETWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPTWN--CPYMTWN--CPYETWN--Memory-copy--reads-and-writes-unprivileged--writes-non-temporal-"
    )
    this["cpyewn"] = OpCodeDoc(
        "CPYEWN",
        """Memory Copy, writes non-temporal. These instructions perform a memory copy.
The prologue, main, and epilogue instructions are expected to be run in
succession and to appear consecutively in memory: CPYPWN, then CPYMWN, and
then CPYEWN.

CPYPWN performs some preconditioning of the arguments suitable for using the
CPYMWN instruction, and performs an implementation defined amount of the
memory copy. CPYMWN performs an implementation defined amount of the memory
copy. CPYEWN performs the last part of the memory copy.

For CPYPWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWN--CPYMWN--CPYEWN--Memory-copy--writes-non-temporal-"
    )
    this["cpymwn"] = OpCodeDoc(
        "CPYMWN",
        """Memory Copy, writes non-temporal. These instructions perform a memory copy.
The prologue, main, and epilogue instructions are expected to be run in
succession and to appear consecutively in memory: CPYPWN, then CPYMWN, and
then CPYEWN.

CPYPWN performs some preconditioning of the arguments suitable for using the
CPYMWN instruction, and performs an implementation defined amount of the
memory copy. CPYMWN performs an implementation defined amount of the memory
copy. CPYEWN performs the last part of the memory copy.

For CPYPWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWN--CPYMWN--CPYEWN--Memory-copy--writes-non-temporal-"
    )
    this["cpypwn"] = OpCodeDoc(
        "CPYPWN",
        """Memory Copy, writes non-temporal. These instructions perform a memory copy.
The prologue, main, and epilogue instructions are expected to be run in
succession and to appear consecutively in memory: CPYPWN, then CPYMWN, and
then CPYEWN.

CPYPWN performs some preconditioning of the arguments suitable for using the
CPYMWN instruction, and performs an implementation defined amount of the
memory copy. CPYMWN performs an implementation defined amount of the memory
copy. CPYEWN performs the last part of the memory copy.

For CPYPWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWN--CPYMWN--CPYEWN--Memory-copy--writes-non-temporal-"
    )
    this["cpyewt"] = OpCodeDoc(
        "CPYEWT",
        """Memory Copy, writes unprivileged. These instructions perform a memory copy.
The prologue, main, and epilogue instructions are expected to be run in
succession and to appear consecutively in memory: CPYPWT, then CPYMWT, and
then CPYEWT.

CPYPWT performs some preconditioning of the arguments suitable for using the
CPYMWT instruction, and performs an implementation defined amount of the
memory copy. CPYMWT performs an implementation defined amount of the memory
copy. CPYEWT performs the last part of the memory copy.

For CPYPWT, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWT, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWT, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWT--CPYMWT--CPYEWT--Memory-copy--writes-unprivileged-"
    )
    this["cpymwt"] = OpCodeDoc(
        "CPYMWT",
        """Memory Copy, writes unprivileged. These instructions perform a memory copy.
The prologue, main, and epilogue instructions are expected to be run in
succession and to appear consecutively in memory: CPYPWT, then CPYMWT, and
then CPYEWT.

CPYPWT performs some preconditioning of the arguments suitable for using the
CPYMWT instruction, and performs an implementation defined amount of the
memory copy. CPYMWT performs an implementation defined amount of the memory
copy. CPYEWT performs the last part of the memory copy.

For CPYPWT, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWT, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWT, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWT--CPYMWT--CPYEWT--Memory-copy--writes-unprivileged-"
    )
    this["cpypwt"] = OpCodeDoc(
        "CPYPWT",
        """Memory Copy, writes unprivileged. These instructions perform a memory copy.
The prologue, main, and epilogue instructions are expected to be run in
succession and to appear consecutively in memory: CPYPWT, then CPYMWT, and
then CPYEWT.

CPYPWT performs some preconditioning of the arguments suitable for using the
CPYMWT instruction, and performs an implementation defined amount of the
memory copy. CPYMWT performs an implementation defined amount of the memory
copy. CPYEWT performs the last part of the memory copy.

For CPYPWT, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWT, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWT, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWT--CPYMWT--CPYEWT--Memory-copy--writes-unprivileged-"
    )
    this["cpyewtn"] = OpCodeDoc(
        "CPYEWTN",
        """Memory Copy, writes unprivileged, reads and writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPWTN, then CPYMWTN, and then CPYEWTN.

CPYPWTN performs some preconditioning of the arguments suitable for using the
CPYMWTN instruction, and performs an implementation defined amount of the
memory copy. CPYMWTN performs an implementation defined amount of the memory
copy. CPYEWTN performs the last part of the memory copy.

For CPYPWTN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWTN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWTN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWTN--CPYMWTN--CPYEWTN--Memory-copy--writes-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpymwtn"] = OpCodeDoc(
        "CPYMWTN",
        """Memory Copy, writes unprivileged, reads and writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPWTN, then CPYMWTN, and then CPYEWTN.

CPYPWTN performs some preconditioning of the arguments suitable for using the
CPYMWTN instruction, and performs an implementation defined amount of the
memory copy. CPYMWTN performs an implementation defined amount of the memory
copy. CPYEWTN performs the last part of the memory copy.

For CPYPWTN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWTN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWTN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWTN--CPYMWTN--CPYEWTN--Memory-copy--writes-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpypwtn"] = OpCodeDoc(
        "CPYPWTN",
        """Memory Copy, writes unprivileged, reads and writes non-temporal. These
instructions perform a memory copy. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: CPYPWTN, then CPYMWTN, and then CPYEWTN.

CPYPWTN performs some preconditioning of the arguments suitable for using the
CPYMWTN instruction, and performs an implementation defined amount of the
memory copy. CPYMWTN performs an implementation defined amount of the memory
copy. CPYEWTN performs the last part of the memory copy.

For CPYPWTN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWTN, option A (which results in encoding PSTATE.C = 0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWTN, option B (which results in encoding PSTATE.C = 1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWTN--CPYMWTN--CPYEWTN--Memory-copy--writes-unprivileged--reads-and-writes-non-temporal-"
    )
    this["cpyewtrn"] = OpCodeDoc(
        "CPYEWTRN",
        """Memory Copy, writes unprivileged, reads non-temporal. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYPWTRN, then CPYMWTRN, and then CPYEWTRN.

CPYPWTRN performs some preconditioning of the arguments suitable for using the
CPYMWTRN instruction, and performs an implementation defined amount of the
memory copy. CPYMWTRN performs an implementation defined amount of the memory
copy. CPYEWTRN performs the last part of the memory copy.

For CPYPWTRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWTRN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWTRN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWTRN--CPYMWTRN--CPYEWTRN--Memory-copy--writes-unprivileged--reads-non-temporal-"
    )
    this["cpymwtrn"] = OpCodeDoc(
        "CPYMWTRN",
        """Memory Copy, writes unprivileged, reads non-temporal. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYPWTRN, then CPYMWTRN, and then CPYEWTRN.

CPYPWTRN performs some preconditioning of the arguments suitable for using the
CPYMWTRN instruction, and performs an implementation defined amount of the
memory copy. CPYMWTRN performs an implementation defined amount of the memory
copy. CPYEWTRN performs the last part of the memory copy.

For CPYPWTRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWTRN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWTRN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWTRN--CPYMWTRN--CPYEWTRN--Memory-copy--writes-unprivileged--reads-non-temporal-"
    )
    this["cpypwtrn"] = OpCodeDoc(
        "CPYPWTRN",
        """Memory Copy, writes unprivileged, reads non-temporal. These instructions
perform a memory copy. The prologue, main, and epilogue instructions are
expected to be run in succession and to appear consecutively in memory:
CPYPWTRN, then CPYMWTRN, and then CPYEWTRN.

CPYPWTRN performs some preconditioning of the arguments suitable for using the
CPYMWTRN instruction, and performs an implementation defined amount of the
memory copy. CPYMWTRN performs an implementation defined amount of the memory
copy. CPYEWTRN performs the last part of the memory copy.

For CPYPWTRN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWTRN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWTRN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWTRN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWTRN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWTRN--CPYMWTRN--CPYEWTRN--Memory-copy--writes-unprivileged--reads-non-temporal-"
    )
    this["cpyewtwn"] = OpCodeDoc(
        "CPYEWTWN",
        """Memory Copy, writes unprivileged and non-temporal. These instructions perform
a memory copy. The prologue, main, and epilogue instructions are expected to
be run in succession and to appear consecutively in memory: CPYPWTWN, then
CPYMWTWN, and then CPYEWTWN.

CPYPWTWN performs some preconditioning of the arguments suitable for using the
CPYMWTWN instruction, and performs an implementation defined amount of the
memory copy. CPYMWTWN performs an implementation defined amount of the memory
copy. CPYEWTWN performs the last part of the memory copy.

For CPYPWTWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWTWN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWTWN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWTWN--CPYMWTWN--CPYEWTWN--Memory-copy--writes-unprivileged-and-non-temporal-"
    )
    this["cpymwtwn"] = OpCodeDoc(
        "CPYMWTWN",
        """Memory Copy, writes unprivileged and non-temporal. These instructions perform
a memory copy. The prologue, main, and epilogue instructions are expected to
be run in succession and to appear consecutively in memory: CPYPWTWN, then
CPYMWTWN, and then CPYEWTWN.

CPYPWTWN performs some preconditioning of the arguments suitable for using the
CPYMWTWN instruction, and performs an implementation defined amount of the
memory copy. CPYMWTWN performs an implementation defined amount of the memory
copy. CPYEWTWN performs the last part of the memory copy.

For CPYPWTWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWTWN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWTWN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWTWN--CPYMWTWN--CPYEWTWN--Memory-copy--writes-unprivileged-and-non-temporal-"
    )
    this["cpypwtwn"] = OpCodeDoc(
        "CPYPWTWN",
        """Memory Copy, writes unprivileged and non-temporal. These instructions perform
a memory copy. The prologue, main, and epilogue instructions are expected to
be run in succession and to appear consecutively in memory: CPYPWTWN, then
CPYMWTWN, and then CPYEWTWN.

CPYPWTWN performs some preconditioning of the arguments suitable for using the
CPYMWTWN instruction, and performs an implementation defined amount of the
memory copy. CPYMWTWN performs an implementation defined amount of the memory
copy. CPYEWTWN performs the last part of the memory copy.

For CPYPWTWN, the following saturation logic is applied:

If Xn<63:55> != 000000000, the copy size Xn is saturated to
0x007FFFFFFFFFFFFF.

After that saturation logic is applied, the direction of the memory copy is
based on the following algorithm:

If (Xs > Xd) && (Xd + saturated Xn) > Xs, then direction = forward

Elsif (Xs < Xd) && (Xs + saturated Xn) > Xd, then direction = backward

Else direction = implementation defined choice between forward and backward.

The architecture supports two algorithms for the memory copy: option A and
option B. Which algorithm is used is implementation defined.

After execution of CPYPWTWN, option A (which results in encoding PSTATE.C =
0):

  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + saturated Xn.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes copied.
  * If the copy is in the backward direction, then:
  * Xs and Xd are unchanged.
  * Xn holds the saturated value of Xn - an implementation defined number of bytes copied.

After execution of CPYPWTWN, option B (which results in encoding PSTATE.C =
1):

  * If the copy is in the forward direction, then:
  * Xs holds the original Xs + an implementation defined number of bytes copied.
  * Xd holds the original Xd + an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {0,0,0}.
  * If the copy is in the backward direction, then:
  * Xs holds the original Xs + saturated Xn - an implementation defined number of bytes copied.
  * Xd holds the original Xd + saturated Xn - an implementation defined number of bytes copied.
  * Xn holds the saturated Xn - an implementation defined number of bytes copied.
  * PSTATE.{N,Z,V} are set to {1,0,0}.

For CPYMWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be copied in the memory copy in total.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.

For CPYMWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be copied in the memory copy in total.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

For CPYEWTWN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * If the copy is in the forward direction (Xn is a negative number), then:
  * Xn holds -1* the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the lowest address that the copy is copied from -Xn.
  * Xd holds the lowest address that the copy is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.
  * If the copy is in the backward direction (Xn is a positive number), then:
  * Xn holds the number of bytes remaining to be copied in the memory copy in total.
  * Xs holds the highest address that the copy is copied from -Xn+1.
  * Xd holds the highest address that the copy is copied to -Xn+1.
  * At the end of the instruction, the value of Xn is written back with 0.

For CPYEWTWN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes to be copied in the memory copy in total.
  * If the copy is in the forward direction (PSTATE.N == 0), then:
  * Xs holds the lowest address that the copy is copied from.
  * Xd holds the lowest address that the copy is copied to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the lowest address that has not been copied from.
  * the value of Xd is written back with the lowest address that has not been copied to.
  * If the copy is in the backward direction (PSTATE.N == 1), then:
  * Xs holds the highest address that the copy is copied from +1.
  * Xd holds the highest address that the copy is copied to +1.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xs is written back with the highest address that has not been copied from +1.
  * the value of Xd is written back with the highest address that has not been copied to +1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CPYPWTWN--CPYMWTWN--CPYEWTWN--Memory-copy--writes-unprivileged-and-non-temporal-"
    )
    this["crc32b"] = OpCodeDoc(
        "CRC32B",
        """`CRC32` checksum performs a cyclic redundancy check (CRC) calculation on a
value held in a general-purpose register. It takes an input CRC value in the
first source operand, performs a CRC on the input value in the second source
operand, and returns the output CRC value. The second source operand can be 8,
16, 32, or 64 bits. To align with common usage, the bit order of the values is
reversed as part of the operation, and the polynomial 0x04C11DB7 is used for
the CRC calculation.

In an Armv8.0 implementation, this is an optional instruction. From Armv8.1,
it is mandatory for all implementations to implement this instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CRC--B--CRC--H--CRC--W--CRC--X--Crc---checksum-"
    )
    this["crc32h"] = OpCodeDoc(
        "CRC32H",
        """`CRC32` checksum performs a cyclic redundancy check (CRC) calculation on a
value held in a general-purpose register. It takes an input CRC value in the
first source operand, performs a CRC on the input value in the second source
operand, and returns the output CRC value. The second source operand can be 8,
16, 32, or 64 bits. To align with common usage, the bit order of the values is
reversed as part of the operation, and the polynomial 0x04C11DB7 is used for
the CRC calculation.

In an Armv8.0 implementation, this is an optional instruction. From Armv8.1,
it is mandatory for all implementations to implement this instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CRC--B--CRC--H--CRC--W--CRC--X--Crc---checksum-"
    )
    this["crc32w"] = OpCodeDoc(
        "CRC32W",
        """`CRC32` checksum performs a cyclic redundancy check (CRC) calculation on a
value held in a general-purpose register. It takes an input CRC value in the
first source operand, performs a CRC on the input value in the second source
operand, and returns the output CRC value. The second source operand can be 8,
16, 32, or 64 bits. To align with common usage, the bit order of the values is
reversed as part of the operation, and the polynomial 0x04C11DB7 is used for
the CRC calculation.

In an Armv8.0 implementation, this is an optional instruction. From Armv8.1,
it is mandatory for all implementations to implement this instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CRC--B--CRC--H--CRC--W--CRC--X--Crc---checksum-"
    )
    this["crc32x"] = OpCodeDoc(
        "CRC32X",
        """`CRC32` checksum performs a cyclic redundancy check (CRC) calculation on a
value held in a general-purpose register. It takes an input CRC value in the
first source operand, performs a CRC on the input value in the second source
operand, and returns the output CRC value. The second source operand can be 8,
16, 32, or 64 bits. To align with common usage, the bit order of the values is
reversed as part of the operation, and the polynomial 0x04C11DB7 is used for
the CRC calculation.

In an Armv8.0 implementation, this is an optional instruction. From Armv8.1,
it is mandatory for all implementations to implement this instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CRC--B--CRC--H--CRC--W--CRC--X--Crc---checksum-"
    )
    this["crc32cb"] = OpCodeDoc(
        "CRC32CB",
        """`CRC32` checksum performs a cyclic redundancy check (CRC) calculation on a
value held in a general-purpose register. It takes an input CRC value in the
first source operand, performs a CRC on the input value in the second source
operand, and returns the output CRC value. The second source operand can be 8,
16, 32, or 64 bits. To align with common usage, the bit order of the values is
reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for
the CRC calculation.

In an Armv8.0 implementation, this is an optional instruction. From Armv8.1,
it is mandatory for all implementations to implement this instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CRC--CB--CRC--CH--CRC--CW--CRC--CX--Crc--c-checksum-"
    )
    this["crc32ch"] = OpCodeDoc(
        "CRC32CH",
        """`CRC32` checksum performs a cyclic redundancy check (CRC) calculation on a
value held in a general-purpose register. It takes an input CRC value in the
first source operand, performs a CRC on the input value in the second source
operand, and returns the output CRC value. The second source operand can be 8,
16, 32, or 64 bits. To align with common usage, the bit order of the values is
reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for
the CRC calculation.

In an Armv8.0 implementation, this is an optional instruction. From Armv8.1,
it is mandatory for all implementations to implement this instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CRC--CB--CRC--CH--CRC--CW--CRC--CX--Crc--c-checksum-"
    )
    this["crc32cw"] = OpCodeDoc(
        "CRC32CW",
        """`CRC32` checksum performs a cyclic redundancy check (CRC) calculation on a
value held in a general-purpose register. It takes an input CRC value in the
first source operand, performs a CRC on the input value in the second source
operand, and returns the output CRC value. The second source operand can be 8,
16, 32, or 64 bits. To align with common usage, the bit order of the values is
reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for
the CRC calculation.

In an Armv8.0 implementation, this is an optional instruction. From Armv8.1,
it is mandatory for all implementations to implement this instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CRC--CB--CRC--CH--CRC--CW--CRC--CX--Crc--c-checksum-"
    )
    this["crc32cx"] = OpCodeDoc(
        "CRC32CX",
        """`CRC32` checksum performs a cyclic redundancy check (CRC) calculation on a
value held in a general-purpose register. It takes an input CRC value in the
first source operand, performs a CRC on the input value in the second source
operand, and returns the output CRC value. The second source operand can be 8,
16, 32, or 64 bits. To align with common usage, the bit order of the values is
reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for
the CRC calculation.

In an Armv8.0 implementation, this is an optional instruction. From Armv8.1,
it is mandatory for all implementations to implement this instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CRC--CB--CRC--CH--CRC--CW--CRC--CX--Crc--c-checksum-"
    )
    this["csdb"] = OpCodeDoc(
        "CSDB",
        """Consumption of Speculative Data Barrier is a memory barrier that controls
speculative execution and data value prediction.

No instruction other than branch instructions appearing in program order after
the CSDB can be speculatively executed using the results of any:

  * Data value predictions of any instructions.
  * PSTATE.{N,Z,C,V} predictions of any instructions other than conditional branch instructions appearing in program order before the CSDB that have not been architecturally resolved.
  * Predictions of SVE predication state for any SVE instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CSDB--Consumption-of-speculative-data-barrier-"
    )
    this["csel"] = OpCodeDoc(
        "CSEL",
        """If the condition is true, Conditional Select writes the value of the first
source register to the destination register. If the condition is false, it
writes the value of the second source register to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CSEL--Conditional-select-"
    )
    this["cset"] = OpCodeDoc(
        "CSET",
        """Conditional Set sets the destination register to 1 if the condition is TRUE,
and otherwise sets it to 0.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CSET--Conditional-set-"
    )
    this["csetm"] = OpCodeDoc(
        "CSETM",
        """Conditional Set Mask sets all bits of the destination register to 1 if the
condition is TRUE, and otherwise sets all bits to 0.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CSETM--Conditional-set-mask-"
    )
    this["csinc"] = OpCodeDoc(
        "CSINC",
        """Conditional Select Increment returns, in the destination register, the value
of the first source register if the condition is TRUE, and otherwise returns
the value of the second source register incremented by 1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CSINC--Conditional-select-increment-"
    )
    this["csinv"] = OpCodeDoc(
        "CSINV",
        """Conditional Select Invert returns, in the destination register, the value of
the first source register if the condition is TRUE, and otherwise returns the
bitwise inversion value of the second source register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CSINV--Conditional-select-invert-"
    )
    this["csneg"] = OpCodeDoc(
        "CSNEG",
        """Conditional Select Negation returns, in the destination register, the value of
the first source register if the condition is TRUE, and otherwise returns the
negated value of the second source register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CSNEG--Conditional-select-negation-"
    )
    this["ctermeq"] = OpCodeDoc(
        "CTERMEQ",
        """Detect termination conditions in serialized vector loops. Tests whether the
comparison between the scalar source operands holds true and if not tests the
state of the !Last condition flag (C) which indicates whether the previous
flag-setting predicate instruction selected the last element of the vector
partition.

The Z and C condition flags are preserved by this instruction. The N and V
condition flags are set as a pair to generate one of the following conditions
for a subsequent conditional instruction:

The scalar source operands are 32-bit or 64-bit general-purpose registers of
the same size.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CTERMEQ--CTERMNE---"
    )
    this["ctermne"] = OpCodeDoc(
        "CTERMNE",
        """Detect termination conditions in serialized vector loops. Tests whether the
comparison between the scalar source operands holds true and if not tests the
state of the !Last condition flag (C) which indicates whether the previous
flag-setting predicate instruction selected the last element of the vector
partition.

The Z and C condition flags are preserved by this instruction. The N and V
condition flags are set as a pair to generate one of the following conditions
for a subsequent conditional instruction:

The scalar source operands are 32-bit or 64-bit general-purpose registers of
the same size.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CTERMEQ--CTERMNE---"
    )
    this["ctz"] = OpCodeDoc(
        "CTZ",
        """Count Trailing Zeros counts the number of consecutive binary zero bits,
starting from the least significant bit in the source register, and places the
count in the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/CTZ--Count-trailing-zeros-"
    )
    this["dc"] = OpCodeDoc(
        "DC",
        """Data Cache operation. For more information, see op0==0b01, cache maintenance,
TLB maintenance, and address translation instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DC--Data-cache-operation-"
    )
    this["dcps1"] = OpCodeDoc(
        "DCPS1",
        """Debug Change PE State to EL1, when executed in Debug state:

  * If executed at EL0 changes the current Exception level and SP to EL1 using SP_EL1.
  * Otherwise, if executed at ELx, selects SP_ELx.

The target exception level of a DCPS1 instruction is:

  * EL1 if the instruction is executed at EL0.
  * Otherwise, the Exception level at which the instruction is executed.

When the target Exception level of a DCPS1 instruction is ELx, on executing
this instruction:

  * ELR_ELx becomes unknown.
  * SPSR_ELx becomes unknown.
  * ESR_ELx becomes unknown.
  * DLR_EL0 and DSPSR_EL0 become unknown.
  * The endianness is set according to SCTLR_ELx.EE.

This instruction is undefined at EL0 in Non-secure state if EL2 is implemented
and HCR_EL2.TGE == 1.

This instruction is always undefined in Non-debug state.

For more information on the operation of the DCPS<n> instructions, see DCPS.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DCPS---Debug-change-pe-state-to-el--"
    )
    this["dcps2"] = OpCodeDoc(
        "DCPS2",
        """Debug Change PE State to EL2, when executed in Debug state:

  * If executed at EL0 or EL1 changes the current Exception level and SP to EL2 using SP_EL2.
  * Otherwise, if executed at ELx, selects SP_ELx.

The target exception level of a DCPS2 instruction is:

  * EL2 if the instruction is executed at an exception level that is not EL3.
  * EL3 if the instruction is executed at EL3.

When the target Exception level of a DCPS2 instruction is ELx, on executing
this instruction:

  * ELR_ELx becomes unknown.
  * SPSR_ELx becomes unknown.
  * ESR_ELx becomes unknown.
  * DLR_EL0 and DSPSR_EL0 become unknown.
  * The endianness is set according to SCTLR_ELx.EE.

This instruction is undefined at the following exception levels:

  * All exception levels if EL2 is not implemented.
  * At EL0 and EL1 if EL2 is disabled in the current Security state.

This instruction is always undefined in Non-debug state.

For more information on the operation of the DCPS<n> instructions, see DCPS.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DCPS---Debug-change-pe-state-to-el--"
    )
    this["dcps3"] = OpCodeDoc(
        "DCPS3",
        """Debug Change PE State to EL3, when executed in Debug state:

  * If executed at EL3 selects SP_EL3.
  * Otherwise, changes the current Exception level and SP to EL3 using SP_EL3.

The target exception level of a DCPS3 instruction is EL3.

On executing a DCPS3 instruction:

  * ELR_EL3 becomes unknown.
  * SPSR_EL3 becomes unknown.
  * ESR_EL3 becomes unknown.
  * DLR_EL0 and DSPSR_EL0 become unknown.
  * The endianness is set according to SCTLR_EL3.EE.

This instruction is undefined at all exception levels if either:

  * EDSCR.SDD == 1.
  * EL3 is not implemented.

This instruction is always undefined in Non-debug state.

For more information on the operation of the DCPS<n> instructions, see DCPS.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DCPS---Debug-change-pe-state-to-el--"
    )
    this["decb"] = OpCodeDoc(
        "DECB",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DECB--DECD--DECH--DECW--scalar----"
    )
    this["decd"] = OpCodeDoc(
        "DECD",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DECB--DECD--DECH--DECW--scalar----"
    )
    this["dech"] = OpCodeDoc(
        "DECH",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DECB--DECD--DECH--DECW--scalar----"
    )
    this["decw"] = OpCodeDoc(
        "DECW",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DECB--DECD--DECH--DECW--scalar----"
    )
    this["decp"] = OpCodeDoc(
        "DECP",
        """Counts the number of true elements in the source predicate and then uses the
result to decrement the scalar destination.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DECP--scalar----"
    )
    this["dgh"] = OpCodeDoc(
        "DGH",
        """Data Gathering Hint is a hint instruction that indicates that it is not
expected to be performance optimal to merge memory accesses with Normal Non-
cacheable or Device-GRE attributes appearing in program order before the hint
instruction with any memory accesses appearing after the hint instruction into
a single memory transaction on an interconnect.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DGH--Data-gathering-hint-"
    )
    this["dmb"] = OpCodeDoc(
        "DMB",
        """Data Memory Barrier is a memory barrier that ensures the ordering of
observations of memory accesses, see Data Memory Barrier.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DMB--Data-memory-barrier-"
    )
    this["dsb"] = OpCodeDoc(
        "DSB",
        """Data Synchronization Barrier is a memory barrier that ensures the completion
of memory accesses, see Data Synchronization Barrier.

A DSB instruction with the nXS qualifier is complete when the subset of these
memory accesses with the XS attribute set to 0 are complete. It does not
require that memory accesses with the XS attribute set to 1 are complete.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DSB--Data-synchronization-barrier-"
    )
    this["dup"] = OpCodeDoc(
        "DUP",
        """Duplicate vector element to vector or scalar. This instruction duplicates the
vector element at the specified element index in the source SIMD&FP register
into a scalar or each element in a vector, and writes the result to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DUP--element---Duplicate-vector-element-to-vector-or-scalar-"
    )
    this["dup"] = OpCodeDoc(
        "DUP",
        """Unconditionally broadcast the signed integer immediate into each element of
the destination vector. This instruction is unpredicated.

The immediate operand is a signed value in the range -128 to +127, and for
element widths of 16 bits or higher it may also be a signed multiple of 256 in
the range -32768 to +32512 (excluding 0).

The immediate is encoded in 8 bits with an optional left shift by 8. The
preferred disassembly when the shift option is specified is "#<simm8>, LSL
#8". However an assembler and disassembler may also allow use of the shifted
16-bit value unless the immediate is 0 and the shift amount is 8, which must
be unambiguously described as "#0, LSL #8".

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DUP--immediate----"
    )
    this["dupm"] = OpCodeDoc(
        "DUPM",
        """Unconditionally broadcast the logical bitmask immediate into each element of
the destination vector. This instruction is unpredicated. The immediate is a
64-bit value consisting of a single run of ones or zeros repeating every 2, 4,
8, 16, 32 or 64 bits.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DUPM---"
    )
    this["dupq"] = OpCodeDoc(
        "DUPQ",
        """Unconditionally broadcast the indexed element within each 128-bit source
vector segment to all elements of the corresponding destination vector
segment. This instruction is unpredicated.

The immediate element index is in the range of 0 to 15 (bytes), 7 (halfwords),
3 (words) or 1 (doublewords).

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DUPQ---"
    )
    this["dvp"] = OpCodeDoc(
        "DVP",
        """Data Value Prediction Restriction by Context prevents data value predictions
that predict execution addresses based on information gathered from earlier
execution within a particular execution context. Data value predictions
determined by the actions of code in the target execution context or contexts
appearing in program order before the instruction cannot be used to
exploitatively control speculative execution occurring after the instruction
is complete and synchronized.

For more information, see DVP RCTX, Data Value Prediction Restriction by
Context.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/DVP--Data-value-prediction-restriction-by-context-"
    )
    this["eon"] = OpCodeDoc(
        "EON",
        """Bitwise Exclusive-OR NOT (shifted register) performs a bitwise exclusive-OR
NOT of a register value and an optionally-shifted register value, and writes
the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EON--shifted-register---Bitwise-exclusive-or-not--shifted-register--"
    )
    this["eor3"] = OpCodeDoc(
        "EOR3",
        """Three-way Exclusive-OR performs a three-way exclusive-OR of the values in the
three source SIMD&FP registers, and writes the result to the destination
SIMD&FP register.

This instruction is implemented only when FEAT_SHA3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EOR---Three-way-exclusive-or-"
    )
    this["eor"] = OpCodeDoc(
        "EOR",
        """Bitwise Exclusive-OR (vector). This instruction performs a bitwise exclusive-
OR operation between the two source SIMD&FP registers, and places the result
in the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EOR--vector---Bitwise-exclusive-or--vector--"
    )
    this["eor"] = OpCodeDoc(
        "EOR",
        """Bitwise Exclusive-OR (immediate) performs a bitwise exclusive-OR of a register
value and an immediate value, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EOR--immediate---Bitwise-exclusive-or--immediate--"
    )
    this["eor"] = OpCodeDoc(
        "EOR",
        """Bitwise exclusive OR an immediate with each 64-bit element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. The immediate is a 64-bit value consisting of a single run
of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction
is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EOR--immediate----"
    )
    this["eorbt"] = OpCodeDoc(
        "EORBT",
        """Interleaving exclusive OR between the even-numbered elements of the first
source vector register and the odd-numbered elements of the second source
vector register, placing the result in the even-numbered elements of the
destination vector, leaving the odd-numbered elements unchanged. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EORBT---"
    )
    this["eorqv"] = OpCodeDoc(
        "EORQV",
        """Bitwise exclusive OR of the same element numbers from each 128-bit source
vector segment, placing each result into the corresponding element number of
the 128-bit SIMD&FP destination register. Inactive elements in the source
vector are treated as all zeros.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EORQV---"
    )
    this["eors"] = OpCodeDoc(
        "EORS",
        """Bitwise exclusive OR active elements of the second source predicate with
corresponding elements of the first source predicate and place the results in
the corresponding elements of the destination predicate. Inactive elements in
the destination predicate register are set to zero. Sets the First (N), None
(Z), !Last (C) condition flags based on the predicate result, and the V flag
to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EORS---"
    )
    this["eortb"] = OpCodeDoc(
        "EORTB",
        """Interleaving exclusive OR between the odd-numbered elements of the first
source vector register and the even-numbered elements of the second source
vector register, placing the result in the odd-numbered elements of the
destination vector, leaving the even-numbered elements unchanged. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EORTB---"
    )
    this["eorv"] = OpCodeDoc(
        "EORV",
        """Bitwise exclusive OR horizontally across all lanes of a vector, and place the
result in the SIMD&FP scalar destination register. Inactive elements in the
source vector are treated as zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EORV---"
    )
    this["eret"] = OpCodeDoc(
        "ERET",
        """Exception Return using the ELR and SPSR for the current Exception level. When
executed, the PE restores PSTATE from the SPSR, and branches to the address
held in the ELR.

The PE checks the SPSR for the current Exception level for an illegal return
event. See Illegal return events from AArch64 state.

`ERET` is undefined at EL0.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ERET--Exception-return-"
    )
    this["eretaa"] = OpCodeDoc(
        "ERETAA",
        """Exception Return, with pointer authentication. This instruction authenticates
the address in ELR, using SP as the modifier and the specified key, the PE
restores PSTATE from the SPSR for the current Exception level, and branches to
the authenticated address.

Key A is used for `ERETAA`. Key B is used for `ERETAB`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to ELR.

The PE checks the SPSR for the current Exception level for an illegal return
event. See Illegal return events from AArch64 state.

`ERETAA` and `ERETAB` are undefined at EL0.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ERETAA--ERETAB--Exception-return--with-pointer-authentication-"
    )
    this["eretab"] = OpCodeDoc(
        "ERETAB",
        """Exception Return, with pointer authentication. This instruction authenticates
the address in ELR, using SP as the modifier and the specified key, the PE
restores PSTATE from the SPSR for the current Exception level, and branches to
the authenticated address.

Key A is used for `ERETAA`. Key B is used for `ERETAB`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to ELR.

The PE checks the SPSR for the current Exception level for an illegal return
event. See Illegal return events from AArch64 state.

`ERETAA` and `ERETAB` are undefined at EL0.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ERETAA--ERETAB--Exception-return--with-pointer-authentication-"
    )
    this["esb"] = OpCodeDoc(
        "ESB",
        """Error Synchronization Barrier is an error synchronization event that might
also update DISR_EL1 and VDISR_EL2.

This instruction can be used at all Exception levels and in Debug state.

In Debug state, this instruction behaves as if SError interrupts are masked at
all Exception levels. See Error Synchronization Barrier in the Arm(R)
Reliability, Availability, and Serviceability (RAS) Specification, Armv8, for
Armv8-A architecture profile.

If the RAS Extension is not implemented, this instruction executes as a `NOP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ESB--Error-synchronization-barrier-"
    )
    this["ext"] = OpCodeDoc(
        "EXT",
        """Extract vector from pair of vectors. This instruction extracts the lowest
vector elements from the second source SIMD&FP register and the highest vector
elements from the first source SIMD&FP register, concatenates the results into
a vector, and writes the vector to the destination SIMD&FP register vector.
The index value specifies the lowest vector element to extract from the first
source register, and consecutive elements are extracted from the first, then
second, source registers until the destination vector is filled.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EXT--Extract-vector-from-pair-of-vectors-"
    )
    this["extq"] = OpCodeDoc(
        "EXTQ",
        """For each 128-bit vector segment of the result, copy the indexed byte up to and
including the last byte of the corresponding first source vector segment to
the bottom of the result segment, then fill the remainder of the result
segment starting from the first byte of the corresponding second source vector
segment. The result segments are destructively placed in the corresponding
first source vector segment. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EXTQ---"
    )
    this["extr"] = OpCodeDoc(
        "EXTR",
        """Extract register extracts a register from a pair of registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/EXTR--Extract-register-"
    )
    this["fabd"] = OpCodeDoc(
        "FABD",
        """Floating-point Absolute Difference (vector). This instruction subtracts the
floating-point values in the elements of the second source SIMD&FP register,
from the corresponding floating-point values in the elements of the first
source SIMD&FP register, places the absolute value of each result in a vector,
and writes the vector to the destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FABD--Floating-point-absolute-difference--vector--"
    )
    this["fabs"] = OpCodeDoc(
        "FABS",
        """Floating-point Absolute value (vector). This instruction calculates the
absolute value of each vector element in the source SIMD&FP register, writes
the result to a vector, and writes the vector to the destination SIMD&FP
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FABS--vector---Floating-point-absolute-value--vector--"
    )
    this["facge"] = OpCodeDoc(
        "FACGE",
        """Floating-point Absolute Compare Greater than or Equal (vector). This
instruction compares the absolute value of each floating-point value in the
first source SIMD&FP register with the absolute value of the corresponding
floating-point value in the second source SIMD&FP register and if the first
value is greater than or equal to the second value sets every bit of the
corresponding vector element in the destination SIMD&FP register to one,
otherwise sets every bit of the corresponding vector element in the
destination SIMD&FP register to zero.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FACGE--Floating-point-absolute-compare-greater-than-or-equal--vector--"
    )
    this["fac<cc>"] = OpCodeDoc(
        "FAC<cc>",
        """Compare active absolute values of floating-point elements in the first source
vector with corresponding absolute values of elements in the second source
vector, and place the boolean results of the specified comparison in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Does not set the condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FAC-cc----"
    )
    this["facal"] = OpCodeDoc(
        "FACAL",
        """Compare active absolute values of floating-point elements in the first source
vector with corresponding absolute values of elements in the second source
vector, and place the boolean results of the specified comparison in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Does not set the condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FAC-cc----"
    )
    this["faccc"] = OpCodeDoc(
        "FACCC",
        """Compare active absolute values of floating-point elements in the first source
vector with corresponding absolute values of elements in the second source
vector, and place the boolean results of the specified comparison in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Does not set the condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FAC-cc----"
    )
    this["faccs"] = OpCodeDoc(
        "FACCS",
        """Compare active absolute values of floating-point elements in the first source
vector with corresponding absolute values of elements in the second source
vector, and place the boolean results of the specified comparison in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Does not set the condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FAC-cc----"
    )
    this["faceq"] = OpCodeDoc(
        "FACEQ",
        """Compare active absolute values of floating-point elements in the first source
vector with corresponding absolute values of elements in the second source
vector, and place the boolean results of the specified comparison in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Does not set the condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FAC-cc----"
    )
    this["facgt"] = OpCodeDoc(
        "FACGT",
        """Floating-point Absolute Compare Greater than (vector). This instruction
compares the absolute value of each vector element in the first source SIMD&FP
register with the absolute value of the corresponding vector element in the
second source SIMD&FP register and if the first value is greater than the
second value sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the
corresponding vector element in the destination SIMD&FP register to zero.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FACGT--Floating-point-absolute-compare-greater-than--vector--"
    )
    this["facle"] = OpCodeDoc(
        "FACLE",
        """Compare active absolute values of floating-point elements in the first source
vector being less than or equal to corresponding absolute values of elements
in the second source vector, and place the boolean results of the comparison
in the corresponding elements of the destination predicate. Inactive elements
in the destination predicate register are set to zero. Does not set the
condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FACLE---"
    )
    this["faclt"] = OpCodeDoc(
        "FACLT",
        """Compare active absolute values of floating-point elements in the first source
vector being less than corresponding absolute values of elements in the second
source vector, and place the boolean results of the comparison in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Does not set the condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FACLT---"
    )
    this["fadd"] = OpCodeDoc(
        "FADD",
        """Floating-point Add (vector). This instruction adds corresponding vector
elements in the two source SIMD&FP registers, writes the result into a vector,
and writes the vector to the destination SIMD&FP register. All the values in
this instruction are floating-point values.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FADD--vector---Floating-point-add--vector--"
    )
    this["fadd"] = OpCodeDoc(
        "FADD",
        """Add an immediate to each active floating-point element of the source vector,
and destructively place the results in the corresponding elements of the
source vector. The immediate may take the value +0.5 or +1.0 only. Inactive
elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FADD--immediate----"
    )
    this["fadda"] = OpCodeDoc(
        "FADDA",
        """Floating-point add a SIMD&FP scalar source and all active lanes of the vector
source and place the result destructively in the SIMD&FP scalar source
register. Vector elements are processed strictly in order from low to high,
with the scalar source providing the initial value. Inactive elements in the
source vector are ignored.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FADDA---"
    )
    this["faddp"] = OpCodeDoc(
        "FADDP",
        """Floating-point Add Pair of elements (scalar). This instruction adds two
floating-point vector elements in the source SIMD&FP register and writes the
scalar result into the destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FADDP--scalar---Floating-point-add-pair-of-elements--scalar--"
    )
    this["faddqv"] = OpCodeDoc(
        "FADDQV",
        """Floating-point addition of the same element numbers from each 128-bit source
vector segment using a recursive pairwise reduction, placing each result into
the corresponding element number of the 128-bit SIMD&FP destination register.
Inactive elements in the source vector are treated as +0.0.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FADDQV---"
    )
    this["faddv"] = OpCodeDoc(
        "FADDV",
        """Floating-point add horizontally over all lanes of a vector using a recursive
pairwise reduction, and place the result in the SIMD&FP scalar destination
register. Inactive elements in the source vector are treated as +0.0.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FADDV---"
    )
    this["fcadd"] = OpCodeDoc(
        "FCADD",
        """Floating-point Complex Add.

This instruction operates on complex numbers that are represented in SIMD&FP
registers as pairs of elements, with the more significant element holding the
imaginary part of the number and the less significant element holding the real
part of the number. Each element holds a floating-point value. It performs the
following computation on the corresponding complex number element pairs from
the two source registers:

  * Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 90 or 270 degrees.
  * The rotated complex number is added to the complex number from the first source register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCADD--Floating-point-complex-add-"
    )
    this["fccmp"] = OpCodeDoc(
        "FCCMP",
        """Floating-point Conditional quiet Compare (scalar). This instruction compares
the two SIMD&FP source register values and writes the result to the PSTATE.{N,
Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V}
flags are set to the flag bit specifier.

This instruction raises an Invalid Operation floating-point exception if
either or both of the operands is a signaling NaN.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCCMP--Floating-point-conditional-quiet-compare--scalar--"
    )
    this["fccmpe"] = OpCodeDoc(
        "FCCMPE",
        """Floating-point Conditional signaling Compare (scalar). This instruction
compares the two SIMD&FP source register values and writes the result to the
PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N,
Z, C, V} flags are set to the flag bit specifier.

This instruction raises an Invalid Operation floating-point exception if
either or both of the operands is any type of NaN.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCCMPE--Floating-point-conditional-signaling-compare--scalar--"
    )
    this["fclamp"] = OpCodeDoc(
        "FCLAMP",
        """Clamp each floating-point element in the two or four destination vectors to
between the floating-point minimum value in the corresponding element of the
first source vector and the floating-point maximum value in the corresponding
element of the second source vector and destructively place the clamped
results in the corresponding elements of the two or four destination vectors.

Regardless of the value of FPCR.AH, the behavior is as follows for each
mininum number and maximum number operation:

  * Negative zero compares less than positive zero. 
  * If one value is numeric and the other is a quiet NaN, the result is the numeric value. 
  * When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN. 

This instruction follows SME2 floating-point numerical behaviors corresponding
to instructions that place their results in one or more SVE Z vectors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCLAMP---"
    )
    this["fcmeq"] = OpCodeDoc(
        "FCMEQ",
        """Floating-point Compare Equal (vector). This instruction compares each
floating-point value from the first source SIMD&FP register, with the
corresponding floating-point value from the second source SIMD&FP register,
and if the comparison is equal sets every bit of the corresponding vector
element in the destination SIMD&FP register to one, otherwise sets every bit
of the corresponding vector element in the destination SIMD&FP register to
zero.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCMEQ--register---Floating-point-compare-equal--vector--"
    )
    this["fcm<cc>"] = OpCodeDoc(
        "FCM<cc>",
        """Compare active floating-point elements in the source vector with zero, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Does not set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCM-cc---zero----"
    )
    this["fcmal"] = OpCodeDoc(
        "FCMAL",
        """Compare active floating-point elements in the source vector with zero, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Does not set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCM-cc---zero----"
    )
    this["fcmcc"] = OpCodeDoc(
        "FCMCC",
        """Compare active floating-point elements in the source vector with zero, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Does not set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCM-cc---zero----"
    )
    this["fcmcs"] = OpCodeDoc(
        "FCMCS",
        """Compare active floating-point elements in the source vector with zero, and
place the boolean results of the specified comparison in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Does not set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCM-cc---zero----"
    )
    this["fcmge"] = OpCodeDoc(
        "FCMGE",
        """Floating-point Compare Greater than or Equal (vector). This instruction reads
each floating-point value in the first source SIMD&FP register and if the
value is greater than or equal to the corresponding floating-point value in
the second source SIMD&FP register sets every bit of the corresponding vector
element in the destination SIMD&FP register to one, otherwise sets every bit
of the corresponding vector element in the destination SIMD&FP register to
zero.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCMGE--register---Floating-point-compare-greater-than-or-equal--vector--"
    )
    this["fcmgt"] = OpCodeDoc(
        "FCMGT",
        """Floating-point Compare Greater than (vector). This instruction reads each
floating-point value in the first source SIMD&FP register and if the value is
greater than the corresponding floating-point value in the second source
SIMD&FP register sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the
corresponding vector element in the destination SIMD&FP register to zero.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCMGT--register---Floating-point-compare-greater-than--vector--"
    )
    this["fcmla"] = OpCodeDoc(
        "FCMLA",
        """Floating-point Complex Multiply Accumulate (by element).

This instruction operates on complex numbers that are represented in SIMD&FP
registers as pairs of elements, with the more significant element holding the
imaginary part of the number and the less significant element holding the real
part of the number. Each element holds a floating-point value. It performs the
following computation on complex numbers from the first source register and
the destination register with the specified complex number from the second
source register:

  * Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.
  * The two elements of the transformed complex number are multiplied by:
  * The real element of the complex number from the first source register, if the transformation was a rotation by 0 or 180 degrees.
  * The imaginary element of the complex number from the first source register, if the transformation was a rotation by 90 or 270 degrees.
  * The complex number resulting from that multiplication is added to the complex number from the destination register.

The multiplication and addition operations are performed as a fused multiply-
add, without any intermediate rounding.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCMLA--by-element---Floating-point-complex-multiply-accumulate--by-element--"
    )
    this["fcmle"] = OpCodeDoc(
        "FCMLE",
        """Floating-point Compare Less than or Equal to zero (vector). This instruction
reads each floating-point value in the source SIMD&FP register and if the
value is less than or equal to zero sets every bit of the corresponding vector
element in the destination SIMD&FP register to one, otherwise sets every bit
of the corresponding vector element in the destination SIMD&FP register to
zero.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCMLE--zero---Floating-point-compare-less-than-or-equal-to-zero--vector--"
    )
    this["fcmlt"] = OpCodeDoc(
        "FCMLT",
        """Floating-point Compare Less than zero (vector). This instruction reads each
floating-point value in the source SIMD&FP register and if the value is less
than zero sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the
corresponding vector element in the destination SIMD&FP register to zero.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCMLT--zero---Floating-point-compare-less-than-zero--vector--"
    )
    this["fcmp"] = OpCodeDoc(
        "FCMP",
        """Floating-point quiet Compare (scalar). This instruction compares the two
SIMD&FP source register values, or the first SIMD&FP source register value and
zero. It writes the result to the PSTATE.{N, Z, C, V} flags.

This instruction raises an Invalid Operation floating-point exception if
either or both of the operands is a signaling NaN.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCMP--Floating-point-quiet-compare--scalar--"
    )
    this["fcmpe"] = OpCodeDoc(
        "FCMPE",
        """Floating-point signaling Compare (scalar). This instruction compares the two
SIMD&FP source register values, or the first SIMD&FP source register value and
zero. It writes the result to the PSTATE.{N, Z, C, V} flags.

This instruction raises an Invalid Operation floating-point exception if
either or both of the operands is any type of NaN.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCMPE--Floating-point-signaling-compare--scalar--"
    )
    this["fcpy"] = OpCodeDoc(
        "FCPY",
        """Copy a floating-point immediate into each active element in the destination
vector. Inactive elements in the destination vector register remain
unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCPY---"
    )
    this["fcsel"] = OpCodeDoc(
        "FCSEL",
        """Floating-point Conditional Select (scalar). This instruction allows the
SIMD&FP destination register to take the value from either one or the other of
two SIMD&FP source registers. If the condition passes, the first SIMD&FP
source register value is taken, otherwise the second SIMD&FP source register
value is taken.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCSEL--Floating-point-conditional-select--scalar--"
    )
    this["fcvt"] = OpCodeDoc(
        "FCVT",
        """Floating-point Convert precision (scalar). This instruction converts the
floating-point value in the SIMD&FP source register to the precision for the
destination register data type using the rounding mode that is determined by
the FPCR and writes the result to the SIMD&FP destination register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVT--Floating-point-convert-precision--scalar--"
    )
    this["fcvtas"] = OpCodeDoc(
        "FCVTAS",
        """Floating-point Convert to Signed integer, rounding to nearest with ties to
Away (vector). This instruction converts each element in a vector from a
floating-point value to a signed integer value using the Round to Nearest with
Ties to Away rounding mode and writes the result to the SIMD&FP destination
register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTAS--vector---Floating-point-convert-to-signed-integer--rounding-to-nearest-with-ties-to-away--vector--"
    )
    this["fcvtau"] = OpCodeDoc(
        "FCVTAU",
        """Floating-point Convert to Unsigned integer, rounding to nearest with ties to
Away (vector). This instruction converts each element in a vector from a
floating-point value to an unsigned integer value using the Round to Nearest
with Ties to Away rounding mode and writes the result to the SIMD&FP
destination register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTAU--vector---Floating-point-convert-to-unsigned-integer--rounding-to-nearest-with-ties-to-away--vector--"
    )
    this["fcvtl"] = OpCodeDoc(
        "FCVTL",
        """Floating-point Convert to higher precision Long (vector). This instruction
reads each element in a vector in the SIMD&FP source register, converts each
value to double the precision of the source element using the rounding mode
that is determined by the FPCR, and writes each result to the equivalent
element of the vector in the SIMD&FP destination register.

Where the operation lengthens a 64-bit vector to a 128-bit vector, the
`FCVTL2` variant operates on the elements in the top 64 bits of the source
register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTL--FCVTL---Floating-point-convert-to-higher-precision-long--vector--"
    )
    this["fcvtl2"] = OpCodeDoc(
        "FCVTL2",
        """Floating-point Convert to higher precision Long (vector). This instruction
reads each element in a vector in the SIMD&FP source register, converts each
value to double the precision of the source element using the rounding mode
that is determined by the FPCR, and writes each result to the equivalent
element of the vector in the SIMD&FP destination register.

Where the operation lengthens a 64-bit vector to a 128-bit vector, the
`FCVTL2` variant operates on the elements in the top 64 bits of the source
register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTL--FCVTL---Floating-point-convert-to-higher-precision-long--vector--"
    )
    this["fcvtlt"] = OpCodeDoc(
        "FCVTLT",
        """Convert odd-numbered floating-point elements from the source vector to the
next higher precision, and place the results in the active overlapping double-
width elements of the destination vector. Inactive elements in the destination
vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTLT---"
    )
    this["fcvtms"] = OpCodeDoc(
        "FCVTMS",
        """Floating-point Convert to Signed integer, rounding toward Minus infinity
(vector). This instruction converts a scalar or each element in a vector from
a floating-point value to a signed integer value using the Round towards Minus
Infinity rounding mode, and writes the result to the SIMD&FP destination
register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTMS--vector---Floating-point-convert-to-signed-integer--rounding-toward-minus-infinity--vector--"
    )
    this["fcvtmu"] = OpCodeDoc(
        "FCVTMU",
        """Floating-point Convert to Unsigned integer, rounding toward Minus infinity
(vector). This instruction converts a scalar or each element in a vector from
a floating-point value to an unsigned integer value using the Round towards
Minus Infinity rounding mode, and writes the result to the SIMD&FP destination
register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTMU--vector---Floating-point-convert-to-unsigned-integer--rounding-toward-minus-infinity--vector--"
    )
    this["fcvtn"] = OpCodeDoc(
        "FCVTN",
        """Floating-point Convert to lower precision Narrow (vector). This instruction
reads each vector element in the SIMD&FP source register, converts each result
to half the precision of the source element, writes the final result to a
vector, and writes the vector to the lower or upper half of the destination
SIMD&FP register. The destination vector elements are half as long as the
source vector elements. The rounding mode is determined by the FPCR.

The `FCVTN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `FCVTN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in FPSR
or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTN--FCVTN---Floating-point-convert-to-lower-precision-narrow--vector--"
    )
    this["fcvtn2"] = OpCodeDoc(
        "FCVTN2",
        """Floating-point Convert to lower precision Narrow (vector). This instruction
reads each vector element in the SIMD&FP source register, converts each result
to half the precision of the source element, writes the final result to a
vector, and writes the vector to the lower or upper half of the destination
SIMD&FP register. The destination vector elements are half as long as the
source vector elements. The rounding mode is determined by the FPCR.

The `FCVTN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `FCVTN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in FPSR
or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTN--FCVTN---Floating-point-convert-to-lower-precision-narrow--vector--"
    )
    this["fcvtns"] = OpCodeDoc(
        "FCVTNS",
        """Floating-point Convert to Signed integer, rounding to nearest with ties to
even (vector). This instruction converts a scalar or each element in a vector
from a floating-point value to a signed integer value using the Round to
Nearest rounding mode, and writes the result to the SIMD&FP destination
register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTNS--vector---Floating-point-convert-to-signed-integer--rounding-to-nearest-with-ties-to-even--vector--"
    )
    this["fcvtnt"] = OpCodeDoc(
        "FCVTNT",
        """Convert active floating-point elements from the source vector to the next
lower precision, and place the results in the odd-numbered half-width elements
of the destination vector, leaving the even-numbered elements unchanged.
Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTNT---"
    )
    this["fcvtnu"] = OpCodeDoc(
        "FCVTNU",
        """Floating-point Convert to Unsigned integer, rounding to nearest with ties to
even (vector). This instruction converts a scalar or each element in a vector
from a floating-point value to an unsigned integer value using the Round to
Nearest rounding mode, and writes the result to the SIMD&FP destination
register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTNU--vector---Floating-point-convert-to-unsigned-integer--rounding-to-nearest-with-ties-to-even--vector--"
    )
    this["fcvtps"] = OpCodeDoc(
        "FCVTPS",
        """Floating-point Convert to Signed integer, rounding toward Plus infinity
(vector). This instruction converts a scalar or each element in a vector from
a floating-point value to a signed integer value using the Round towards Plus
Infinity rounding mode, and writes the result to the SIMD&FP destination
register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTPS--vector---Floating-point-convert-to-signed-integer--rounding-toward-plus-infinity--vector--"
    )
    this["fcvtpu"] = OpCodeDoc(
        "FCVTPU",
        """Floating-point Convert to Unsigned integer, rounding toward Plus infinity
(vector). This instruction converts a scalar or each element in a vector from
a floating-point value to an unsigned integer value using the Round towards
Plus Infinity rounding mode, and writes the result to the SIMD&FP destination
register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTPU--vector---Floating-point-convert-to-unsigned-integer--rounding-toward-plus-infinity--vector--"
    )
    this["fcvtx"] = OpCodeDoc(
        "FCVTX",
        """Convert active double-precision floating-point elements from the source vector
to single-precision, rounding to Odd, and place the results in the even-
numbered 32-bit elements of the destination vector, while setting the odd-
numbered elements to zero. Inactive elements in the destination vector
register remain unmodified.

Rounding to Odd (aka Von Neumann rounding) permits a two-step conversion from
double-precision to half-precision without incurring intermediate rounding
errors.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTX---"
    )
    this["fcvtxn"] = OpCodeDoc(
        "FCVTXN",
        """Floating-point Convert to lower precision Narrow, rounding to odd (vector).
This instruction reads each vector element in the source SIMD&FP register,
narrows each value to half the precision of the source element using the Round
to Odd rounding mode, writes the result to a vector, and writes the vector to
the destination SIMD&FP register.

The `FCVTXN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `FCVTXN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTXN--FCVTXN---Floating-point-convert-to-lower-precision-narrow--rounding-to-odd--vector--"
    )
    this["fcvtxn2"] = OpCodeDoc(
        "FCVTXN2",
        """Floating-point Convert to lower precision Narrow, rounding to odd (vector).
This instruction reads each vector element in the source SIMD&FP register,
narrows each value to half the precision of the source element using the Round
to Odd rounding mode, writes the result to a vector, and writes the vector to
the destination SIMD&FP register.

The `FCVTXN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `FCVTXN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTXN--FCVTXN---Floating-point-convert-to-lower-precision-narrow--rounding-to-odd--vector--"
    )
    this["fcvtxnt"] = OpCodeDoc(
        "FCVTXNT",
        """Convert active double-precision floating-point elements from the source vector
to single-precision, rounding to Odd, and place the results in the odd-
numbered 32-bit elements of the destination vector, leaving the even-numbered
elements unchanged. Inactive elements in the destination vector register
remain unmodified.

Rounding to Odd (aka Von Neumann rounding) permits a two-step conversion from
double-precision to half-precision without incurring intermediate rounding
errors.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTXNT---"
    )
    this["fcvtzs"] = OpCodeDoc(
        "FCVTZS",
        """Floating-point Convert to Signed fixed-point, rounding toward Zero (vector).
This instruction converts a scalar or each element in a vector from floating-
point to fixed-point signed integer using the Round towards Zero rounding
mode, and writes the result to the SIMD&FP destination register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTZS--vector--fixed-point---Floating-point-convert-to-signed-fixed-point--rounding-toward-zero--vector--"
    )
    this["fcvtzu"] = OpCodeDoc(
        "FCVTZU",
        """Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector).
This instruction converts a scalar or each element in a vector from floating-
point to fixed-point unsigned integer using the Round towards Zero rounding
mode, and writes the result to the general-purpose destination register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FCVTZU--vector--fixed-point---Floating-point-convert-to-unsigned-fixed-point--rounding-toward-zero--vector--"
    )
    this["fdiv"] = OpCodeDoc(
        "FDIV",
        """Floating-point Divide (vector). This instruction divides the floating-point
values in the elements in the first source SIMD&FP register, by the floating-
point values in the corresponding elements in the second source SIMD&FP
register, places the results in a vector, and writes the vector to the
destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FDIV--vector---Floating-point-divide--vector--"
    )
    this["fdivr"] = OpCodeDoc(
        "FDIVR",
        """Reversed divide active floating-point elements of the second source vector by
corresponding floating-point elements of the first source vector and
destructively place the quotient in the corresponding elements of the first
source vector. Inactive elements in the destination vector register remain
unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FDIVR---"
    )
    this["fdot"] = OpCodeDoc(
        "FDOT",
        """This instruction computes the fused sum-of-products of a pair of half-
precision floating-point values held in each 32-bit element of the first
source and second source vectors, without intermediate rounding, and then
destructively adds the single-precision sum-of-products to the corresponding
single-precision element of the destination vector.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FDOT--vectors----"
    )
    this["fdup"] = OpCodeDoc(
        "FDUP",
        """Unconditionally broadcast the floating-point immediate into each element of
the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FDUP---"
    )
    this["fexpa"] = OpCodeDoc(
        "FEXPA",
        """The `FEXPA` instruction accelerates the polynomial series calculation of the
exp(x) function.

The double-precision variant copies the low 52 bits of an entry from a hard-
wired table of 64-bit coefficients, indexed by the low 6 bits of each element
of the source vector, and prepends to that the next 11 bits of the source
element (src<16:6>), setting the sign bit to zero.

The single-precision variant copies the low 23 bits of an entry from hard-
wired table of 32-bit coefficients, indexed by the low 6 bits of each element
of the source vector, and prepends to that the next 8 bits of the source
element (src<13:6>), setting the sign bit to zero.

The half-precision variant copies the low 10 bits of an entry from hard-wired
table of 16-bit coefficients, indexed by the low 5 bits of each element of the
source vector, and prepends to that the next 5 bits of the source element
(src<9:5>), setting the sign bit to zero.

A coefficient table entry with index m holds the floating-point value 2(m/64),
or for the half-precision variant 2(m/32). This instruction is unpredicated.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FEXPA---"
    )
    this["fjcvtzs"] = OpCodeDoc(
        "FJCVTZS",
        """Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero.
This instruction converts the double-precision floating-point value in the
SIMD&FP source register to a 32-bit signed integer using the Round towards
Zero rounding mode, and writes the result to the general-purpose destination
register. If the result is too large to be represented as a signed 32-bit
integer, then the result is the integer modulo 232, as held in a 32-bit signed
integer.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FJCVTZS--Floating-point-javascript-convert-to-signed-fixed-point--rounding-toward-zero-"
    )
    this["flogb"] = OpCodeDoc(
        "FLOGB",
        """This instruction returns the signed integer base 2 logarithm of each floating-
point input element |x| after normalization.

This is the unbiased exponent of x used in the representation of the floating-
point value, such that, for positive x, x = significand  2exponent.

The integer results are placed in elements of the destination vector which
have the same width (esize) as the floating-point input elements:

  * If x is normal, the result is the base 2 logarithm of x. 
  * If x is subnormal, the result corresponds to the normalized representation. 
  * If x is infinite, the result is 2(esize-1)-1. 
  * If x is 0.0 or NaN, the result is -2(esize-1). 

Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FLOGB---"
    )
    this["fmad"] = OpCodeDoc(
        "FMAD",
        """Multiply the corresponding active floating-point elements of the first and
second source vectors and add to elements of the third (addend) vector without
intermediate rounding. Destructively place the results in the destination and
first source (multiplicand) vector. Inactive elements in the destination
vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAD---"
    )
    this["fmadd"] = OpCodeDoc(
        "FMADD",
        """Floating-point fused Multiply-Add (scalar). This instruction multiplies the
values of the first two SIMD&FP source registers, adds the product to the
value of the third SIMD&FP source register, and writes the result to the
SIMD&FP destination register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMADD--Floating-point-fused-multiply-add--scalar--"
    )
    this["fmax"] = OpCodeDoc(
        "FMAX",
        """Floating-point Maximum (vector). This instruction compares corresponding
vector elements in the two source SIMD&FP registers, places the larger of each
of the two floating-point values into a vector, and writes the vector to the
destination SIMD&FP register.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero.
  * When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
  * When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

  * If both elements are zeros, regardless of the sign of either zero, the result is the second element.
  * If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAX--vector---Floating-point-maximum--vector--"
    )
    this["fmax"] = OpCodeDoc(
        "FMAX",
        """Determine the maximum of an immediate and each active floating-point element
of the source vector, and destructively place the results in the corresponding
elements of the source vector. The immediate may take the value +0.0 or +1.0
only.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * When FPCR.DN is 0, if the element is a NaN, the result is a quiet NaN. 
  * When FPCR.DN is 1, if the element is a NaN, the result is Default NaN. 

When FPCR.AH is 1, the behavior is as follows:

  * If both the element and the immediate are zeros, regardless of the sign of either zero, the result is the immediate. 
  * If the element is a NaN, regardless of the value of FPCR.DN, the result is the immediate. 

Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAX--immediate----"
    )
    this["fmaxnm"] = OpCodeDoc(
        "FMAXNM",
        """Floating-point Maximum Number (vector). This instruction compares
corresponding vector elements in the two source SIMD&FP registers, writes the
larger of the two floating-point values into a vector, and writes the vector
to the destination SIMD&FP register.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero.
  * If one element is numeric and the other is a quiet NaN, the result is the numeric value.
  * When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
  * When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAXNM--vector---Floating-point-maximum-number--vector--"
    )
    this["fmaxnm"] = OpCodeDoc(
        "FMAXNM",
        """Determine the maximum number value of an immediate and each active floating-
point element of the source vector, and destructively place the results in the
corresponding elements of the source vector. The immediate may take the value
+0.0 or +1.0 only.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * If the element is a quiet NaN, the result is the immediate value. 
  * When FPCR.DN is 0, if the element is a signaling NaN, the result is a quiet NaN. 
  * When FPCR.DN is 1, if the element is a signaling NaN, the result is Default NaN. 

Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAXNM--immediate----"
    )
    this["fmaxnmp"] = OpCodeDoc(
        "FMAXNMP",
        """Floating-point Maximum Number of Pair of elements (scalar). This instruction
compares two vector elements in the source SIMD&FP register and writes the
largest of the floating-point values as a scalar to the destination SIMD&FP
register.

Regardless of the value of FPCR.AH, the behavior is as follows for each
pairwise operation:

  * Negative zero compares less than positive zero.
  * If one element is numeric and the other is a quiet NaN, the result is the numeric value.
  * When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
  * When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAXNMP--scalar---Floating-point-maximum-number-of-pair-of-elements--scalar--"
    )
    this["fmaxnmqv"] = OpCodeDoc(
        "FMAXNMQV",
        """Floating-point maximum number of the same element numbers from each 128-bit
source vector segment using a recursive pairwise reduction, placing each
result into the corresponding element number of the 128-bit SIMD&FP
destination register. Inactive elements in the source vector are treated as
the default NaN.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * If one value is numeric and the other is a quiet NaN, the result is the numeric value. 
  * When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN. 

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAXNMQV---"
    )
    this["fmaxnmv"] = OpCodeDoc(
        "FMAXNMV",
        """Floating-point Maximum Number across Vector. This instruction compares all the
vector elements in the source SIMD&FP register, and writes the largest of the
values as a scalar to the destination SIMD&FP register. All the values in this
instruction are floating-point values.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero.
  * If one value is numeric and the other is a quiet NaN, the result is the numeric value.
  * When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN.
  * When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAXNMV--Floating-point-maximum-number-across-vector-"
    )
    this["fmaxp"] = OpCodeDoc(
        "FMAXP",
        """Floating-point Maximum of Pair of elements (scalar). This instruction compares
two vector elements in the source SIMD&FP register and writes the largest of
the floating-point values as a scalar to the destination SIMD&FP register.

When FPCR.AH is 0, the behavior is as follows for each pairwise operation:

  * Negative zero compares less than positive zero.
  * When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
  * When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows for each pairwise operation:

  * If both elements are zeros, regardless of the sign of either zero, the result is the second element.
  * If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAXP--scalar---Floating-point-maximum-of-pair-of-elements--scalar--"
    )
    this["fmaxqv"] = OpCodeDoc(
        "FMAXQV",
        """Floating-point maximum of the same element numbers from each 128-bit source
vector segment using a recursive pairwise reduction, placing each result into
the corresponding element number of the 128-bit SIMD&FP destination register.
Inactive elements in the source vector are treated as -Infinity.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * When FPCR.DN is 0, if either value is a NaN, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either value is a NaN, the result is Default NaN. 

When FPCR.AH is 1, the behavior is as follows:

  * If both values are zeros, regardless of the sign of either zero, the result is the second value. 
  * If either value is a NaN, regardless of the value of FPCR.DN, the result is the second value. 

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAXQV---"
    )
    this["fmaxv"] = OpCodeDoc(
        "FMAXV",
        """Floating-point Maximum across Vector. This instruction compares all the vector
elements in the source SIMD&FP register, and writes the largest of the values
as a scalar to the destination SIMD&FP register. All the values in this
instruction are floating-point values.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero.
  * When FPCR.DN is 0, if either value is a NaN, the result is a quiet NaN.
  * When FPCR.DN is 1, if either value is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

  * If both values are zeros, regardless of the sign of either zero, the result is the second value.
  * If either value is a NaN, regardless of the value of FPCR.DN, the result is the second value.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMAXV--Floating-point-maximum-across-vector-"
    )
    this["fmin"] = OpCodeDoc(
        "FMIN",
        """Floating-point minimum (vector). This instruction compares corresponding
elements in the vectors in the two source SIMD&FP registers, places the
smaller of each of the two floating-point values into a vector, and writes the
vector to the destination SIMD&FP register.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero.
  * When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
  * When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

  * If both elements are zeros, regardless of the sign of either zero, the result is the second element.
  * If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMIN--vector---Floating-point-minimum--vector--"
    )
    this["fmin"] = OpCodeDoc(
        "FMIN",
        """Determine the minimum of an immediate and each active floating-point element
of the source vector, and destructively place the results in the corresponding
elements of the source vector. The immediate may take the value +0.0 or +1.0
only.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * When FPCR.DN is 0, if the element is a NaN, the result is a quiet NaN. 
  * When FPCR.DN is 1, if the element is a NaN, the result is Default NaN. 

When FPCR.AH is 1, the behavior is as follows:

  * If both the element and the immediate are zeros, regardless of the sign of either zero, the result is the immediate. 
  * If the element is a NaN, regardless of the value of FPCR.DN, the result is the immediate. 

Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMIN--immediate----"
    )
    this["fminnm"] = OpCodeDoc(
        "FMINNM",
        """Floating-point Minimum Number (vector). This instruction compares
corresponding vector elements in the two source SIMD&FP registers, writes the
smaller of the two floating-point values into a vector, and writes the vector
to the destination SIMD&FP register.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero.
  * If one element is numeric and the other is a quiet NaN, the result is the numeric value.
  * When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
  * When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMINNM--vector---Floating-point-minimum-number--vector--"
    )
    this["fminnm"] = OpCodeDoc(
        "FMINNM",
        """Determine the minimum number value of an immediate and each active floating-
point element of the source vector, and destructively place the results in the
corresponding elements of the source vector. The immediate may take the value
+0.0 or +1.0 only.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * If the element is a quiet NaN, the result is the immediate value. 
  * When FPCR.DN is 0, if the element is a signaling NaN, the result is a quiet NaN. 
  * When FPCR.DN is 1, if the element is a signaling NaN, the result is Default NaN. 

Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMINNM--immediate----"
    )
    this["fminnmp"] = OpCodeDoc(
        "FMINNMP",
        """Floating-point Minimum Number of Pair of elements (scalar). This instruction
compares two vector elements in the source SIMD&FP register and writes the
smallest of the floating-point values as a scalar to the destination SIMD&FP
register.

Regardless of the value of FPCR.AH, the behavior is as follows for each
pairwise operation:

  * Negative zero compares less than positive zero.
  * If one element is numeric and the other is a quiet NaN, the result is the numeric value.
  * When FPCR.DN is 0, if either element is a signaling NaN or if both elements are NaNs, the result is a quiet NaN.
  * When FPCR.DN is 1, if either element is a signaling NaN or if both elements are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMINNMP--scalar---Floating-point-minimum-number-of-pair-of-elements--scalar--"
    )
    this["fminnmqv"] = OpCodeDoc(
        "FMINNMQV",
        """Floating-point minimum number of the same element numbers from each 128-bit
source vector segment using a recursive pairwise reduction, placing each
result into the corresponding element number of the 128-bit SIMD&FP
destination register. Inactive elements in the source vector are treated as
the default NaN.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * If one value is numeric and the other is a quiet NaN, the result is the numeric value. 
  * When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN. 

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMINNMQV---"
    )
    this["fminnmv"] = OpCodeDoc(
        "FMINNMV",
        """Floating-point Minimum Number across Vector. This instruction compares all the
vector elements in the source SIMD&FP register, and writes the smallest of the
values as a scalar to the destination SIMD&FP register. All the values in this
instruction are floating-point values.

Regardless of the value of FPCR.AH, the behavior is as follows:

  * Negative zero compares less than positive zero.
  * If one value is numeric and the other is a quiet NaN, the result is the numeric value.
  * When FPCR.DN is 0, if either value is a signaling NaN or if both values are NaNs, the result is a quiet NaN.
  * When FPCR.DN is 1, if either value is a signaling NaN or if both values are NaNs, the result is Default NaN.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMINNMV--Floating-point-minimum-number-across-vector-"
    )
    this["fminp"] = OpCodeDoc(
        "FMINP",
        """Floating-point Minimum of Pair of elements (scalar). This instruction compares
two vector elements in the source SIMD&FP register and writes the smallest of
the floating-point values as a scalar to the destination SIMD&FP register.

When FPCR.AH is 0, the behavior is as follows for each pairwise operation:

  * Negative zero compares less than positive zero.
  * When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
  * When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows for each pairwise operation:

  * If both elements are zeros, regardless of the sign of either zero, the result is the second element.
  * If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMINP--scalar---Floating-point-minimum-of-pair-of-elements--scalar--"
    )
    this["fminqv"] = OpCodeDoc(
        "FMINQV",
        """Floating-point minimum of the same element numbers from each 128-bit source
vector segment using a recursive pairwise reduction, placing each result into
the corresponding element number of the 128-bit SIMD&FP destination register.
Inactive elements in the source vector are treated as +Infinity.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero. 
  * When FPCR.DN is 0, if either value is a NaN, the result is a quiet NaN. 
  * When FPCR.DN is 1, if either value is a NaN, the result is Default NaN. 

When FPCR.AH is 1, the behavior is as follows:

  * If both values are zeros, regardless of the sign of either zero, the result is the second value. 
  * If either value is a NaN, regardless of the value of FPCR.DN, the result is the second value. 

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMINQV---"
    )
    this["fminv"] = OpCodeDoc(
        "FMINV",
        """Floating-point Minimum across Vector. This instruction compares all the vector
elements in the source SIMD&FP register, and writes the smallest of the values
as a scalar to the destination SIMD&FP register. All the values in this
instruction are floating-point values.

When FPCR.AH is 0, the behavior is as follows:

  * Negative zero compares less than positive zero.
  * When FPCR.DN is 0, if either value is a NaN, the result is a quiet NaN.
  * When FPCR.DN is 1, if either value is a NaN, the result is Default NaN.

When FPCR.AH is 1, the behavior is as follows:

  * If both values are zeros, regardless of the sign of either zero, the result is the second value.
  * If either value is a NaN, regardless of the value of FPCR.DN, the result is the second value.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMINV--Floating-point-minimum-across-vector-"
    )
    this["fmla"] = OpCodeDoc(
        "FMLA",
        """Floating-point fused Multiply-Add to accumulator (by element). This
instruction multiplies the vector elements in the first source SIMD&FP
register by the specified value in the second source SIMD&FP register, and
accumulates the results in the vector elements of the destination SIMD&FP
register. All the values in this instruction are floating-point values.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLA--by-element---Floating-point-fused-multiply-add-to-accumulator--by-element--"
    )
    this["fmlal"] = OpCodeDoc(
        "FMLAL",
        """Floating-point fused Multiply-Add Long to accumulator (by element). This
instruction multiplies the vector elements in the first source SIMD&FP
register by the specified value in the second source SIMD&FP register, and
accumulates the product to the corresponding vector element of the destination
SIMD&FP register. The instruction does not round the result of the multiply
before the accumulation.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

In Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is
mandatory for all implementations to support it.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLAL--FMLAL---by-element---Floating-point-fused-multiply-add-long-to-accumulator--by-element--"
    )
    this["fmlal2"] = OpCodeDoc(
        "FMLAL2",
        """Floating-point fused Multiply-Add Long to accumulator (by element). This
instruction multiplies the vector elements in the first source SIMD&FP
register by the specified value in the second source SIMD&FP register, and
accumulates the product to the corresponding vector element of the destination
SIMD&FP register. The instruction does not round the result of the multiply
before the accumulation.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

In Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is
mandatory for all implementations to support it.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLAL--FMLAL---by-element---Floating-point-fused-multiply-add-long-to-accumulator--by-element--"
    )
    this["fmlalb"] = OpCodeDoc(
        "FMLALB",
        """This half-precision floating-point multiply-add long instruction widens the
even-numbered half-precision elements in the first source vector and the
corresponding elements in the second source vector to single-precision format
and then destructively multiplies and adds these values without intermediate
rounding to the single-precision elements of the destination vector that
overlap with the corresponding half-precision elements in the source vectors.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLALB--vectors----"
    )
    this["fmlalt"] = OpCodeDoc(
        "FMLALT",
        """This half-precision floating-point multiply-add long instruction widens the
odd-numbered half-precision elements in the first source vector and the
corresponding elements in the second source vector to single-precision format
and then destructively multiplies and adds these values without intermediate
rounding to the single-precision elements of the destination vector that
overlap with the corresponding half-precision elements in the source vectors.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLALT--vectors----"
    )
    this["fmls"] = OpCodeDoc(
        "FMLS",
        """Floating-point fused Multiply-Subtract from accumulator (by element). This
instruction multiplies the vector elements in the first source SIMD&FP
register by the specified value in the second source SIMD&FP register, and
subtracts the results from the vector elements of the destination SIMD&FP
register. All the values in this instruction are floating-point values.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLS--by-element---Floating-point-fused-multiply-subtract-from-accumulator--by-element--"
    )
    this["fmlsl"] = OpCodeDoc(
        "FMLSL",
        """Floating-point fused Multiply-Subtract Long from accumulator (by element).
This instruction multiplies the negated vector elements in the first source
SIMD&FP register by the specified value in the second source SIMD&FP register,
and accumulates the product to the corresponding vector element of the
destination SIMD&FP register. The instruction does not round the result of the
multiply before the accumulation.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

In Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is
mandatory for all implementations to support it.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLSL--FMLSL---by-element---Floating-point-fused-multiply-subtract-long-from-accumulator--by-element--"
    )
    this["fmlsl2"] = OpCodeDoc(
        "FMLSL2",
        """Floating-point fused Multiply-Subtract Long from accumulator (by element).
This instruction multiplies the negated vector elements in the first source
SIMD&FP register by the specified value in the second source SIMD&FP register,
and accumulates the product to the corresponding vector element of the
destination SIMD&FP register. The instruction does not round the result of the
multiply before the accumulation.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

In Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is
mandatory for all implementations to support it.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLSL--FMLSL---by-element---Floating-point-fused-multiply-subtract-long-from-accumulator--by-element--"
    )
    this["fmlslb"] = OpCodeDoc(
        "FMLSLB",
        """This half-precision floating-point multiply-subtract long instruction widens
the even-numbered half-precision elements in the first source vector and the
corresponding elements in the second source vector to single-precision format
and then destructively multiplies and subtracts these values without
intermediate rounding from the single-precision elements of the destination
vector that overlap with the corresponding half-precision elements in the
source vectors. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLSLB--vectors----"
    )
    this["fmlslt"] = OpCodeDoc(
        "FMLSLT",
        """This half-precision floating-point multiply-subtract long instruction widens
the odd-numbered half-precision elements in the first source vector and the
corresponding elements in the second source vector to single-precision format
and then destructively multiplies and subtracts these values without
intermediate rounding from the single-precision elements of the destination
vector that overlap with the corresponding half-precision elements in the
source vectors. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMLSLT--vectors----"
    )
    this["fmmla"] = OpCodeDoc(
        "FMMLA",
        """The floating-point matrix multiply-accumulate instruction supports single-
precision and double-precision data types in a 22 matrix contained in
segments of 128 or 256 bits, respectively. It multiplies the 22 matrix in
each segment of the first source vector by the 22 matrix in the corresponding
segment of the second source vector. The resulting 22 matrix product is then
destructively added to the matrix accumulator held in the corresponding
segment of the addend and destination vector. This is equivalent to performing
a 2-way dot product per destination element. This instruction is unpredicated.
The single-precision variant is vector length agnostic. The double-precision
variant requires that the current vector length is at least 256 bits, and if
the current vector length is not an integer multiple of 256 bits then the
trailing bits are set to zero.

ID_AA64ZFR0_EL1.F32MM indicates whether the single-precision variant is
implemented.

ID_AA64ZFR0_EL1.F64MM indicates whether the double-precision variant is
implemented.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMMLA---"
    )
    this["fmopa"] = OpCodeDoc(
        "FMOPA",
        """The half-precision floating-point sum of outer products and accumulate
instruction works with a 32-bit element ZA tile.

This instruction widens the SVLS2 sub-matrix of half-precision floating-point
values held in the first source vector to single-precision floating-point
values and multiplies it by the widened 2SVLS sub-matrix of half-precision
floating-point values in the second source vector to single-precision
floating-point values.

Each source vector is independently predicated by a corresponding governing
predicate. When a 16-bit source element is Inactive it is treated as having
the value +0.0, but if both pairs of source vector elements that correspond to
a 32-bit destination element contain Inactive elements, then the destination
element remains unmodified.

The resulting SVLSSVLS single-precision floating-point sum of outer products
is then destructively added to the single-precision floating-point destination
tile. This is equivalent to performing a 2-way dot product and accumulate to
each of the destination tile elements.

Each 32-bit container of the first source vector holds 2 consecutive column
elements of each row of a SVLS2 sub-matrix. Similarly, each 32-bit container
of the second source vector holds 2 consecutive row elements of each column of
a 2SVLS sub-matrix.

This instruction follows SME ZA-targeting floating-point behaviors.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMOPA--widening----"
    )
    this["fmops"] = OpCodeDoc(
        "FMOPS",
        """The half-precision floating-point sum of outer products and subtract
instruction works with a 32-bit element ZA tile.

This instruction widens the SVLS2 sub-matrix of half-precision floating-point
values held in the first source vector to single-precision floating-point
values and multiplies it by the widened 2SVLS sub-matrix of half-precision
floating-point values in the second source vector to single-precision
floating-point values.

Each source vector is independently predicated by a corresponding governing
predicate. When a 16-bit source element is Inactive it is treated as having
the value +0.0, but if both pairs of source vector elements that correspond to
a 32-bit destination element contain Inactive elements, then the destination
element remains unmodified.

The resulting SVLSSVLS single-precision floating-point sum of outer products
is then destructively subtracted from the single-precision floating-point
destination tile. This is equivalent to performing a 2-way dot product and
subtract from each of the destination tile elements.

Each 32-bit container of the first source vector holds 2 consecutive column
elements of each row of a SVLS2 sub-matrix. Similarly, each 32-bit container
of the second source vector holds 2 consecutive row elements of each column of
a 2SVLS sub-matrix.

This instruction follows SME ZA-targeting floating-point behaviors.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMOPS--widening----"
    )
    this["fmov"] = OpCodeDoc(
        "FMOV",
        """Floating-point move immediate (vector). This instruction copies an immediate
floating-point constant into every element of the SIMD&FP destination
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMOV--vector--immediate---Floating-point-move-immediate--vector--"
    )
    this["fmov"] = OpCodeDoc(
        "FMOV",
        """Floating-point Move register without conversion. This instruction copies the
floating-point value in the SIMD&FP source register to the SIMD&FP destination
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMOV--register---Floating-point-move-register-without-conversion-"
    )
    this["fmsb"] = OpCodeDoc(
        "FMSB",
        """Multiply the corresponding active floating-point elements of the first and
second source vectors and subtract from elements of the third (addend) vector
without intermediate rounding. Destructively place the results in the
destination and first source (multiplicand) vector. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMSB---"
    )
    this["fmsub"] = OpCodeDoc(
        "FMSUB",
        """Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies
the values of the first two SIMD&FP source registers, negates the product,
adds that to the value of the third SIMD&FP source register, and writes the
result to the SIMD&FP destination register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMSUB--Floating-point-fused-multiply-subtract--scalar--"
    )
    this["fmul"] = OpCodeDoc(
        "FMUL",
        """Floating-point Multiply (by element). This instruction multiplies the vector
elements in the first source SIMD&FP register by the specified value in the
second source SIMD&FP register, places the results in a vector, and writes the
vector to the destination SIMD&FP register. All the values in this instruction
are floating-point values.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMUL--by-element---Floating-point-multiply--by-element--"
    )
    this["fmul"] = OpCodeDoc(
        "FMUL",
        """Multiply by an immediate each active floating-point element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. The immediate may take the value +0.5 or +2.0 only.
Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMUL--immediate----"
    )
    this["fmulx"] = OpCodeDoc(
        "FMULX",
        """Floating-point Multiply extended (by element). This instruction multiplies the
floating-point values in the vector elements in the first source SIMD&FP
register by the specified floating-point value in the second source SIMD&FP
register, places the results in a vector, and writes the vector to the
destination SIMD&FP register.

If one value is zero and the other value is infinite, the result is 2.0. In
this case, the result is negative if only one of the values is negative,
otherwise the result is positive.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FMULX--by-element---Floating-point-multiply-extended--by-element--"
    )
    this["fneg"] = OpCodeDoc(
        "FNEG",
        """Floating-point Negate (vector). This instruction negates the value of each
vector element in the source SIMD&FP register, writes the result to a vector,
and writes the vector to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FNEG--vector---Floating-point-negate--vector--"
    )
    this["fnmad"] = OpCodeDoc(
        "FNMAD",
        """Multiply the corresponding active floating-point elements of the first and
second source vectors and add to elements of the third (addend) vector without
intermediate rounding. Destructively place the negated results in the
destination and first source (multiplicand) vector. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FNMAD---"
    )
    this["fnmadd"] = OpCodeDoc(
        "FNMADD",
        """Floating-point Negated fused Multiply-Add (scalar). This instruction
multiplies the values of the first two SIMD&FP source registers, negates the
product, subtracts the value of the third SIMD&FP source register, and writes
the result to the destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FNMADD--Floating-point-negated-fused-multiply-add--scalar--"
    )
    this["fnmla"] = OpCodeDoc(
        "FNMLA",
        """Multiply the corresponding active floating-point elements of the first and
second source vectors and add to elements of the third source (addend) vector
without intermediate rounding. Destructively place the negated results in the
destination and third source (addend) vector. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FNMLA---"
    )
    this["fnmls"] = OpCodeDoc(
        "FNMLS",
        """Multiply the corresponding active floating-point elements of the first and
second source vectors and subtract from elements of the third source (addend)
vector without intermediate rounding. Destructively place the negated results
in the destination and third source (addend) vector. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FNMLS---"
    )
    this["fnmsb"] = OpCodeDoc(
        "FNMSB",
        """Multiply the corresponding active floating-point elements of the first and
second source vectors and subtract from elements of the third (addend) vector
without intermediate rounding. Destructively place the negated results in the
destination and first source (multiplicand) vector. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FNMSB---"
    )
    this["fnmsub"] = OpCodeDoc(
        "FNMSUB",
        """Floating-point Negated fused Multiply-Subtract (scalar). This instruction
multiplies the values of the first two SIMD&FP source registers, subtracts the
value of the third SIMD&FP source register, and writes the result to the
destination SIMD&FP register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FNMSUB--Floating-point-negated-fused-multiply-subtract--scalar--"
    )
    this["fnmul"] = OpCodeDoc(
        "FNMUL",
        """Floating-point Multiply-Negate (scalar). This instruction multiplies the
floating-point values of the two source SIMD&FP registers, and writes the
negation of the result to the destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FNMUL--scalar---Floating-point-multiply-negate--scalar--"
    )
    this["frecpe"] = OpCodeDoc(
        "FRECPE",
        """Floating-point Reciprocal Estimate. This instruction finds an approximate
reciprocal estimate for each vector element in the source SIMD&FP register,
places the result in a vector, and writes the vector to the destination
SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRECPE--Floating-point-reciprocal-estimate-"
    )
    this["frecps"] = OpCodeDoc(
        "FRECPS",
        """Floating-point Reciprocal Step. This instruction multiplies the corresponding
floating-point values in the vectors of the two source SIMD&FP registers,
subtracts each of the products from 2.0, places the resulting floating-point
values in a vector, and writes the vector to the destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRECPS--Floating-point-reciprocal-step-"
    )
    this["frecpx"] = OpCodeDoc(
        "FRECPX",
        """Floating-point Reciprocal exponent (scalar). This instruction finds an
approximate reciprocal exponent for the source SIMD&FP register and writes the
result to the destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRECPX--Floating-point-reciprocal-exponent--scalar--"
    )
    this["frint32x"] = OpCodeDoc(
        "FRINT32X",
        """Floating-point Round to 32-bit Integer, using current rounding mode (vector).
This instruction rounds a vector of floating-point values in the SIMD&FP
source register to integral floating-point values that fit into a 32-bit
integer size using the rounding mode that is determined by the FPCR, and
writes the result to the SIMD&FP destination register.

A zero input returns a zero result with the same sign. When one of the result
values is not numerically equal to the corresponding input value, an Inexact
exception is raised. When an input is infinite, NaN or out-of-range, the
instruction returns for the corresponding result value the most negative
integer representable in the destination size, and an Invalid Operation
floating-point exception is raised.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINT--X--vector---Floating-point-round-to----bit-integer--using-current-rounding-mode--vector--"
    )
    this["frint32z"] = OpCodeDoc(
        "FRINT32Z",
        """Floating-point Round to 32-bit Integer toward Zero (vector). This instruction
rounds a vector of floating-point values in the SIMD&FP source register to
integral floating-point values that fit into a 32-bit integer size using the
Round towards Zero rounding mode, and writes the result to the SIMD&FP
destination register.

A zero input returns a zero result with the same sign. When one of the result
values is not numerically equal to the corresponding input value, an Inexact
exception is raised. When an input is infinite, NaN or out-of-range, the
instruction returns for the corresponding result value the most negative
integer representable in the destination size, and an Invalid Operation
floating-point exception is raised.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINT--Z--vector---Floating-point-round-to----bit-integer-toward-zero--vector--"
    )
    this["frint64x"] = OpCodeDoc(
        "FRINT64X",
        """Floating-point Round to 64-bit Integer, using current rounding mode (vector).
This instruction rounds a vector of floating-point values in the SIMD&FP
source register to integral floating-point values that fit into a 64-bit
integer size using the rounding mode that is determined by the FPCR, and
writes the result to the SIMD&FP destination register.

A zero input returns a zero result with the same sign. When one of the result
values is not numerically equal to the corresponding input value, an Inexact
exception is raised. When an input is infinite, NaN or out-of-range, the
instruction returns for the corresponding result value the most negative
integer representable in the destination size, and an Invalid Operation
floating-point exception is raised.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINT--X--vector---Floating-point-round-to----bit-integer--using-current-rounding-mode--vector--"
    )
    this["frint64z"] = OpCodeDoc(
        "FRINT64Z",
        """Floating-point Round to 64-bit Integer toward Zero (vector). This instruction
rounds a vector of floating-point values in the SIMD&FP source register to
integral floating-point values that fit into a 64-bit integer size using the
Round towards Zero rounding mode, and writes the result to the SIMD&FP
destination register.

A zero input returns a zero result with the same sign. When one of the result
values is not numerically equal to the corresponding input value, an Inexact
exception is raised. When an input is infinite, NaN or out-of-range, the
instruction returns for the corresponding result value the most negative
integer representable in the destination size, and an Invalid Operation
floating-point exception is raised.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINT--Z--vector---Floating-point-round-to----bit-integer-toward-zero--vector--"
    )
    this["frinta"] = OpCodeDoc(
        "FRINTA",
        """Floating-point Round to Integral, to nearest with ties to Away (vector). This
instruction rounds a vector of floating-point values in the SIMD&FP source
register to integral floating-point values of the same size using the Round to
Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP
destination register.

A zero input gives a zero result with the same sign, an infinite input gives
an infinite result with the same sign, and a NaN is propagated as for normal
arithmetic.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINTA--vector---Floating-point-round-to-integral--to-nearest-with-ties-to-away--vector--"
    )
    this["frint<r>"] = OpCodeDoc(
        "FRINT<r>",
        """Round to an integral floating-point value with the specified rounding option
from each active floating-point element of the source vector, and place the
results in the corresponding elements of the destination vector. Inactive
elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINT-r----"
    )
    this["frinti"] = OpCodeDoc(
        "FRINTI",
        """Floating-point Round to Integral, using current rounding mode (vector). This
instruction rounds a vector of floating-point values in the SIMD&FP source
register to integral floating-point values of the same size using the rounding
mode that is determined by the FPCR, and writes the result to the SIMD&FP
destination register.

A zero input gives a zero result with the same sign, an infinite input gives
an infinite result with the same sign, and a NaN is propagated as for normal
arithmetic.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINTI--vector---Floating-point-round-to-integral--using-current-rounding-mode--vector--"
    )
    this["frintm"] = OpCodeDoc(
        "FRINTM",
        """Floating-point Round to Integral, toward Minus infinity (vector). This
instruction rounds a vector of floating-point values in the SIMD&FP source
register to integral floating-point values of the same size using the Round
towards Minus Infinity rounding mode, and writes the result to the SIMD&FP
destination register.

A zero input gives a zero result with the same sign, an infinite input gives
an infinite result with the same sign, and a NaN is propagated as for normal
arithmetic.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINTM--vector---Floating-point-round-to-integral--toward-minus-infinity--vector--"
    )
    this["frintn"] = OpCodeDoc(
        "FRINTN",
        """Floating-point Round to Integral, to nearest with ties to even (vector). This
instruction rounds a vector of floating-point values in the SIMD&FP source
register to integral floating-point values of the same size using the Round to
Nearest rounding mode, and writes the result to the SIMD&FP destination
register.

A zero input gives a zero result with the same sign, an infinite input gives
an infinite result with the same sign, and a NaN is propagated as for normal
arithmetic.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINTN--vector---Floating-point-round-to-integral--to-nearest-with-ties-to-even--vector--"
    )
    this["frintp"] = OpCodeDoc(
        "FRINTP",
        """Floating-point Round to Integral, toward Plus infinity (vector). This
instruction rounds a vector of floating-point values in the SIMD&FP source
register to integral floating-point values of the same size using the Round
towards Plus Infinity rounding mode, and writes the result to the SIMD&FP
destination register.

A zero input gives a zero result with the same sign, an infinite input gives
an infinite result with the same sign, and a NaN is propagated as for normal
arithmetic.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINTP--vector---Floating-point-round-to-integral--toward-plus-infinity--vector--"
    )
    this["frintx"] = OpCodeDoc(
        "FRINTX",
        """Floating-point Round to Integral exact, using current rounding mode (vector).
This instruction rounds a vector of floating-point values in the SIMD&FP
source register to integral floating-point values of the same size using the
rounding mode that is determined by the FPCR, and writes the result to the
SIMD&FP destination register.

When a result value is not numerically equal to the corresponding input value,
an Inexact exception is raised. A zero input gives a zero result with the same
sign, an infinite input gives an infinite result with the same sign, and a NaN
is propagated as for normal arithmetic.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINTX--vector---Floating-point-round-to-integral-exact--using-current-rounding-mode--vector--"
    )
    this["frintz"] = OpCodeDoc(
        "FRINTZ",
        """Floating-point Round to Integral, toward Zero (vector). This instruction
rounds a vector of floating-point values in the SIMD&FP source register to
integral floating-point values of the same size using the Round towards Zero
rounding mode, and writes the result to the SIMD&FP destination register.

A zero input gives a zero result with the same sign, an infinite input gives
an infinite result with the same sign, and a NaN is propagated as for normal
arithmetic.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRINTZ--vector---Floating-point-round-to-integral--toward-zero--vector--"
    )
    this["frsqrte"] = OpCodeDoc(
        "FRSQRTE",
        """Floating-point Reciprocal Square Root Estimate. This instruction calculates an
approximate square root for each vector element in the source SIMD&FP
register, places the result in a vector, and writes the vector to the
destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRSQRTE--Floating-point-reciprocal-square-root-estimate-"
    )
    this["frsqrts"] = OpCodeDoc(
        "FRSQRTS",
        """Floating-point Reciprocal Square Root Step. This instruction multiplies
corresponding floating-point values in the vectors of the two source SIMD&FP
registers, subtracts each of the products from 3.0, divides these results by
2.0, places the results into a vector, and writes the vector to the
destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FRSQRTS--Floating-point-reciprocal-square-root-step-"
    )
    this["fscale"] = OpCodeDoc(
        "FSCALE",
        """Multiply the active floating-point elements of the first source vector by 2.0
to the power of the signed integer values in the corresponding elements of the
second source vector and destructively place the results in the corresponding
elements of the first source vector. Inactive elements in the destination
vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FSCALE---"
    )
    this["fsqrt"] = OpCodeDoc(
        "FSQRT",
        """Floating-point Square Root (vector). This instruction calculates the square
root for each vector element in the source SIMD&FP register, places the result
in a vector, and writes the vector to the destination SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FSQRT--vector---Floating-point-square-root--vector--"
    )
    this["fsub"] = OpCodeDoc(
        "FSUB",
        """Floating-point Subtract (vector). This instruction subtracts the elements in
the vector in the second source SIMD&FP register, from the corresponding
elements in the vector in the first source SIMD&FP register, places each
result into elements of a vector, and writes the vector to the destination
SIMD&FP register.

This instruction can generate a floating-point exception. Depending on the
settings in FPCR, the exception results in either a flag being set in FPSR, or
a synchronous exception being generated. For more information, see Floating-
point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FSUB--vector---Floating-point-subtract--vector--"
    )
    this["fsub"] = OpCodeDoc(
        "FSUB",
        """Subtract an immediate from each active floating-point element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. The immediate may take the value +0.5 or +1.0 only.
Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FSUB--immediate----"
    )
    this["fsubr"] = OpCodeDoc(
        "FSUBR",
        """Reversed subtract from an immediate each active floating-point element of the
source vector, and destructively place the results in the corresponding
elements of the source vector. The immediate may take the value +0.5 or +1.0
only. Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FSUBR--immediate----"
    )
    this["ftmad"] = OpCodeDoc(
        "FTMAD",
        """The `FTMAD` instruction calculates the series terms for either sin(x) or
cos(x), where the argument x has been adjusted to be in the range -/4 < x 
/4.

To calculate the series terms of sin(x) and cos(x) the initial source operands
of `FTMAD` should be zero in the first source vector and x2 in the second
source vector. The `FTMAD` instruction is then executed eight times to
calculate the sum of eight series terms, which gives a result of sufficient
precision.

The `FTMAD` instruction multiplies each element of the first source vector by
the absolute value of the corresponding element of the second source vector
and performs a fused addition of each product with a value obtained from a
table of hard-wired coefficients, and places the results destructively in the
first source vector.

The coefficients are different for sin(x) and cos(x), and are selected by a
combination of the sign bit in the second source element and an immediate
index in the range 0 to 7.

Double-precision coefficient table for sin(x) (s2<63> == '0')

Double-precision coefficient table for cos(x) (s2<63> == '1')

Single-precision coefficient table for sin(x) (s2<31> == '0')

Single-precision coefficient table for cos(x) (s2<31> == '1')

Half-precision coefficient table for sin(x) (s2<15> == '0')

Half-precision coefficient table for cos(x) (s2<15> == '1')

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FTMAD---"
    )
    this["ftsmul"] = OpCodeDoc(
        "FTSMUL",
        """The `FTSMUL` instruction calculates the initial value for the `FTMAD`
instruction. The instruction squares each element in the first source vector
and then sets the sign bit to a copy of bit 0 of the corresponding element in
the second source register, and places the results in the destination vector.
This instruction is unpredicated.

To compute sin(x) or cos(x) the instruction is executed with elements of the
first source vector set to x, adjusted to be in the range -/4 < x  /4.

The elements of the second source vector hold the corresponding value of the
quadrant q number as an integer not a floating-point value. The value q
satisfies the relationship (2q-1)  /4 < x  (2q+1)  /4.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FTSMUL---"
    )
    this["ftssel"] = OpCodeDoc(
        "FTSSEL",
        """The `FTSSEL` instruction selects the coefficient for the final multiplication
in the polynomial series approximation. The instruction places the value 1.0
or a copy of the first source vector element in the destination element,
depending on bit 0 of the quadrant number q held in the corresponding element
of the second source vector. The sign bit of the destination element is copied
from bit 1 of the corresponding value of q. This instruction is unpredicated.

To compute sin(x) or cos(x) the instruction is executed with elements of the
first source vector set to x, adjusted to be in the range -/4 < x  /4.

The elements of the second source vector hold the corresponding value of the
quadrant q number as an integer not a floating-point value. The value q
satisfies the relationship (2q-1)  /4 < x  (2q+1)  /4.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FTSSEL---"
    )
    this["fvdot"] = OpCodeDoc(
        "FVDOT",
        """The instruction computes the fused sum-of-products of each vertical pair of
half-precision floating-point values in the corresponding elements of the two
first source vectors with the pair of half-precision floating-point values in
the indexed 32-bit group of the corresponding 128-bit segment of the second
source vector, without intermediate rounding. The single-precision sum-of-
products results are destructively added to the corresponding single-precision
elements of the two ZA single-vector groups.

The half-precision floating-point pairs within the second source vector are
specified using an immediate index which selects the same pair position within
each 128-bit vector segment. The element index range is from 0 to 3.

The vector numbers forming the single-vector group within each half of the ZA
array are selected by the sum of the vector select register and immediate
offset, modulo half the number of ZA array vectors.

The vector group symbol VGx2 indicates that the ZA operand consists of two ZA
single-vector groups. The vector group symbol is preferred for disassembly,
but optional in assembler source code.

This instruction follows SME ZA-targeting floating-point behaviors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/FVDOT---"
    )
    this["gcsbdsync"] = OpCodeDoc(
        "GCSBDSYNC",
        """Guarded Control Stack Barrier. This instruction generates a Guarded control
stack data synchronization event.

If FEAT_GCS is not implemented, this instruction executes as a `NOP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSB-DSYNC--Guarded-control-stack-barrier-"
    )
    this["gcspopcx"] = OpCodeDoc(
        "GCSPOPCX",
        """Guarded Control Stack Pop and Compare exception return record loads an
exception return record from the location indicated by the current Guarded
control stack pointer register, compares the loaded values with the current
ELR_ELx, SPSR_ELx, and LR, and increments the pointer by the size of a Guarded
control stack exception return record.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSPOPCX--Guarded-control-stack-pop-and-compare-exception-return-record-"
    )
    this["gcspopm"] = OpCodeDoc(
        "GCSPOPM",
        """Guarded Control Stack Pop loads the 64-bit doubleword that is pointed to by
the current Guarded control stack pointer, writes it to the destination
register, and increments the current Guarded control stack pointer register by
the size of a Guarded control stack procedure return record.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSPOPM--Guarded-control-stack-pop-"
    )
    this["gcspopx"] = OpCodeDoc(
        "GCSPOPX",
        """Guarded Control Stack Pop exception return record loads an exception return
record from the location indicated by the current Guarded control stack
pointer register, checks that the record is an exception return record, and
increments the pointer by the size of a Guarded control stack exception return
record.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSPOPX--Guarded-control-stack-pop-exception-return-record-"
    )
    this["gcspushm"] = OpCodeDoc(
        "GCSPUSHM",
        """Guarded Control Stack Push decrements the current Guarded control stack
pointer register by the size of a Guarded control procedure return record and
stores an entry to the Guarded control stack.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSPUSHM--Guarded-control-stack-push-"
    )
    this["gcspushx"] = OpCodeDoc(
        "GCSPUSHX",
        """Guarded Control Stack Push exception return record decrements the current
Guarded control stack pointer register by the size of a Guarded control stack
exception return record and stores an exception return record to the Guarded
control stack.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSPUSHX--Guarded-control-stack-push-exception-return-record-"
    )
    this["gcsss1"] = OpCodeDoc(
        "GCSSS1",
        """Guarded Control Stack Switch Stack 1 validates that the stack being switched
to contains a Valid cap entry, stores an In-progress cap entry to the stack
that is being switched to, and sets the current Guarded control stack pointer
to the stack that is being switched to.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSSS---Guarded-control-stack-switch-stack---"
    )
    this["gcsss2"] = OpCodeDoc(
        "GCSSS2",
        """Guarded Control Stack Switch Stack 2 validates that the most recent entry of
the Guarded control stack being switched to contains an In-progress cap entry,
stores a Valid cap entry to the Guarded control stack that is being switched
from, and sets Xt to the Guarded control stack pointer that is being switched
from.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSSS---Guarded-control-stack-switch-stack---"
    )
    this["gcsstr"] = OpCodeDoc(
        "GCSSTR",
        """Guarded Control Stack Store stores a doubleword from a register to memory. The
address that is used for the store is calculated from a base register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSSTR--Guarded-control-stack-store-"
    )
    this["gcssttr"] = OpCodeDoc(
        "GCSSTTR",
        """Guarded Control Stack unprivileged Store stores a doubleword from a register
to memory. The address that is used for the store is calculated from a base
register.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1 and HCR_EL2.{NV, NV1} is not {1, 1}.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GCSSTTR--Guarded-control-stack-unprivileged-store-"
    )
    this["gmi"] = OpCodeDoc(
        "GMI",
        """Tag Mask Insert inserts the tag in the first source register into the excluded
set specified in the second source register, writing the new excluded set to
the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/GMI--Tag-mask-insert-"
    )
    this["hint"] = OpCodeDoc(
        "HINT",
        """Hint instruction is for the instruction set space that is reserved for
architectural hint instructions.

Some encodings described here are not allocated in this revision of the
architecture, and behave as NOPs. These encodings might be allocated to other
hint functionality in future revisions of the architecture and therefore must
not be used by software.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/HINT--Hint-instruction-"
    )
    this["histcnt"] = OpCodeDoc(
        "HISTCNT",
        """This instruction compares each active 32 or 64-bit element of the first source
vector with all active elements with an element number less than or equal to
its own in the second source vector, and places the count of matching elements
in the corresponding element of the destination vector. Inactive elements in
the destination vector are set to zero.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/HISTCNT---"
    )
    this["histseg"] = OpCodeDoc(
        "HISTSEG",
        """This instruction compares each 8-bit byte element of the first source vector
with all of the elements in the corresponding 128-bit segment of the second
source vector and places the count of matching elements in the corresponding
element of the destination vector. This instruction is unpredicated.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/HISTSEG---"
    )
    this["hlt"] = OpCodeDoc(
        "HLT",
        """Halt instruction. An `HLT` instruction can generate a Halt Instruction debug
event, which causes entry into Debug state.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/HLT--Halt-instruction-"
    )
    this["hvc"] = OpCodeDoc(
        "HVC",
        """Hypervisor Call causes an exception to EL2. Software executing at EL1 can use
this instruction to call the hypervisor to request a service.

The `HVC` instruction is undefined:

  * When EL3 is implemented and SCR_EL3.HCE is set to 0.
  * When EL3 is not implemented and HCR_EL2.HCD is set to 1.
  * When EL2 is not implemented.
  * At EL1 if EL2 is not enabled in the current Security state.
  * At EL0.

On executing an `HVC` instruction, the PE records the exception as a
Hypervisor Call exception in ESR_ELx, using the EC value 0x16, and the value
of the immediate argument.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/HVC--Hypervisor-call-"
    )
    this["ic"] = OpCodeDoc(
        "IC",
        """Instruction Cache operation. For more information, see op0==0b01, cache
maintenance, TLB maintenance, and address translation instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/IC--Instruction-cache-operation-"
    )
    this["incb"] = OpCodeDoc(
        "INCB",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/INCB--INCD--INCH--INCW--scalar----"
    )
    this["incd"] = OpCodeDoc(
        "INCD",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/INCB--INCD--INCH--INCW--scalar----"
    )
    this["inch"] = OpCodeDoc(
        "INCH",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/INCB--INCD--INCH--INCW--scalar----"
    )
    this["incw"] = OpCodeDoc(
        "INCW",
        """Determines the number of active elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/INCB--INCD--INCH--INCW--scalar----"
    )
    this["incp"] = OpCodeDoc(
        "INCP",
        """Counts the number of true elements in the source predicate and then uses the
result to increment the scalar destination.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/INCP--scalar----"
    )
    this["index"] = OpCodeDoc(
        "INDEX",
        """Populates the destination vector by setting the first element to the first
signed immediate integer operand and monotonically incrementing the value by
the second signed immediate integer operand for each subsequent element. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/INDEX--immediates----"
    )
    this["ins"] = OpCodeDoc(
        "INS",
        """Insert vector element from another vector element. This instruction copies the
vector element of the source SIMD&FP register to the specified vector element
of the destination SIMD&FP register.

This instruction can insert data into individual elements within a SIMD&FP
register without clearing the remaining bits to zero.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/INS--element---Insert-vector-element-from-another-vector-element-"
    )
    this["insr"] = OpCodeDoc(
        "INSR",
        """Shift the destination vector left by one element, and then place a copy of the
least-significant bits of the general-purpose register in element 0 of the
destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/INSR--scalar----"
    )
    this["irg"] = OpCodeDoc(
        "IRG",
        """Insert Random Tag inserts a random Logical Address Tag into the address in the
first source register, and writes the result to the destination register. Any
tags specified in the optional second source register or in GCR_EL1.Exclude
are excluded from the selection of the random Logical Address Tag.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/IRG--Insert-random-tag-"
    )
    this["isb"] = OpCodeDoc(
        "ISB",
        """Instruction Synchronization Barrier flushes the pipeline in the PE and is a
context synchronization event. For more information, see Instruction
Synchronization Barrier (ISB).

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ISB--Instruction-synchronization-barrier-"
    )
    this["lasta"] = OpCodeDoc(
        "LASTA",
        """If there is an active element then extract the element after the last active
element modulo the number of elements from the final source vector register.
If there are no active elements, extract element zero. Then zero-extend and
place the extracted element in the destination general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LASTA--scalar----"
    )
    this["lastb"] = OpCodeDoc(
        "LASTB",
        """If there is an active element then extract the last active element from the
final source vector register. If there are no active elements, extract the
highest-numbered element. Then zero-extend and place the extracted element in
the destination general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LASTB--scalar----"
    )
    this["ld1"] = OpCodeDoc(
        "LD1",
        """Load multiple single-element structures to one, two, three, or four registers.
This instruction loads multiple single-element structures from memory and
writes the result to one, two, three, or four SIMD&FP registers.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD---multiple-structures---Load-multiple-single-element-structures-to-one--two--three--or-four-registers-"
    )
    this["ld1b"] = OpCodeDoc(
        "LD1B",
        """Contiguous load of unsigned bytes to elements of two or four consecutive
vector registers from the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-B--scalar-plus-immediate--consecutive-registers----"
    )
    this["ld1d"] = OpCodeDoc(
        "LD1D",
        """Contiguous load of unsigned doublewords to elements of two or four consecutive
vector registers from the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-D--scalar-plus-immediate--consecutive-registers----"
    )
    this["ld1h"] = OpCodeDoc(
        "LD1H",
        """Contiguous load of unsigned halfwords to elements of two or four consecutive
vector registers from the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-H--scalar-plus-immediate--consecutive-registers----"
    )
    this["ld1q"] = OpCodeDoc(
        "LD1Q",
        """Gather load of quadwords to active elements of a vector register from memory
addresses generated by a vector base plus a 64-bit unscaled scalar register
offset. Inactive elements will not cause a read from Device memory or signal
faults, and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-Q---"
    )
    this["ld1r"] = OpCodeDoc(
        "LD1R",
        """Load one single-element structure and Replicate to all lanes (of one
register). This instruction loads a single-element structure from memory and
replicates the structure to all the lanes of the SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-R--Load-one-single-element-structure-and-replicate-to-all-lanes--of-one-register--"
    )
    this["ld1rb"] = OpCodeDoc(
        "LD1RB",
        """Load a single unsigned byte from a memory address generated by a 64-bit scalar
base address plus an immediate offset which is in the range 0 to 63.

Broadcast the loaded data into all active elements of the destination vector,
setting the inactive elements to zero. If all elements are inactive then the
instruction will not perform a read from Device memory or cause a data abort.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RB---"
    )
    this["ld1rd"] = OpCodeDoc(
        "LD1RD",
        """Load a single doubleword from a memory address generated by a 64-bit scalar
base address plus an immediate offset which is a multiple of 8 in the range 0
to 504.

Broadcast the loaded data into all active elements of the destination vector,
setting the inactive elements to zero. If all elements are inactive then the
instruction will not perform a read from Device memory or cause a data abort.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RD---"
    )
    this["ld1rh"] = OpCodeDoc(
        "LD1RH",
        """Load a single unsigned halfword from a memory address generated by a 64-bit
scalar base address plus an immediate offset which is a multiple of 2 in the
range 0 to 126.

Broadcast the loaded data into all active elements of the destination vector,
setting the inactive elements to zero. If all elements are inactive then the
instruction will not perform a read from Device memory or cause a data abort.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RH---"
    )
    this["ld1rob"] = OpCodeDoc(
        "LD1ROB",
        """Load thirty-two contiguous bytes to elements of a 256-bit (octaword) vector
from the memory address generated by a 64-bit scalar base address and
immediate index that is a multiple of 32 in the range -256 to +224 added to
the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero.

The resulting 256-bit vector is then replicated to fill the destination
vector. The instruction requires that the current vector length is at least
256 bits, and if the current vector length is not an integer multiple of 256
bits then the trailing bits in the destination vector are set to zero.

Only the first thirty-two predicate elements are used and higher numbered
predicate elements are ignored.

ID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-ROB--scalar-plus-immediate----"
    )
    this["ld1rod"] = OpCodeDoc(
        "LD1ROD",
        """Load four contiguous doublewords to elements of a 256-bit (octaword) vector
from the memory address generated by a 64-bit scalar base address and
immediate index that is a multiple of 32 in the range -256 to +224 added to
the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero.

The resulting 256-bit vector is then replicated to fill the destination
vector. The instruction requires that the current vector length is at least
256 bits, and if the current vector length is not an integer multiple of 256
bits then the trailing bits in the destination vector are set to zero.

Only the first four predicate elements are used and higher numbered predicate
elements are ignored.

ID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-ROD--scalar-plus-immediate----"
    )
    this["ld1roh"] = OpCodeDoc(
        "LD1ROH",
        """Load sixteen contiguous halfwords to elements of a 256-bit (octaword) vector
from the memory address generated by a 64-bit scalar base address and
immediate index that is a multiple of 32 in the range -256 to +224 added to
the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero.

The resulting 256-bit vector is then replicated to fill the destination
vector. The instruction requires that the current vector length is at least
256 bits, and if the current vector length is not an integer multiple of 256
bits then the trailing bits in the destination vector are set to zero.

Only the first sixteen predicate elements are used and higher numbered
predicate elements are ignored.

ID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-ROH--scalar-plus-immediate----"
    )
    this["ld1row"] = OpCodeDoc(
        "LD1ROW",
        """Load eight contiguous words to elements of a 256-bit (octaword) vector from
the memory address generated by a 64-bit scalar base address and immediate
index that is a multiple of 32 in the range -256 to +224 added to the base
address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero.

The resulting 256-bit vector is then replicated to fill the destination
vector. The instruction requires that the current vector length is at least
256 bits, and if the current vector length is not an integer multiple of 256
bits then the trailing bits in the destination vector are set to zero.

Only the first eight predicate elements are used and higher numbered predicate
elements are ignored.

ID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-ROW--scalar-plus-immediate----"
    )
    this["ld1rqb"] = OpCodeDoc(
        "LD1RQB",
        """Load sixteen contiguous bytes to elements of a short, 128-bit (quadword)
vector from the memory address generated by a 64-bit scalar base address and
immediate index that is a multiple of 16 in the range -128 to +112 added to
the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero. The resulting short vector is then replicated to fill the
long destination vector. Only the first sixteen predicate elements are used
and higher numbered predicate elements are ignored.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RQB--scalar-plus-immediate----"
    )
    this["ld1rqd"] = OpCodeDoc(
        "LD1RQD",
        """Load two contiguous doublewords to elements of a short, 128-bit (quadword)
vector from the memory address generated by a 64-bit scalar base address and
immediate index that is a multiple of 16 in the range -128 to +112 added to
the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero. The resulting short vector is then replicated to fill the
long destination vector. Only the first two predicate elements are used and
higher numbered predicate elements are ignored.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RQD--scalar-plus-immediate----"
    )
    this["ld1rqh"] = OpCodeDoc(
        "LD1RQH",
        """Load eight contiguous halfwords to elements of a short, 128-bit (quadword)
vector from the memory address generated by a 64-bit scalar base address and
immediate index that is a multiple of 16 in the range -128 to +112 added to
the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero. The resulting short vector is then replicated to fill the
long destination vector. Only the first eight predicate elements are used and
higher numbered predicate elements are ignored.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RQH--scalar-plus-immediate----"
    )
    this["ld1rqw"] = OpCodeDoc(
        "LD1RQW",
        """Load four contiguous words to elements of a short, 128-bit (quadword) vector
from the memory address generated by a 64-bit scalar base address and
immediate index that is a multiple of 16 in the range -128 to +112 added to
the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero. The resulting short vector is then replicated to fill the
long destination vector. Only the first four predicate elements are used and
higher numbered predicate elements are ignored.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RQW--scalar-plus-immediate----"
    )
    this["ld1rsb"] = OpCodeDoc(
        "LD1RSB",
        """Load a single signed byte from a memory address generated by a 64-bit scalar
base address plus an immediate offset which is in the range 0 to 63.

Broadcast the loaded data into all active elements of the destination vector,
setting the inactive elements to zero. If all elements are inactive then the
instruction will not perform a read from Device memory or cause a data abort.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RSB---"
    )
    this["ld1rsh"] = OpCodeDoc(
        "LD1RSH",
        """Load a single signed halfword from a memory address generated by a 64-bit
scalar base address plus an immediate offset which is a multiple of 2 in the
range 0 to 126.

Broadcast the loaded data into all active elements of the destination vector,
setting the inactive elements to zero. If all elements are inactive then the
instruction will not perform a read from Device memory or cause a data abort.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RSH---"
    )
    this["ld1rsw"] = OpCodeDoc(
        "LD1RSW",
        """Load a single signed word from a memory address generated by a 64-bit scalar
base address plus an immediate offset which is a multiple of 4 in the range 0
to 252.

Broadcast the loaded data into all active elements of the destination vector,
setting the inactive elements to zero. If all elements are inactive then the
instruction will not perform a read from Device memory or cause a data abort.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RSW---"
    )
    this["ld1rw"] = OpCodeDoc(
        "LD1RW",
        """Load a single unsigned word from a memory address generated by a 64-bit scalar
base address plus an immediate offset which is a multiple of 4 in the range 0
to 252.

Broadcast the loaded data into all active elements of the destination vector,
setting the inactive elements to zero. If all elements are inactive then the
instruction will not perform a read from Device memory or cause a data abort.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-RW---"
    )
    this["ld1sb"] = OpCodeDoc(
        "LD1SB",
        """Gather load of signed bytes to active elements of a vector register from
memory addresses generated by a vector base plus immediate index. The index is
in the range 0 to 31. Inactive elements will not cause a read from Device
memory or signal faults, and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-SB--vector-plus-immediate----"
    )
    this["ld1sh"] = OpCodeDoc(
        "LD1SH",
        """Gather load of signed halfwords to active elements of a vector register from
memory addresses generated by a vector base plus immediate index. The index is
a multiple of 2 in the range 0 to 62. Inactive elements will not cause a read
from Device memory or signal faults, and are set to zero in the destination
vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-SH--vector-plus-immediate----"
    )
    this["ld1sw"] = OpCodeDoc(
        "LD1SW",
        """Gather load of signed words to active elements of a vector register from
memory addresses generated by a vector base plus immediate index. The index is
a multiple of 4 in the range 0 to 124. Inactive elements will not cause a read
from Device memory or signal faults, and are set to zero in the destination
vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-SW--vector-plus-immediate----"
    )
    this["ld1w"] = OpCodeDoc(
        "LD1W",
        """Contiguous load of unsigned words to elements of two or four consecutive
vector registers from the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-W--scalar-plus-immediate--consecutive-registers----"
    )
    this["ld2"] = OpCodeDoc(
        "LD2",
        """Load multiple 2-element structures to two registers. This instruction loads
multiple 2-element structures from memory and writes the result to the two
SIMD&FP registers, with de-interleaving.

For an example of de-interleaving, see `LD3 (multiple structures)`.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD---multiple-structures---Load-multiple---element-structures-to-two-registers-"
    )
    this["ld2b"] = OpCodeDoc(
        "LD2B",
        """Contiguous load two-byte structures, each to the same element number in two
vector registers from the memory address generated by a 64-bit scalar base and
an immediate index which is a multiple of 2 in the range -16 to 14 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive bytes in memory which
make up each structure. Inactive elements will not cause a read from Device
memory or signal a fault, and the corresponding element is set to zero in each
of the two destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-B--scalar-plus-immediate----"
    )
    this["ld2d"] = OpCodeDoc(
        "LD2D",
        """Contiguous load two-doubleword structures, each to the same element number in
two vector registers from the memory address generated by a 64-bit scalar base
and an immediate index which is a multiple of 2 in the range -16 to 14 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive doublewords in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the two destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-D--scalar-plus-immediate----"
    )
    this["ld2h"] = OpCodeDoc(
        "LD2H",
        """Contiguous load two-halfword structures, each to the same element number in
two vector registers from the memory address generated by a 64-bit scalar base
and an immediate index which is a multiple of 2 in the range -16 to 14 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive halfwords in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the two destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-H--scalar-plus-immediate----"
    )
    this["ld2q"] = OpCodeDoc(
        "LD2Q",
        """Contiguous load two-quadword structures, each to the same element number in
two vector registers from the memory address generated by a 64-bit scalar base
and an immediate index which is a multiple of 2 in the range -16 to 14 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive quadwords in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the two destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-Q--scalar-plus-immediate----"
    )
    this["ld2r"] = OpCodeDoc(
        "LD2R",
        """Load single 2-element structure and Replicate to all lanes of two registers.
This instruction loads a 2-element structure from memory and replicates the
structure to all the lanes of the two SIMD&FP registers.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-R--Load-single---element-structure-and-replicate-to-all-lanes-of-two-registers-"
    )
    this["ld2w"] = OpCodeDoc(
        "LD2W",
        """Contiguous load two-word structures, each to the same element number in two
vector registers from the memory address generated by a 64-bit scalar base and
an immediate index which is a multiple of 2 in the range -16 to 14 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive words in memory which
make up each structure. Inactive elements will not cause a read from Device
memory or signal a fault, and the corresponding element is set to zero in each
of the two destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-W--scalar-plus-immediate----"
    )
    this["ld3"] = OpCodeDoc(
        "LD3",
        """Load multiple 3-element structures to three registers. This instruction loads
multiple 3-element structures from memory and writes the result to the three
SIMD&FP registers, with de-interleaving.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD---multiple-structures---Load-multiple---element-structures-to-three-registers-"
    )
    this["ld3b"] = OpCodeDoc(
        "LD3B",
        """Contiguous load three-byte structures, each to the same element number in
three vector registers from the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 3 in the range -24 to 21
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive bytes in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the three destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-B--scalar-plus-immediate----"
    )
    this["ld3d"] = OpCodeDoc(
        "LD3D",
        """Contiguous load three-doubleword structures, each to the same element number
in three vector registers from the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 3 in the range -24 to 21
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive doublewords in
memory which make up each structure. Inactive elements will not cause a read
from Device memory or signal a fault, and the corresponding element is set to
zero in each of the three destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-D--scalar-plus-immediate----"
    )
    this["ld3h"] = OpCodeDoc(
        "LD3H",
        """Contiguous load three-halfword structures, each to the same element number in
three vector registers from the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 3 in the range -24 to 21
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive halfwords in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the three destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-H--scalar-plus-immediate----"
    )
    this["ld3q"] = OpCodeDoc(
        "LD3Q",
        """Contiguous load three-quadword structures, each to the same element number in
three vector registers from the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 3 in the range -24 to 21
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive quadwords in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the three destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-Q--scalar-plus-immediate----"
    )
    this["ld3r"] = OpCodeDoc(
        "LD3R",
        """Load single 3-element structure and Replicate to all lanes of three registers.
This instruction loads a 3-element structure from memory and replicates the
structure to all the lanes of the three SIMD&FP registers.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-R--Load-single---element-structure-and-replicate-to-all-lanes-of-three-registers-"
    )
    this["ld3w"] = OpCodeDoc(
        "LD3W",
        """Contiguous load three-word structures, each to the same element number in
three vector registers from the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 3 in the range -24 to 21
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive words in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the three destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-W--scalar-plus-immediate----"
    )
    this["ld4"] = OpCodeDoc(
        "LD4",
        """Load multiple 4-element structures to four registers. This instruction loads
multiple 4-element structures from memory and writes the result to the four
SIMD&FP registers, with de-interleaving.

For an example of de-interleaving, see `LD3 (multiple structures)`.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD---multiple-structures---Load-multiple---element-structures-to-four-registers-"
    )
    this["ld4b"] = OpCodeDoc(
        "LD4B",
        """Contiguous load four-byte structures, each to the same element number in four
vector registers from the memory address generated by a 64-bit scalar base and
an immediate index which is a multiple of 4 in the range -32 to 28 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive bytes in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the four destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-B--scalar-plus-immediate----"
    )
    this["ld4d"] = OpCodeDoc(
        "LD4D",
        """Contiguous load four-doubleword structures, each to the same element number in
four vector registers from the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 4 in the range -32 to 28
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive doublewords in
memory which make up each structure. Inactive elements will not cause a read
from Device memory or signal a fault, and the corresponding element is set to
zero in each of the four destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-D--scalar-plus-immediate----"
    )
    this["ld4h"] = OpCodeDoc(
        "LD4H",
        """Contiguous load four-halfword structures, each to the same element number in
four vector registers from the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 4 in the range -32 to 28
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive halfwords in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the four destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-H--scalar-plus-immediate----"
    )
    this["ld4q"] = OpCodeDoc(
        "LD4Q",
        """Contiguous load four-quadword structures, each to the same element number in
four vector registers from the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 4 in the range -32 to 28
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive quadwords in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the four destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-Q--scalar-plus-immediate----"
    )
    this["ld4r"] = OpCodeDoc(
        "LD4R",
        """Load single 4-element structure and Replicate to all lanes of four registers.
This instruction loads a 4-element structure from memory and replicates the
structure to all the lanes of the four SIMD&FP registers.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-R--Load-single---element-structure-and-replicate-to-all-lanes-of-four-registers-"
    )
    this["ld4w"] = OpCodeDoc(
        "LD4W",
        """Contiguous load four-word structures, each to the same element number in four
vector registers from the memory address generated by a 64-bit scalar base and
an immediate index which is a multiple of 4 in the range -32 to 28 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive words in memory
which make up each structure. Inactive elements will not cause a read from
Device memory or signal a fault, and the corresponding element is set to zero
in each of the four destination vector registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD-W--scalar-plus-immediate----"
    )
    this["ld64b"] = OpCodeDoc(
        "LD64B",
        """Single-copy Atomic 64-byte Load derives an address from a base register value,
loads eight 64-bit doublewords from a memory location, and writes them to
consecutive registers, Xt to X(t+7). The data that is loaded is atomic and is
required to be 64-byte aligned.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LD--B--Single-copy-atomic----byte-load-"
    )
    this["ldadd"] = OpCodeDoc(
        "LDADD",
        """Atomic add on word or doubleword in memory atomically loads a 32-bit word or
64-bit doubleword from memory, adds the value held in a register to it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDADDA` and `LDADDAL` load from memory with acquire semantics.
  * `LDADDL` and `LDADDAL` store to memory with release semantics.
  * `LDADD` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADD--LDADDA--LDADDAL--LDADDL--Atomic-add-on-word-or-doubleword-in-memory-"
    )
    this["ldadda"] = OpCodeDoc(
        "LDADDA",
        """Atomic add on word or doubleword in memory atomically loads a 32-bit word or
64-bit doubleword from memory, adds the value held in a register to it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDADDA` and `LDADDAL` load from memory with acquire semantics.
  * `LDADDL` and `LDADDAL` store to memory with release semantics.
  * `LDADD` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADD--LDADDA--LDADDAL--LDADDL--Atomic-add-on-word-or-doubleword-in-memory-"
    )
    this["ldaddal"] = OpCodeDoc(
        "LDADDAL",
        """Atomic add on word or doubleword in memory atomically loads a 32-bit word or
64-bit doubleword from memory, adds the value held in a register to it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDADDA` and `LDADDAL` load from memory with acquire semantics.
  * `LDADDL` and `LDADDAL` store to memory with release semantics.
  * `LDADD` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADD--LDADDA--LDADDAL--LDADDL--Atomic-add-on-word-or-doubleword-in-memory-"
    )
    this["ldaddl"] = OpCodeDoc(
        "LDADDL",
        """Atomic add on word or doubleword in memory atomically loads a 32-bit word or
64-bit doubleword from memory, adds the value held in a register to it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDADDA` and `LDADDAL` load from memory with acquire semantics.
  * `LDADDL` and `LDADDAL` store to memory with release semantics.
  * `LDADD` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADD--LDADDA--LDADDAL--LDADDL--Atomic-add-on-word-or-doubleword-in-memory-"
    )
    this["ldaddab"] = OpCodeDoc(
        "LDADDAB",
        """Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds
the value held in a register to it, and stores the result back to memory. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDADDAB` and `LDADDALB` load from memory with acquire semantics.
  * `LDADDLB` and `LDADDALB` store to memory with release semantics.
  * `LDADDB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADDB--LDADDAB--LDADDALB--LDADDLB--Atomic-add-on-byte-in-memory-"
    )
    this["ldaddalb"] = OpCodeDoc(
        "LDADDALB",
        """Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds
the value held in a register to it, and stores the result back to memory. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDADDAB` and `LDADDALB` load from memory with acquire semantics.
  * `LDADDLB` and `LDADDALB` store to memory with release semantics.
  * `LDADDB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADDB--LDADDAB--LDADDALB--LDADDLB--Atomic-add-on-byte-in-memory-"
    )
    this["ldaddb"] = OpCodeDoc(
        "LDADDB",
        """Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds
the value held in a register to it, and stores the result back to memory. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDADDAB` and `LDADDALB` load from memory with acquire semantics.
  * `LDADDLB` and `LDADDALB` store to memory with release semantics.
  * `LDADDB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADDB--LDADDAB--LDADDALB--LDADDLB--Atomic-add-on-byte-in-memory-"
    )
    this["ldaddlb"] = OpCodeDoc(
        "LDADDLB",
        """Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds
the value held in a register to it, and stores the result back to memory. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDADDAB` and `LDADDALB` load from memory with acquire semantics.
  * `LDADDLB` and `LDADDALB` store to memory with release semantics.
  * `LDADDB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADDB--LDADDAB--LDADDALB--LDADDLB--Atomic-add-on-byte-in-memory-"
    )
    this["ldaddah"] = OpCodeDoc(
        "LDADDAH",
        """Atomic add on halfword in memory atomically loads a 16-bit halfword from
memory, adds the value held in a register to it, and stores the result back to
memory. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDADDAH` and `LDADDALH` load from memory with acquire semantics.
  * `LDADDLH` and `LDADDALH` store to memory with release semantics.
  * `LDADDH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADDH--LDADDAH--LDADDALH--LDADDLH--Atomic-add-on-halfword-in-memory-"
    )
    this["ldaddalh"] = OpCodeDoc(
        "LDADDALH",
        """Atomic add on halfword in memory atomically loads a 16-bit halfword from
memory, adds the value held in a register to it, and stores the result back to
memory. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDADDAH` and `LDADDALH` load from memory with acquire semantics.
  * `LDADDLH` and `LDADDALH` store to memory with release semantics.
  * `LDADDH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADDH--LDADDAH--LDADDALH--LDADDLH--Atomic-add-on-halfword-in-memory-"
    )
    this["ldaddh"] = OpCodeDoc(
        "LDADDH",
        """Atomic add on halfword in memory atomically loads a 16-bit halfword from
memory, adds the value held in a register to it, and stores the result back to
memory. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDADDAH` and `LDADDALH` load from memory with acquire semantics.
  * `LDADDLH` and `LDADDALH` store to memory with release semantics.
  * `LDADDH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADDH--LDADDAH--LDADDALH--LDADDLH--Atomic-add-on-halfword-in-memory-"
    )
    this["ldaddlh"] = OpCodeDoc(
        "LDADDLH",
        """Atomic add on halfword in memory atomically loads a 16-bit halfword from
memory, adds the value held in a register to it, and stores the result back to
memory. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDADDAH` and `LDADDALH` load from memory with acquire semantics.
  * `LDADDLH` and `LDADDALH` store to memory with release semantics.
  * `LDADDH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDADDH--LDADDAH--LDADDALH--LDADDLH--Atomic-add-on-halfword-in-memory-"
    )
    this["ldap1"] = OpCodeDoc(
        "LDAP1",
        """Load-Acquire RCpc one single-element structure to one lane of one register.
This instruction loads a single-element structure from memory and writes the
result to the specified lane of the SIMD&FP register without affecting the
other bits of the register.

The instruction has memory ordering semantics, as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about memory accesses, see Load/Store addressing modes.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAP---SIMD-FP---Load-acquire-rcpc-one-single-element-structure-to-one-lane-of-one-register-"
    )
    this["ldapr"] = OpCodeDoc(
        "LDAPR",
        """Load-Acquire RCpc Register derives an address from a base register value,
loads a 32-bit word or 64-bit doubleword from the derived address in memory,
and writes it to a register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAPR--Load-acquire-rcpc-register-"
    )
    this["ldaprb"] = OpCodeDoc(
        "LDAPRB",
        """Load-Acquire RCpc Register Byte derives an address from a base register value,
loads a byte from the derived address in memory, zero-extends it and writes it
to a register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAPRB--Load-acquire-rcpc-register-byte-"
    )
    this["ldaprh"] = OpCodeDoc(
        "LDAPRH",
        """Load-Acquire RCpc Register Halfword derives an address from a base register
value, loads a halfword from the derived address in memory, zero-extends it
and writes it to a register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAPRH--Load-acquire-rcpc-register-halfword-"
    )
    this["ldapur"] = OpCodeDoc(
        "LDAPUR",
        """Load-Acquire RCpc SIMD&FP Register (unscaled offset). This instruction loads a
SIMD&FP register from memory. The address that is used for the load is
calculated from a base register value and an optional immediate offset.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAPUR--SIMD-FP---Load-acquire-rcpc-simd-fp-register--unscaled-offset--"
    )
    this["ldapurb"] = OpCodeDoc(
        "LDAPURB",
        """Load-Acquire RCpc Register Byte (unscaled) calculates an address from a base
register and an immediate offset, loads a byte from memory, zero-extends it,
and writes it to a register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAPURB--Load-acquire-rcpc-register-byte--unscaled--"
    )
    this["ldapurh"] = OpCodeDoc(
        "LDAPURH",
        """Load-Acquire RCpc Register Halfword (unscaled) calculates an address from a
base register and an immediate offset, loads a halfword from memory, zero-
extends it, and writes it to a register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAPURH--Load-acquire-rcpc-register-halfword--unscaled--"
    )
    this["ldapursb"] = OpCodeDoc(
        "LDAPURSB",
        """Load-Acquire RCpc Register Signed Byte (unscaled) calculates an address from a
base register and an immediate offset, loads a signed byte from memory, sign-
extends it, and writes it to a register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAPURSB--Load-acquire-rcpc-register-signed-byte--unscaled--"
    )
    this["ldapursh"] = OpCodeDoc(
        "LDAPURSH",
        """Load-Acquire RCpc Register Signed Halfword (unscaled) calculates an address
from a base register and an immediate offset, loads a signed halfword from
memory, sign-extends it, and writes it to a register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAPURSH--Load-acquire-rcpc-register-signed-halfword--unscaled--"
    )
    this["ldapursw"] = OpCodeDoc(
        "LDAPURSW",
        """Load-Acquire RCpc Register Signed Word (unscaled) calculates an address from a
base register and an immediate offset, loads a signed word from memory, sign-
extends it, and writes it to a register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release, except that:

  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAPURSW--Load-acquire-rcpc-register-signed-word--unscaled--"
    )
    this["ldar"] = OpCodeDoc(
        "LDAR",
        """Load-Acquire Register derives an address from a base register value, loads a
32-bit word or 64-bit doubleword from memory, and writes it to a register. The
instruction also has memory ordering semantics as described in Load-Acquire,
Store-Release. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAR--Load-acquire-register-"
    )
    this["ldarb"] = OpCodeDoc(
        "LDARB",
        """Load-Acquire Register Byte derives an address from a base register value,
loads a byte from memory, zero-extends it and writes it to a register. The
instruction also has memory ordering semantics as described in Load-Acquire,
Store-Release. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDARB--Load-acquire-register-byte-"
    )
    this["ldarh"] = OpCodeDoc(
        "LDARH",
        """Load-Acquire Register Halfword derives an address from a base register value,
loads a halfword from memory, zero-extends it, and writes it to a register.
The instruction also has memory ordering semantics as described in Load-
Acquire, Store-Release. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDARH--Load-acquire-register-halfword-"
    )
    this["ldaxp"] = OpCodeDoc(
        "LDAXP",
        """Load-Acquire Exclusive Pair of Registers derives an address from a base
register value, loads two 32-bit words or two 64-bit doublewords from memory,
and writes them to two registers. For information on single-copy atomicity and
alignment requirements, see Requirements for single-copy atomicity and
Alignment of data accesses. The PE marks the physical address being accessed
as an exclusive access. This exclusive access mark is checked by Store
Exclusive instructions. See Synchronization and semaphores. The instruction
also has memory ordering semantics, as described in Load-Acquire, Store-
Release. For information about memory accesses, see Load/Store addressing
modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAXP--Load-acquire-exclusive-pair-of-registers-"
    )
    this["ldaxr"] = OpCodeDoc(
        "LDAXR",
        """Load-Acquire Exclusive Register derives an address from a base register value,
loads a 32-bit word or 64-bit doubleword from memory, and writes it to a
register. The memory access is atomic. The PE marks the physical address being
accessed as an exclusive access. This exclusive access mark is checked by
Store Exclusive instructions. See Synchronization and semaphores. The
instruction also has memory ordering semantics as described in Load-Acquire,
Store-Release. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAXR--Load-acquire-exclusive-register-"
    )
    this["ldaxrb"] = OpCodeDoc(
        "LDAXRB",
        """Load-Acquire Exclusive Register Byte derives an address from a base register
value, loads a byte from memory, zero-extends it and writes it to a register.
The memory access is atomic. The PE marks the physical address being accessed
as an exclusive access. This exclusive access mark is checked by Store
Exclusive instructions. See Synchronization and semaphores. The instruction
also has memory ordering semantics as described in Load-Acquire, Store-
Release. For information about memory accesses, see Load/Store addressing
modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAXRB--Load-acquire-exclusive-register-byte-"
    )
    this["ldaxrh"] = OpCodeDoc(
        "LDAXRH",
        """Load-Acquire Exclusive Register Halfword derives an address from a base
register value, loads a halfword from memory, zero-extends it and writes it to
a register. The memory access is atomic. The PE marks the physical address
being accessed as an exclusive access. This exclusive access mark is checked
by Store Exclusive instructions. See Synchronization and semaphores. The
instruction also has memory ordering semantics as described in Load-Acquire,
Store-Release. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDAXRH--Load-acquire-exclusive-register-halfword-"
    )
    this["ldclr"] = OpCodeDoc(
        "LDCLR",
        """Atomic bit clear on word or doubleword in memory atomically loads a 32-bit
word or 64-bit doubleword from memory, performs a bitwise AND with the
complement of the value held in a register on it, and stores the result back
to memory. The value initially loaded from memory is returned in the
destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDCLRA` and `LDCLRAL` load from memory with acquire semantics.
  * `LDCLRL` and `LDCLRAL` store to memory with release semantics.
  * `LDCLR` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLR--LDCLRA--LDCLRAL--LDCLRL--Atomic-bit-clear-on-word-or-doubleword-in-memory-"
    )
    this["ldclra"] = OpCodeDoc(
        "LDCLRA",
        """Atomic bit clear on word or doubleword in memory atomically loads a 32-bit
word or 64-bit doubleword from memory, performs a bitwise AND with the
complement of the value held in a register on it, and stores the result back
to memory. The value initially loaded from memory is returned in the
destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDCLRA` and `LDCLRAL` load from memory with acquire semantics.
  * `LDCLRL` and `LDCLRAL` store to memory with release semantics.
  * `LDCLR` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLR--LDCLRA--LDCLRAL--LDCLRL--Atomic-bit-clear-on-word-or-doubleword-in-memory-"
    )
    this["ldclral"] = OpCodeDoc(
        "LDCLRAL",
        """Atomic bit clear on word or doubleword in memory atomically loads a 32-bit
word or 64-bit doubleword from memory, performs a bitwise AND with the
complement of the value held in a register on it, and stores the result back
to memory. The value initially loaded from memory is returned in the
destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDCLRA` and `LDCLRAL` load from memory with acquire semantics.
  * `LDCLRL` and `LDCLRAL` store to memory with release semantics.
  * `LDCLR` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLR--LDCLRA--LDCLRAL--LDCLRL--Atomic-bit-clear-on-word-or-doubleword-in-memory-"
    )
    this["ldclrl"] = OpCodeDoc(
        "LDCLRL",
        """Atomic bit clear on word or doubleword in memory atomically loads a 32-bit
word or 64-bit doubleword from memory, performs a bitwise AND with the
complement of the value held in a register on it, and stores the result back
to memory. The value initially loaded from memory is returned in the
destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDCLRA` and `LDCLRAL` load from memory with acquire semantics.
  * `LDCLRL` and `LDCLRAL` store to memory with release semantics.
  * `LDCLR` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLR--LDCLRA--LDCLRAL--LDCLRL--Atomic-bit-clear-on-word-or-doubleword-in-memory-"
    )
    this["ldclrab"] = OpCodeDoc(
        "LDCLRAB",
        """Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory,
performs a bitwise AND with the complement of the value held in a register on
it, and stores the result back to memory. The value initially loaded from
memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDCLRAB` and `LDCLRALB` load from memory with acquire semantics.
  * `LDCLRLB` and `LDCLRALB` store to memory with release semantics.
  * `LDCLRB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRB--LDCLRAB--LDCLRALB--LDCLRLB--Atomic-bit-clear-on-byte-in-memory-"
    )
    this["ldclralb"] = OpCodeDoc(
        "LDCLRALB",
        """Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory,
performs a bitwise AND with the complement of the value held in a register on
it, and stores the result back to memory. The value initially loaded from
memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDCLRAB` and `LDCLRALB` load from memory with acquire semantics.
  * `LDCLRLB` and `LDCLRALB` store to memory with release semantics.
  * `LDCLRB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRB--LDCLRAB--LDCLRALB--LDCLRLB--Atomic-bit-clear-on-byte-in-memory-"
    )
    this["ldclrb"] = OpCodeDoc(
        "LDCLRB",
        """Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory,
performs a bitwise AND with the complement of the value held in a register on
it, and stores the result back to memory. The value initially loaded from
memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDCLRAB` and `LDCLRALB` load from memory with acquire semantics.
  * `LDCLRLB` and `LDCLRALB` store to memory with release semantics.
  * `LDCLRB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRB--LDCLRAB--LDCLRALB--LDCLRLB--Atomic-bit-clear-on-byte-in-memory-"
    )
    this["ldclrlb"] = OpCodeDoc(
        "LDCLRLB",
        """Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory,
performs a bitwise AND with the complement of the value held in a register on
it, and stores the result back to memory. The value initially loaded from
memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDCLRAB` and `LDCLRALB` load from memory with acquire semantics.
  * `LDCLRLB` and `LDCLRALB` store to memory with release semantics.
  * `LDCLRB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRB--LDCLRAB--LDCLRALB--LDCLRLB--Atomic-bit-clear-on-byte-in-memory-"
    )
    this["ldclrah"] = OpCodeDoc(
        "LDCLRAH",
        """Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from
memory, performs a bitwise AND with the complement of the value held in a
register on it, and stores the result back to memory. The value initially
loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDCLRAH` and `LDCLRALH` load from memory with acquire semantics.
  * `LDCLRLH` and `LDCLRALH` store to memory with release semantics.
  * `LDCLRH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRH--LDCLRAH--LDCLRALH--LDCLRLH--Atomic-bit-clear-on-halfword-in-memory-"
    )
    this["ldclralh"] = OpCodeDoc(
        "LDCLRALH",
        """Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from
memory, performs a bitwise AND with the complement of the value held in a
register on it, and stores the result back to memory. The value initially
loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDCLRAH` and `LDCLRALH` load from memory with acquire semantics.
  * `LDCLRLH` and `LDCLRALH` store to memory with release semantics.
  * `LDCLRH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRH--LDCLRAH--LDCLRALH--LDCLRLH--Atomic-bit-clear-on-halfword-in-memory-"
    )
    this["ldclrh"] = OpCodeDoc(
        "LDCLRH",
        """Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from
memory, performs a bitwise AND with the complement of the value held in a
register on it, and stores the result back to memory. The value initially
loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDCLRAH` and `LDCLRALH` load from memory with acquire semantics.
  * `LDCLRLH` and `LDCLRALH` store to memory with release semantics.
  * `LDCLRH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRH--LDCLRAH--LDCLRALH--LDCLRLH--Atomic-bit-clear-on-halfword-in-memory-"
    )
    this["ldclrlh"] = OpCodeDoc(
        "LDCLRLH",
        """Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from
memory, performs a bitwise AND with the complement of the value held in a
register on it, and stores the result back to memory. The value initially
loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDCLRAH` and `LDCLRALH` load from memory with acquire semantics.
  * `LDCLRLH` and `LDCLRALH` store to memory with release semantics.
  * `LDCLRH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRH--LDCLRAH--LDCLRALH--LDCLRLH--Atomic-bit-clear-on-halfword-in-memory-"
    )
    this["ldclrp"] = OpCodeDoc(
        "LDCLRP",
        """Atomic bit clear on quadword in memory atomically loads a 128-bit quadword
from memory, performs a bitwise AND with the complement of the value held in a
pair of registers on it, and stores the result back to memory. The value
initially loaded from memory is returned in the same pair of registers.

  * `LDCLRPA` and `LDCLRPAL` load from memory with acquire semantics.
  * `LDCLRPL` and `LDCLRPAL` store to memory with release semantics.
  * `LDCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRP--LDCLRPA--LDCLRPAL--LDCLRPL--Atomic-bit-clear-on-quadword-in-memory-"
    )
    this["ldclrpa"] = OpCodeDoc(
        "LDCLRPA",
        """Atomic bit clear on quadword in memory atomically loads a 128-bit quadword
from memory, performs a bitwise AND with the complement of the value held in a
pair of registers on it, and stores the result back to memory. The value
initially loaded from memory is returned in the same pair of registers.

  * `LDCLRPA` and `LDCLRPAL` load from memory with acquire semantics.
  * `LDCLRPL` and `LDCLRPAL` store to memory with release semantics.
  * `LDCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRP--LDCLRPA--LDCLRPAL--LDCLRPL--Atomic-bit-clear-on-quadword-in-memory-"
    )
    this["ldclrpal"] = OpCodeDoc(
        "LDCLRPAL",
        """Atomic bit clear on quadword in memory atomically loads a 128-bit quadword
from memory, performs a bitwise AND with the complement of the value held in a
pair of registers on it, and stores the result back to memory. The value
initially loaded from memory is returned in the same pair of registers.

  * `LDCLRPA` and `LDCLRPAL` load from memory with acquire semantics.
  * `LDCLRPL` and `LDCLRPAL` store to memory with release semantics.
  * `LDCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRP--LDCLRPA--LDCLRPAL--LDCLRPL--Atomic-bit-clear-on-quadword-in-memory-"
    )
    this["ldclrpl"] = OpCodeDoc(
        "LDCLRPL",
        """Atomic bit clear on quadword in memory atomically loads a 128-bit quadword
from memory, performs a bitwise AND with the complement of the value held in a
pair of registers on it, and stores the result back to memory. The value
initially loaded from memory is returned in the same pair of registers.

  * `LDCLRPA` and `LDCLRPAL` load from memory with acquire semantics.
  * `LDCLRPL` and `LDCLRPAL` store to memory with release semantics.
  * `LDCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDCLRP--LDCLRPA--LDCLRPAL--LDCLRPL--Atomic-bit-clear-on-quadword-in-memory-"
    )
    this["ldeor"] = OpCodeDoc(
        "LDEOR",
        """Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit
word or 64-bit doubleword from memory, performs an exclusive-OR with the value
held in a register on it, and stores the result back to memory. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDEORA` and `LDEORAL` load from memory with acquire semantics.
  * `LDEORL` and `LDEORAL` store to memory with release semantics.
  * `LDEOR` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEOR--LDEORA--LDEORAL--LDEORL--Atomic-exclusive-or-on-word-or-doubleword-in-memory-"
    )
    this["ldeora"] = OpCodeDoc(
        "LDEORA",
        """Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit
word or 64-bit doubleword from memory, performs an exclusive-OR with the value
held in a register on it, and stores the result back to memory. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDEORA` and `LDEORAL` load from memory with acquire semantics.
  * `LDEORL` and `LDEORAL` store to memory with release semantics.
  * `LDEOR` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEOR--LDEORA--LDEORAL--LDEORL--Atomic-exclusive-or-on-word-or-doubleword-in-memory-"
    )
    this["ldeoral"] = OpCodeDoc(
        "LDEORAL",
        """Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit
word or 64-bit doubleword from memory, performs an exclusive-OR with the value
held in a register on it, and stores the result back to memory. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDEORA` and `LDEORAL` load from memory with acquire semantics.
  * `LDEORL` and `LDEORAL` store to memory with release semantics.
  * `LDEOR` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEOR--LDEORA--LDEORAL--LDEORL--Atomic-exclusive-or-on-word-or-doubleword-in-memory-"
    )
    this["ldeorl"] = OpCodeDoc(
        "LDEORL",
        """Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit
word or 64-bit doubleword from memory, performs an exclusive-OR with the value
held in a register on it, and stores the result back to memory. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDEORA` and `LDEORAL` load from memory with acquire semantics.
  * `LDEORL` and `LDEORAL` store to memory with release semantics.
  * `LDEOR` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEOR--LDEORA--LDEORAL--LDEORL--Atomic-exclusive-or-on-word-or-doubleword-in-memory-"
    )
    this["ldeorab"] = OpCodeDoc(
        "LDEORAB",
        """Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from
memory, performs an exclusive-OR with the value held in a register on it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not `WZR`, `LDEORAB` and `LDEORALB` load from memory with acquire semantics.
  * `LDEORLB` and `LDEORALB` store to memory with release semantics.
  * `LDEORB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEORB--LDEORAB--LDEORALB--LDEORLB--Atomic-exclusive-or-on-byte-in-memory-"
    )
    this["ldeoralb"] = OpCodeDoc(
        "LDEORALB",
        """Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from
memory, performs an exclusive-OR with the value held in a register on it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not `WZR`, `LDEORAB` and `LDEORALB` load from memory with acquire semantics.
  * `LDEORLB` and `LDEORALB` store to memory with release semantics.
  * `LDEORB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEORB--LDEORAB--LDEORALB--LDEORLB--Atomic-exclusive-or-on-byte-in-memory-"
    )
    this["ldeorb"] = OpCodeDoc(
        "LDEORB",
        """Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from
memory, performs an exclusive-OR with the value held in a register on it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not `WZR`, `LDEORAB` and `LDEORALB` load from memory with acquire semantics.
  * `LDEORLB` and `LDEORALB` store to memory with release semantics.
  * `LDEORB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEORB--LDEORAB--LDEORALB--LDEORLB--Atomic-exclusive-or-on-byte-in-memory-"
    )
    this["ldeorlb"] = OpCodeDoc(
        "LDEORLB",
        """Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from
memory, performs an exclusive-OR with the value held in a register on it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not `WZR`, `LDEORAB` and `LDEORALB` load from memory with acquire semantics.
  * `LDEORLB` and `LDEORALB` store to memory with release semantics.
  * `LDEORB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEORB--LDEORAB--LDEORALB--LDEORLB--Atomic-exclusive-or-on-byte-in-memory-"
    )
    this["ldeorah"] = OpCodeDoc(
        "LDEORAH",
        """Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword
from memory, performs an exclusive-OR with the value held in a register on it,
and stores the result back to memory. The value initially loaded from memory
is returned in the destination register.

  * If the destination register is not `WZR`, `LDEORAH` and `LDEORALH` load from memory with acquire semantics.
  * `LDEORLH` and `LDEORALH` store to memory with release semantics.
  * `LDEORH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEORH--LDEORAH--LDEORALH--LDEORLH--Atomic-exclusive-or-on-halfword-in-memory-"
    )
    this["ldeoralh"] = OpCodeDoc(
        "LDEORALH",
        """Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword
from memory, performs an exclusive-OR with the value held in a register on it,
and stores the result back to memory. The value initially loaded from memory
is returned in the destination register.

  * If the destination register is not `WZR`, `LDEORAH` and `LDEORALH` load from memory with acquire semantics.
  * `LDEORLH` and `LDEORALH` store to memory with release semantics.
  * `LDEORH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEORH--LDEORAH--LDEORALH--LDEORLH--Atomic-exclusive-or-on-halfword-in-memory-"
    )
    this["ldeorh"] = OpCodeDoc(
        "LDEORH",
        """Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword
from memory, performs an exclusive-OR with the value held in a register on it,
and stores the result back to memory. The value initially loaded from memory
is returned in the destination register.

  * If the destination register is not `WZR`, `LDEORAH` and `LDEORALH` load from memory with acquire semantics.
  * `LDEORLH` and `LDEORALH` store to memory with release semantics.
  * `LDEORH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEORH--LDEORAH--LDEORALH--LDEORLH--Atomic-exclusive-or-on-halfword-in-memory-"
    )
    this["ldeorlh"] = OpCodeDoc(
        "LDEORLH",
        """Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword
from memory, performs an exclusive-OR with the value held in a register on it,
and stores the result back to memory. The value initially loaded from memory
is returned in the destination register.

  * If the destination register is not `WZR`, `LDEORAH` and `LDEORALH` load from memory with acquire semantics.
  * `LDEORLH` and `LDEORALH` store to memory with release semantics.
  * `LDEORH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDEORH--LDEORAH--LDEORALH--LDEORLH--Atomic-exclusive-or-on-halfword-in-memory-"
    )
    this["ldff1b"] = OpCodeDoc(
        "LDFF1B",
        """Gather load with first-faulting behavior of unsigned bytes to active elements
of a vector register from memory addresses generated by a vector base plus
immediate index. The index is in the range 0 to 31. Inactive elements will not
cause a read from Device memory or signal faults, and are set to zero in the
destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDFF-B--vector-plus-immediate----"
    )
    this["ldff1d"] = OpCodeDoc(
        "LDFF1D",
        """Gather load with first-faulting behavior of doublewords to active elements of
a vector register from memory addresses generated by a vector base plus
immediate index. The index is a multiple of 8 in the range 0 to 248. Inactive
elements will not cause a read from Device memory or signal faults, and are
set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDFF-D--vector-plus-immediate----"
    )
    this["ldff1h"] = OpCodeDoc(
        "LDFF1H",
        """Gather load with first-faulting behavior of unsigned halfwords to active
elements of a vector register from memory addresses generated by a vector base
plus immediate index. The index is a multiple of 2 in the range 0 to 62.
Inactive elements will not cause a read from Device memory or signal faults,
and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDFF-H--vector-plus-immediate----"
    )
    this["ldff1sb"] = OpCodeDoc(
        "LDFF1SB",
        """Gather load with first-faulting behavior of signed bytes to active elements of
a vector register from memory addresses generated by a vector base plus
immediate index. The index is in the range 0 to 31. Inactive elements will not
cause a read from Device memory or signal faults, and are set to zero in the
destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDFF-SB--vector-plus-immediate----"
    )
    this["ldff1sh"] = OpCodeDoc(
        "LDFF1SH",
        """Gather load with first-faulting behavior of signed halfwords to active
elements of a vector register from memory addresses generated by a vector base
plus immediate index. The index is a multiple of 2 in the range 0 to 62.
Inactive elements will not cause a read from Device memory or signal faults,
and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDFF-SH--vector-plus-immediate----"
    )
    this["ldff1sw"] = OpCodeDoc(
        "LDFF1SW",
        """Gather load with first-faulting behavior of signed words to active elements of
a vector register from memory addresses generated by a vector base plus
immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive
elements will not cause a read from Device memory or signal faults, and are
set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDFF-SW--vector-plus-immediate----"
    )
    this["ldff1w"] = OpCodeDoc(
        "LDFF1W",
        """Gather load with first-faulting behavior of unsigned words to active elements
of a vector register from memory addresses generated by a vector base plus
immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive
elements will not cause a read from Device memory or signal faults, and are
set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDFF-W--vector-plus-immediate----"
    )
    this["ldg"] = OpCodeDoc(
        "LDG",
        """Load Allocation Tag loads an Allocation Tag from a memory address, generates a
Logical Address Tag from the Allocation Tag and merges it into the destination
register. The address used for the load is calculated from the base register
and an immediate signed offset scaled by the Tag granule.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDG--Load-allocation-tag-"
    )
    this["ldgm"] = OpCodeDoc(
        "LDGM",
        """Load Tag Multiple reads a naturally aligned block of N Allocation Tags, where
the size of N is identified in GMID_EL1.BS, and writes the Allocation Tag read
from address A to the destination register at 4*A<7:4>+3:4*A<7:4>. Bits of the
destination register not written with an Allocation Tag are set to 0.

This instruction is undefined at EL0.

This instruction generates an Unchecked access.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDGM--Load-tag-multiple-"
    )
    this["ldiapp"] = OpCodeDoc(
        "LDIAPP",
        """Load-Acquire RCpc ordered Pair of registers calculates an address from a base
register value and an optional offset, loads two 32-bit words or two 64-bit
doublewords from memory, and writes them to two registers. For information on
single-copy atomicity and alignment requirements, see Requirements for single-
copy atomicity and Alignment of data accesses. The instruction also has memory
ordering semantics, as described in Load-Acquire, Load-AcquirePC, and Store-
Release, except that:

  * The Memory effects associated with Xt1/Wt1 are Ordered-before the Memory effects associated with Xt2/Wt2.
  * There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.
  * The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDIAPP--Load-acquire-rcpc-ordered-pair-of-registers-"
    )
    this["ldlar"] = OpCodeDoc(
        "LDLAR",
        """Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory,
and writes it to a register. The instruction also has memory ordering
semantics as described in Load LOAcquire, Store LORelease. For information
about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDLAR--Load-loacquire-register-"
    )
    this["ldlarb"] = OpCodeDoc(
        "LDLARB",
        """Load LOAcquire Register Byte loads a byte from memory, zero-extends it and
writes it to a register. The instruction also has memory ordering semantics as
described in Load LOAcquire, Store LORelease. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDLARB--Load-loacquire-register-byte-"
    )
    this["ldlarh"] = OpCodeDoc(
        "LDLARH",
        """Load LOAcquire Register Halfword loads a halfword from memory, zero-extends
it, and writes it to a register. The instruction also has memory ordering
semantics as described in Load LOAcquire, Store LORelease. For information
about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDLARH--Load-loacquire-register-halfword-"
    )
    this["ldnf1b"] = OpCodeDoc(
        "LDNF1B",
        """Contiguous load with non-faulting behavior of unsigned bytes to elements of a
vector register from the memory address generated by a 64-bit scalar base and
immediate index in the range -8 to 7 which is multiplied by the vector's in-
memory size, irrespective of predication, and added to the base address.
Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNF-B---"
    )
    this["ldnf1d"] = OpCodeDoc(
        "LDNF1D",
        """Contiguous load with non-faulting behavior of doublewords to elements of a
vector register from the memory address generated by a 64-bit scalar base and
immediate index in the range -8 to 7 which is multiplied by the vector's in-
memory size, irrespective of predication, and added to the base address.
Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNF-D---"
    )
    this["ldnf1h"] = OpCodeDoc(
        "LDNF1H",
        """Contiguous load with non-faulting behavior of unsigned halfwords to elements
of a vector register from the memory address generated by a 64-bit scalar base
and immediate index in the range -8 to 7 which is multiplied by the vector's
in-memory size, irrespective of predication, and added to the base address.
Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNF-H---"
    )
    this["ldnf1sb"] = OpCodeDoc(
        "LDNF1SB",
        """Contiguous load with non-faulting behavior of signed bytes to elements of a
vector register from the memory address generated by a 64-bit scalar base and
immediate index in the range -8 to 7 which is multiplied by the vector's in-
memory size, irrespective of predication, and added to the base address.
Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNF-SB---"
    )
    this["ldnf1sh"] = OpCodeDoc(
        "LDNF1SH",
        """Contiguous load with non-faulting behavior of signed halfwords to elements of
a vector register from the memory address generated by a 64-bit scalar base
and immediate index in the range -8 to 7 which is multiplied by the vector's
in-memory size, irrespective of predication, and added to the base address.
Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNF-SH---"
    )
    this["ldnf1sw"] = OpCodeDoc(
        "LDNF1SW",
        """Contiguous load with non-faulting behavior of signed words to elements of a
vector register from the memory address generated by a 64-bit scalar base and
immediate index in the range -8 to 7 which is multiplied by the vector's in-
memory size, irrespective of predication, and added to the base address.
Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNF-SW---"
    )
    this["ldnf1w"] = OpCodeDoc(
        "LDNF1W",
        """Contiguous load with non-faulting behavior of unsigned words to elements of a
vector register from the memory address generated by a 64-bit scalar base and
immediate index in the range -8 to 7 which is multiplied by the vector's in-
memory size, irrespective of predication, and added to the base address.
Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNF-W---"
    )
    this["ldnp"] = OpCodeDoc(
        "LDNP",
        """Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads
a pair of SIMD&FP registers from memory, issuing a hint to the memory system
that the access is non-temporal. The address that is used for the load is
calculated from a base register value and an optional immediate offset.

For information about non-temporal pair instructions, see Load/Store SIMD and
Floating-point Non-temporal pair.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNP--SIMD-FP---Load-pair-of-simd-fp-registers--with-non-temporal-hint-"
    )
    this["ldnt1b"] = OpCodeDoc(
        "LDNT1B",
        """Contiguous load non-temporal of bytes to elements of two or four consecutive
vector registers from the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

A non-temporal load is a hint to the system that this data is unlikely to be
referenced again soon.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNT-B--scalar-plus-immediate--consecutive-registers----"
    )
    this["ldnt1d"] = OpCodeDoc(
        "LDNT1D",
        """Contiguous load non-temporal of doublewords to elements of two or four
consecutive vector registers from the memory address generated by a 64-bit
scalar base and immediate index which is multiplied by the vector's in-memory
size, irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

A non-temporal load is a hint to the system that this data is unlikely to be
referenced again soon.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNT-D--scalar-plus-immediate--consecutive-registers----"
    )
    this["ldnt1h"] = OpCodeDoc(
        "LDNT1H",
        """Contiguous load non-temporal of halfwords to elements of two or four
consecutive vector registers from the memory address generated by a 64-bit
scalar base and immediate index which is multiplied by the vector's in-memory
size, irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

A non-temporal load is a hint to the system that this data is unlikely to be
referenced again soon.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNT-H--scalar-plus-immediate--consecutive-registers----"
    )
    this["ldnt1sb"] = OpCodeDoc(
        "LDNT1SB",
        """Gather load non-temporal of signed bytes to active elements of a vector
register from memory addresses generated by a vector base plus a 64-bit
unscaled scalar register offset. Inactive elements will not cause a read from
Device memory or signal faults, and are set to zero in the destination vector.

A non-temporal load is a hint to the system that this data is unlikely to be
referenced again soon.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNT-SB---"
    )
    this["ldnt1sh"] = OpCodeDoc(
        "LDNT1SH",
        """Gather load non-temporal of signed halfwords to active elements of a vector
register from memory addresses generated by a vector base plus a 64-bit
unscaled scalar register offset. Inactive elements will not cause a read from
Device memory or signal faults, and are set to zero in the destination vector.

A non-temporal load is a hint to the system that this data is unlikely to be
referenced again soon.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNT-SH---"
    )
    this["ldnt1sw"] = OpCodeDoc(
        "LDNT1SW",
        """Gather load non-temporal of signed words to active elements of a vector
register from memory addresses generated by a vector base plus a 64-bit
unscaled scalar register offset. Inactive elements will not cause a read from
Device memory or signal faults, and are set to zero in the destination vector.

A non-temporal load is a hint to the system that this data is unlikely to be
referenced again soon.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNT-SW---"
    )
    this["ldnt1w"] = OpCodeDoc(
        "LDNT1W",
        """Contiguous load non-temporal of words to elements of two or four consecutive
vector registers from the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault,
and are set to zero in the destination vector.

A non-temporal load is a hint to the system that this data is unlikely to be
referenced again soon.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDNT-W--scalar-plus-immediate--consecutive-registers----"
    )
    this["ldp"] = OpCodeDoc(
        "LDP",
        """Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP
registers from memory. The address that is used for the load is calculated
from a base register value and an optional immediate offset.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDP--SIMD-FP---Load-pair-of-simd-fp-registers-"
    )
    this["ldpsw"] = OpCodeDoc(
        "LDPSW",
        """Load Pair of Registers Signed Word calculates an address from a base register
value and an immediate offset, loads two 32-bit words from memory, sign-
extends them, and writes them to two registers. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDPSW--Load-pair-of-registers-signed-word-"
    )
    this["ldr"] = OpCodeDoc(
        "LDR",
        """Load SIMD&FP Register (immediate offset). This instruction loads an element
from memory, and writes the result as a scalar to the SIMD&FP register. The
address that is used for the load is calculated from a base register value, a
signed immediate offset, and an optional offset that is a multiple of the
element size.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDR--immediate--SIMD-FP---Load-simd-fp-register--immediate-offset--"
    )
    this["ldr"] = OpCodeDoc(
        "LDR",
        """Load Register (immediate) loads a word or doubleword from memory and writes it
to a register. The address that is used for the load is calculated from a base
register and an immediate offset. For information about memory accesses, see
Load/Store addressing modes. The Unsigned offset variant scales the immediate
offset value by the size of the value accessed before adding it to the base
register value.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDR--immediate---Load-register--immediate--"
    )
    this["ldr"] = OpCodeDoc(
        "LDR",
        """Load Register (register) calculates an address from a base register value and
an offset register value, loads a word from memory, and writes it to a
register. The offset register value can optionally be shifted and extended.
For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDR--register---Load-register--register--"
    )
    this["ldraa"] = OpCodeDoc(
        "LDRAA",
        """Load Register, with pointer authentication. This instruction authenticates an
address from a base register using a modifier of zero and the specified key,
adds an immediate offset to the authenticated address, and loads a 64-bit
doubleword from memory at this resulting address into a register.

Key A is used for `LDRAA`. Key B is used for `LDRAB`.

If the authentication passes, the PE behaves the same as for an `LDR`
instruction. For information on behavior if the authentication fails, see
Faulting on pointer authentication.

The authenticated address is not written back to the base register, unless the
pre-indexed variant of the instruction is used. In this case, the address that
is written back to the base register does not include the pointer
authentication code.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRAA--LDRAB--Load-register--with-pointer-authentication-"
    )
    this["ldrab"] = OpCodeDoc(
        "LDRAB",
        """Load Register, with pointer authentication. This instruction authenticates an
address from a base register using a modifier of zero and the specified key,
adds an immediate offset to the authenticated address, and loads a 64-bit
doubleword from memory at this resulting address into a register.

Key A is used for `LDRAA`. Key B is used for `LDRAB`.

If the authentication passes, the PE behaves the same as for an `LDR`
instruction. For information on behavior if the authentication fails, see
Faulting on pointer authentication.

The authenticated address is not written back to the base register, unless the
pre-indexed variant of the instruction is used. In this case, the address that
is written back to the base register does not include the pointer
authentication code.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRAA--LDRAB--Load-register--with-pointer-authentication-"
    )
    this["ldrb"] = OpCodeDoc(
        "LDRB",
        """Load Register Byte (immediate) loads a byte from memory, zero-extends it, and
writes the result to a register. The address that is used for the load is
calculated from a base register and an immediate offset. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRB--immediate---Load-register-byte--immediate--"
    )
    this["ldrb"] = OpCodeDoc(
        "LDRB",
        """Load Register Byte (register) calculates an address from a base register value
and an offset register value, loads a byte from memory, zero-extends it, and
writes it to a register. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRB--register---Load-register-byte--register--"
    )
    this["ldrh"] = OpCodeDoc(
        "LDRH",
        """Load Register Halfword (immediate) loads a halfword from memory, zero-extends
it, and writes the result to a register. The address that is used for the load
is calculated from a base register and an immediate offset. For information
about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRH--immediate---Load-register-halfword--immediate--"
    )
    this["ldrh"] = OpCodeDoc(
        "LDRH",
        """Load Register Halfword (register) calculates an address from a base register
value and an offset register value, loads a halfword from memory, zero-extends
it, and writes it to a register. For information about memory accesses, see
Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRH--register---Load-register-halfword--register--"
    )
    this["ldrsb"] = OpCodeDoc(
        "LDRSB",
        """Load Register Signed Byte (immediate) loads a byte from memory, sign-extends
it to either 32 bits or 64 bits, and writes the result to a register. The
address that is used for the load is calculated from a base register and an
immediate offset. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRSB--immediate---Load-register-signed-byte--immediate--"
    )
    this["ldrsb"] = OpCodeDoc(
        "LDRSB",
        """Load Register Signed Byte (register) calculates an address from a base
register value and an offset register value, loads a byte from memory, sign-
extends it, and writes it to a register. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRSB--register---Load-register-signed-byte--register--"
    )
    this["ldrsh"] = OpCodeDoc(
        "LDRSH",
        """Load Register Signed Halfword (immediate) loads a halfword from memory, sign-
extends it to 32 bits or 64 bits, and writes the result to a register. The
address that is used for the load is calculated from a base register and an
immediate offset. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRSH--immediate---Load-register-signed-halfword--immediate--"
    )
    this["ldrsh"] = OpCodeDoc(
        "LDRSH",
        """Load Register Signed Halfword (register) calculates an address from a base
register value and an offset register value, loads a halfword from memory,
sign-extends it, and writes it to a register. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRSH--register---Load-register-signed-halfword--register--"
    )
    this["ldrsw"] = OpCodeDoc(
        "LDRSW",
        """Load Register Signed Word (immediate) loads a word from memory, sign-extends
it to 64 bits, and writes the result to a register. The address that is used
for the load is calculated from a base register and an immediate offset. For
information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRSW--immediate---Load-register-signed-word--immediate--"
    )
    this["ldrsw"] = OpCodeDoc(
        "LDRSW",
        """Load Register Signed Word (register) calculates an address from a base
register value and an offset register value, loads a word from memory, sign-
extends it to form a 64-bit value, and writes it to a register. The offset
register value can be shifted left by 0 or 2 bits. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDRSW--register---Load-register-signed-word--register--"
    )
    this["ldset"] = OpCodeDoc(
        "LDSET",
        """Atomic bit set on word or doubleword in memory atomically loads a 32-bit word
or 64-bit doubleword from memory, performs a bitwise OR with the value held in
a register on it, and stores the result back to memory. The value initially
loaded from memory is returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSETA` and `LDSETAL` load from memory with acquire semantics.
  * `LDSETL` and `LDSETAL` store to memory with release semantics.
  * `LDSET` has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Store-
Release.

For information about memory accesses see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSET--LDSETA--LDSETAL--LDSETL--Atomic-bit-set-on-word-or-doubleword-in-memory-"
    )
    this["ldseta"] = OpCodeDoc(
        "LDSETA",
        """Atomic bit set on word or doubleword in memory atomically loads a 32-bit word
or 64-bit doubleword from memory, performs a bitwise OR with the value held in
a register on it, and stores the result back to memory. The value initially
loaded from memory is returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSETA` and `LDSETAL` load from memory with acquire semantics.
  * `LDSETL` and `LDSETAL` store to memory with release semantics.
  * `LDSET` has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Store-
Release.

For information about memory accesses see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSET--LDSETA--LDSETAL--LDSETL--Atomic-bit-set-on-word-or-doubleword-in-memory-"
    )
    this["ldsetal"] = OpCodeDoc(
        "LDSETAL",
        """Atomic bit set on word or doubleword in memory atomically loads a 32-bit word
or 64-bit doubleword from memory, performs a bitwise OR with the value held in
a register on it, and stores the result back to memory. The value initially
loaded from memory is returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSETA` and `LDSETAL` load from memory with acquire semantics.
  * `LDSETL` and `LDSETAL` store to memory with release semantics.
  * `LDSET` has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Store-
Release.

For information about memory accesses see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSET--LDSETA--LDSETAL--LDSETL--Atomic-bit-set-on-word-or-doubleword-in-memory-"
    )
    this["ldsetl"] = OpCodeDoc(
        "LDSETL",
        """Atomic bit set on word or doubleword in memory atomically loads a 32-bit word
or 64-bit doubleword from memory, performs a bitwise OR with the value held in
a register on it, and stores the result back to memory. The value initially
loaded from memory is returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSETA` and `LDSETAL` load from memory with acquire semantics.
  * `LDSETL` and `LDSETAL` store to memory with release semantics.
  * `LDSET` has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Store-
Release.

For information about memory accesses see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSET--LDSETA--LDSETAL--LDSETL--Atomic-bit-set-on-word-or-doubleword-in-memory-"
    )
    this["ldsetab"] = OpCodeDoc(
        "LDSETAB",
        """Atomic bit set on byte in memory atomically loads an 8-bit byte from memory,
performs a bitwise OR with the value held in a register on it, and stores the
result back to memory. The value initially loaded from memory is returned in
the destination register.

  * If the destination register is not `WZR`, `LDSETAB` and `LDSETALB` load from memory with acquire semantics.
  * `LDSETLB` and `LDSETALB` store to memory with release semantics.
  * `LDSETB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETB--LDSETAB--LDSETALB--LDSETLB--Atomic-bit-set-on-byte-in-memory-"
    )
    this["ldsetalb"] = OpCodeDoc(
        "LDSETALB",
        """Atomic bit set on byte in memory atomically loads an 8-bit byte from memory,
performs a bitwise OR with the value held in a register on it, and stores the
result back to memory. The value initially loaded from memory is returned in
the destination register.

  * If the destination register is not `WZR`, `LDSETAB` and `LDSETALB` load from memory with acquire semantics.
  * `LDSETLB` and `LDSETALB` store to memory with release semantics.
  * `LDSETB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETB--LDSETAB--LDSETALB--LDSETLB--Atomic-bit-set-on-byte-in-memory-"
    )
    this["ldsetb"] = OpCodeDoc(
        "LDSETB",
        """Atomic bit set on byte in memory atomically loads an 8-bit byte from memory,
performs a bitwise OR with the value held in a register on it, and stores the
result back to memory. The value initially loaded from memory is returned in
the destination register.

  * If the destination register is not `WZR`, `LDSETAB` and `LDSETALB` load from memory with acquire semantics.
  * `LDSETLB` and `LDSETALB` store to memory with release semantics.
  * `LDSETB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETB--LDSETAB--LDSETALB--LDSETLB--Atomic-bit-set-on-byte-in-memory-"
    )
    this["ldsetlb"] = OpCodeDoc(
        "LDSETLB",
        """Atomic bit set on byte in memory atomically loads an 8-bit byte from memory,
performs a bitwise OR with the value held in a register on it, and stores the
result back to memory. The value initially loaded from memory is returned in
the destination register.

  * If the destination register is not `WZR`, `LDSETAB` and `LDSETALB` load from memory with acquire semantics.
  * `LDSETLB` and `LDSETALB` store to memory with release semantics.
  * `LDSETB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETB--LDSETAB--LDSETALB--LDSETLB--Atomic-bit-set-on-byte-in-memory-"
    )
    this["ldsetah"] = OpCodeDoc(
        "LDSETAH",
        """Atomic bit set on halfword in memory atomically loads a 16-bit halfword from
memory, performs a bitwise OR with the value held in a register on it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not `WZR`, `LDSETAH` and `LDSETALH` load from memory with acquire semantics.
  * `LDSETLH` and `LDSETALH` store to memory with release semantics.
  * `LDSETH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETH--LDSETAH--LDSETALH--LDSETLH--Atomic-bit-set-on-halfword-in-memory-"
    )
    this["ldsetalh"] = OpCodeDoc(
        "LDSETALH",
        """Atomic bit set on halfword in memory atomically loads a 16-bit halfword from
memory, performs a bitwise OR with the value held in a register on it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not `WZR`, `LDSETAH` and `LDSETALH` load from memory with acquire semantics.
  * `LDSETLH` and `LDSETALH` store to memory with release semantics.
  * `LDSETH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETH--LDSETAH--LDSETALH--LDSETLH--Atomic-bit-set-on-halfword-in-memory-"
    )
    this["ldseth"] = OpCodeDoc(
        "LDSETH",
        """Atomic bit set on halfword in memory atomically loads a 16-bit halfword from
memory, performs a bitwise OR with the value held in a register on it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not `WZR`, `LDSETAH` and `LDSETALH` load from memory with acquire semantics.
  * `LDSETLH` and `LDSETALH` store to memory with release semantics.
  * `LDSETH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETH--LDSETAH--LDSETALH--LDSETLH--Atomic-bit-set-on-halfword-in-memory-"
    )
    this["ldsetlh"] = OpCodeDoc(
        "LDSETLH",
        """Atomic bit set on halfword in memory atomically loads a 16-bit halfword from
memory, performs a bitwise OR with the value held in a register on it, and
stores the result back to memory. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not `WZR`, `LDSETAH` and `LDSETALH` load from memory with acquire semantics.
  * `LDSETLH` and `LDSETALH` store to memory with release semantics.
  * `LDSETH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETH--LDSETAH--LDSETALH--LDSETLH--Atomic-bit-set-on-halfword-in-memory-"
    )
    this["ldsetp"] = OpCodeDoc(
        "LDSETP",
        """Atomic bit set on quadword in memory atomically loads a 128-bit quadword from
memory, performs a bitwise OR with the value held in a pair of registers on
it, and stores the result back to memory. The value initially loaded from
memory is returned in the same pair of registers.

  * `LDSETPA` and `LDSETPAL` load from memory with acquire semantics.
  * `LDSETPL` and `LDSETPAL` store to memory with release semantics.
  * `LDSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETP--LDSETPA--LDSETPAL--LDSETPL--Atomic-bit-set-on-quadword-in-memory-"
    )
    this["ldsetpa"] = OpCodeDoc(
        "LDSETPA",
        """Atomic bit set on quadword in memory atomically loads a 128-bit quadword from
memory, performs a bitwise OR with the value held in a pair of registers on
it, and stores the result back to memory. The value initially loaded from
memory is returned in the same pair of registers.

  * `LDSETPA` and `LDSETPAL` load from memory with acquire semantics.
  * `LDSETPL` and `LDSETPAL` store to memory with release semantics.
  * `LDSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETP--LDSETPA--LDSETPAL--LDSETPL--Atomic-bit-set-on-quadword-in-memory-"
    )
    this["ldsetpal"] = OpCodeDoc(
        "LDSETPAL",
        """Atomic bit set on quadword in memory atomically loads a 128-bit quadword from
memory, performs a bitwise OR with the value held in a pair of registers on
it, and stores the result back to memory. The value initially loaded from
memory is returned in the same pair of registers.

  * `LDSETPA` and `LDSETPAL` load from memory with acquire semantics.
  * `LDSETPL` and `LDSETPAL` store to memory with release semantics.
  * `LDSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETP--LDSETPA--LDSETPAL--LDSETPL--Atomic-bit-set-on-quadword-in-memory-"
    )
    this["ldsetpl"] = OpCodeDoc(
        "LDSETPL",
        """Atomic bit set on quadword in memory atomically loads a 128-bit quadword from
memory, performs a bitwise OR with the value held in a pair of registers on
it, and stores the result back to memory. The value initially loaded from
memory is returned in the same pair of registers.

  * `LDSETPA` and `LDSETPAL` load from memory with acquire semantics.
  * `LDSETPL` and `LDSETPAL` store to memory with release semantics.
  * `LDSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSETP--LDSETPA--LDSETPAL--LDSETPL--Atomic-bit-set-on-quadword-in-memory-"
    )
    this["ldsmax"] = OpCodeDoc(
        "LDSMAX",
        """Atomic signed maximum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the larger value back to memory, treating the
values as signed numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSMAXA` and `LDSMAXAL` load from memory with acquire semantics.
  * `LDSMAXL` and `LDSMAXAL` store to memory with release semantics.
  * `LDSMAX` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAX--LDSMAXA--LDSMAXAL--LDSMAXL--Atomic-signed-maximum-on-word-or-doubleword-in-memory-"
    )
    this["ldsmaxa"] = OpCodeDoc(
        "LDSMAXA",
        """Atomic signed maximum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the larger value back to memory, treating the
values as signed numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSMAXA` and `LDSMAXAL` load from memory with acquire semantics.
  * `LDSMAXL` and `LDSMAXAL` store to memory with release semantics.
  * `LDSMAX` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAX--LDSMAXA--LDSMAXAL--LDSMAXL--Atomic-signed-maximum-on-word-or-doubleword-in-memory-"
    )
    this["ldsmaxal"] = OpCodeDoc(
        "LDSMAXAL",
        """Atomic signed maximum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the larger value back to memory, treating the
values as signed numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSMAXA` and `LDSMAXAL` load from memory with acquire semantics.
  * `LDSMAXL` and `LDSMAXAL` store to memory with release semantics.
  * `LDSMAX` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAX--LDSMAXA--LDSMAXAL--LDSMAXL--Atomic-signed-maximum-on-word-or-doubleword-in-memory-"
    )
    this["ldsmaxl"] = OpCodeDoc(
        "LDSMAXL",
        """Atomic signed maximum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the larger value back to memory, treating the
values as signed numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSMAXA` and `LDSMAXAL` load from memory with acquire semantics.
  * `LDSMAXL` and `LDSMAXAL` store to memory with release semantics.
  * `LDSMAX` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAX--LDSMAXA--LDSMAXAL--LDSMAXL--Atomic-signed-maximum-on-word-or-doubleword-in-memory-"
    )
    this["ldsmaxab"] = OpCodeDoc(
        "LDSMAXAB",
        """Atomic signed maximum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMAXAB` and `LDSMAXALB` load from memory with acquire semantics.
  * `LDSMAXLB` and `LDSMAXALB` store to memory with release semantics.
  * `LDSMAXB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAXB--LDSMAXAB--LDSMAXALB--LDSMAXLB--Atomic-signed-maximum-on-byte-in-memory-"
    )
    this["ldsmaxalb"] = OpCodeDoc(
        "LDSMAXALB",
        """Atomic signed maximum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMAXAB` and `LDSMAXALB` load from memory with acquire semantics.
  * `LDSMAXLB` and `LDSMAXALB` store to memory with release semantics.
  * `LDSMAXB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAXB--LDSMAXAB--LDSMAXALB--LDSMAXLB--Atomic-signed-maximum-on-byte-in-memory-"
    )
    this["ldsmaxb"] = OpCodeDoc(
        "LDSMAXB",
        """Atomic signed maximum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMAXAB` and `LDSMAXALB` load from memory with acquire semantics.
  * `LDSMAXLB` and `LDSMAXALB` store to memory with release semantics.
  * `LDSMAXB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAXB--LDSMAXAB--LDSMAXALB--LDSMAXLB--Atomic-signed-maximum-on-byte-in-memory-"
    )
    this["ldsmaxlb"] = OpCodeDoc(
        "LDSMAXLB",
        """Atomic signed maximum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMAXAB` and `LDSMAXALB` load from memory with acquire semantics.
  * `LDSMAXLB` and `LDSMAXALB` store to memory with release semantics.
  * `LDSMAXB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAXB--LDSMAXAB--LDSMAXALB--LDSMAXLB--Atomic-signed-maximum-on-byte-in-memory-"
    )
    this["ldsmaxah"] = OpCodeDoc(
        "LDSMAXAH",
        """Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword
from memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMAXAH` and `LDSMAXALH` load from memory with acquire semantics.
  * `LDSMAXLH` and `LDSMAXALH` store to memory with release semantics.
  * `LDSMAXH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAXH--LDSMAXAH--LDSMAXALH--LDSMAXLH--Atomic-signed-maximum-on-halfword-in-memory-"
    )
    this["ldsmaxalh"] = OpCodeDoc(
        "LDSMAXALH",
        """Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword
from memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMAXAH` and `LDSMAXALH` load from memory with acquire semantics.
  * `LDSMAXLH` and `LDSMAXALH` store to memory with release semantics.
  * `LDSMAXH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAXH--LDSMAXAH--LDSMAXALH--LDSMAXLH--Atomic-signed-maximum-on-halfword-in-memory-"
    )
    this["ldsmaxh"] = OpCodeDoc(
        "LDSMAXH",
        """Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword
from memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMAXAH` and `LDSMAXALH` load from memory with acquire semantics.
  * `LDSMAXLH` and `LDSMAXALH` store to memory with release semantics.
  * `LDSMAXH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAXH--LDSMAXAH--LDSMAXALH--LDSMAXLH--Atomic-signed-maximum-on-halfword-in-memory-"
    )
    this["ldsmaxlh"] = OpCodeDoc(
        "LDSMAXLH",
        """Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword
from memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMAXAH` and `LDSMAXALH` load from memory with acquire semantics.
  * `LDSMAXLH` and `LDSMAXALH` store to memory with release semantics.
  * `LDSMAXH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMAXH--LDSMAXAH--LDSMAXALH--LDSMAXLH--Atomic-signed-maximum-on-halfword-in-memory-"
    )
    this["ldsmin"] = OpCodeDoc(
        "LDSMIN",
        """Atomic signed minimum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the smaller value back to memory, treating the
values as signed numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSMINA` and `LDSMINAL` load from memory with acquire semantics.
  * `LDSMINL` and `LDSMINAL` store to memory with release semantics.
  * `LDSMIN` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMIN--LDSMINA--LDSMINAL--LDSMINL--Atomic-signed-minimum-on-word-or-doubleword-in-memory-"
    )
    this["ldsmina"] = OpCodeDoc(
        "LDSMINA",
        """Atomic signed minimum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the smaller value back to memory, treating the
values as signed numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSMINA` and `LDSMINAL` load from memory with acquire semantics.
  * `LDSMINL` and `LDSMINAL` store to memory with release semantics.
  * `LDSMIN` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMIN--LDSMINA--LDSMINAL--LDSMINL--Atomic-signed-minimum-on-word-or-doubleword-in-memory-"
    )
    this["ldsminal"] = OpCodeDoc(
        "LDSMINAL",
        """Atomic signed minimum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the smaller value back to memory, treating the
values as signed numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSMINA` and `LDSMINAL` load from memory with acquire semantics.
  * `LDSMINL` and `LDSMINAL` store to memory with release semantics.
  * `LDSMIN` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMIN--LDSMINA--LDSMINAL--LDSMINL--Atomic-signed-minimum-on-word-or-doubleword-in-memory-"
    )
    this["ldsminl"] = OpCodeDoc(
        "LDSMINL",
        """Atomic signed minimum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the smaller value back to memory, treating the
values as signed numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDSMINA` and `LDSMINAL` load from memory with acquire semantics.
  * `LDSMINL` and `LDSMINAL` store to memory with release semantics.
  * `LDSMIN` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMIN--LDSMINA--LDSMINAL--LDSMINL--Atomic-signed-minimum-on-word-or-doubleword-in-memory-"
    )
    this["ldsminab"] = OpCodeDoc(
        "LDSMINAB",
        """Atomic signed minimum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMINAB` and `LDSMINALB` load from memory with acquire semantics.
  * `LDSMINLB` and `LDSMINALB` store to memory with release semantics.
  * `LDSMINB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMINB--LDSMINAB--LDSMINALB--LDSMINLB--Atomic-signed-minimum-on-byte-in-memory-"
    )
    this["ldsminalb"] = OpCodeDoc(
        "LDSMINALB",
        """Atomic signed minimum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMINAB` and `LDSMINALB` load from memory with acquire semantics.
  * `LDSMINLB` and `LDSMINALB` store to memory with release semantics.
  * `LDSMINB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMINB--LDSMINAB--LDSMINALB--LDSMINLB--Atomic-signed-minimum-on-byte-in-memory-"
    )
    this["ldsminb"] = OpCodeDoc(
        "LDSMINB",
        """Atomic signed minimum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMINAB` and `LDSMINALB` load from memory with acquire semantics.
  * `LDSMINLB` and `LDSMINALB` store to memory with release semantics.
  * `LDSMINB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMINB--LDSMINAB--LDSMINALB--LDSMINLB--Atomic-signed-minimum-on-byte-in-memory-"
    )
    this["ldsminlb"] = OpCodeDoc(
        "LDSMINLB",
        """Atomic signed minimum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMINAB` and `LDSMINALB` load from memory with acquire semantics.
  * `LDSMINLB` and `LDSMINALB` store to memory with release semantics.
  * `LDSMINB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMINB--LDSMINAB--LDSMINALB--LDSMINLB--Atomic-signed-minimum-on-byte-in-memory-"
    )
    this["ldsminah"] = OpCodeDoc(
        "LDSMINAH",
        """Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword
from memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMINAH` and `LDSMINALH` load from memory with acquire semantics.
  * `LDSMINLH` and `LDSMINALH` store to memory with release semantics.
  * `LDSMINH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMINH--LDSMINAH--LDSMINALH--LDSMINLH--Atomic-signed-minimum-on-halfword-in-memory-"
    )
    this["ldsminalh"] = OpCodeDoc(
        "LDSMINALH",
        """Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword
from memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMINAH` and `LDSMINALH` load from memory with acquire semantics.
  * `LDSMINLH` and `LDSMINALH` store to memory with release semantics.
  * `LDSMINH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMINH--LDSMINAH--LDSMINALH--LDSMINLH--Atomic-signed-minimum-on-halfword-in-memory-"
    )
    this["ldsminh"] = OpCodeDoc(
        "LDSMINH",
        """Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword
from memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMINAH` and `LDSMINALH` load from memory with acquire semantics.
  * `LDSMINLH` and `LDSMINALH` store to memory with release semantics.
  * `LDSMINH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMINH--LDSMINAH--LDSMINALH--LDSMINLH--Atomic-signed-minimum-on-halfword-in-memory-"
    )
    this["ldsminlh"] = OpCodeDoc(
        "LDSMINLH",
        """Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword
from memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDSMINAH` and `LDSMINALH` load from memory with acquire semantics.
  * `LDSMINLH` and `LDSMINALH` store to memory with release semantics.
  * `LDSMINH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDSMINH--LDSMINAH--LDSMINALH--LDSMINLH--Atomic-signed-minimum-on-halfword-in-memory-"
    )
    this["ldtr"] = OpCodeDoc(
        "LDTR",
        """Load Register (unprivileged) loads a word or doubleword from memory, and
writes it to a register. The address that is used for the load is calculated
from a base register and an immediate offset.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDTR--Load-register--unprivileged--"
    )
    this["ldtrb"] = OpCodeDoc(
        "LDTRB",
        """Load Register Byte (unprivileged) loads a byte from memory, zero-extends it,
and writes the result to a register. The address that is used for the load is
calculated from a base register and an immediate offset.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDTRB--Load-register-byte--unprivileged--"
    )
    this["ldtrh"] = OpCodeDoc(
        "LDTRH",
        """Load Register Halfword (unprivileged) loads a halfword from memory, zero-
extends it, and writes the result to a register. The address that is used for
the load is calculated from a base register and an immediate offset.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDTRH--Load-register-halfword--unprivileged--"
    )
    this["ldtrsb"] = OpCodeDoc(
        "LDTRSB",
        """Load Register Signed Byte (unprivileged) loads a byte from memory, sign-
extends it to 32 bits or 64 bits, and writes the result to a register. The
address that is used for the load is calculated from a base register and an
immediate offset.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDTRSB--Load-register-signed-byte--unprivileged--"
    )
    this["ldtrsh"] = OpCodeDoc(
        "LDTRSH",
        """Load Register Signed Halfword (unprivileged) loads a halfword from memory,
sign-extends it to 32 bits or 64 bits, and writes the result to a register.
The address that is used for the load is calculated from a base register and
an immediate offset.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDTRSH--Load-register-signed-halfword--unprivileged--"
    )
    this["ldtrsw"] = OpCodeDoc(
        "LDTRSW",
        """Load Register Signed Word (unprivileged) loads a word from memory, sign-
extends it to 64 bits, and writes the result to a register. The address that
is used for the load is calculated from a base register and an immediate
offset.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDTRSW--Load-register-signed-word--unprivileged--"
    )
    this["ldumax"] = OpCodeDoc(
        "LDUMAX",
        """Atomic unsigned maximum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the larger value back to memory, treating the
values as unsigned numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDUMAXA` and `LDUMAXAL` load from memory with acquire semantics.
  * `LDUMAXL` and `LDUMAXAL` store to memory with release semantics.
  * `LDUMAX` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAX--LDUMAXA--LDUMAXAL--LDUMAXL--Atomic-unsigned-maximum-on-word-or-doubleword-in-memory-"
    )
    this["ldumaxa"] = OpCodeDoc(
        "LDUMAXA",
        """Atomic unsigned maximum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the larger value back to memory, treating the
values as unsigned numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDUMAXA` and `LDUMAXAL` load from memory with acquire semantics.
  * `LDUMAXL` and `LDUMAXAL` store to memory with release semantics.
  * `LDUMAX` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAX--LDUMAXA--LDUMAXAL--LDUMAXL--Atomic-unsigned-maximum-on-word-or-doubleword-in-memory-"
    )
    this["ldumaxal"] = OpCodeDoc(
        "LDUMAXAL",
        """Atomic unsigned maximum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the larger value back to memory, treating the
values as unsigned numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDUMAXA` and `LDUMAXAL` load from memory with acquire semantics.
  * `LDUMAXL` and `LDUMAXAL` store to memory with release semantics.
  * `LDUMAX` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAX--LDUMAXA--LDUMAXAL--LDUMAXL--Atomic-unsigned-maximum-on-word-or-doubleword-in-memory-"
    )
    this["ldumaxl"] = OpCodeDoc(
        "LDUMAXL",
        """Atomic unsigned maximum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the larger value back to memory, treating the
values as unsigned numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDUMAXA` and `LDUMAXAL` load from memory with acquire semantics.
  * `LDUMAXL` and `LDUMAXAL` store to memory with release semantics.
  * `LDUMAX` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAX--LDUMAXA--LDUMAXAL--LDUMAXL--Atomic-unsigned-maximum-on-word-or-doubleword-in-memory-"
    )
    this["ldumaxab"] = OpCodeDoc(
        "LDUMAXAB",
        """Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as unsigned numbers. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDUMAXAB` and `LDUMAXALB` load from memory with acquire semantics.
  * `LDUMAXLB` and `LDUMAXALB` store to memory with release semantics.
  * `LDUMAXB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAXB--LDUMAXAB--LDUMAXALB--LDUMAXLB--Atomic-unsigned-maximum-on-byte-in-memory-"
    )
    this["ldumaxalb"] = OpCodeDoc(
        "LDUMAXALB",
        """Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as unsigned numbers. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDUMAXAB` and `LDUMAXALB` load from memory with acquire semantics.
  * `LDUMAXLB` and `LDUMAXALB` store to memory with release semantics.
  * `LDUMAXB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAXB--LDUMAXAB--LDUMAXALB--LDUMAXLB--Atomic-unsigned-maximum-on-byte-in-memory-"
    )
    this["ldumaxb"] = OpCodeDoc(
        "LDUMAXB",
        """Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as unsigned numbers. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDUMAXAB` and `LDUMAXALB` load from memory with acquire semantics.
  * `LDUMAXLB` and `LDUMAXALB` store to memory with release semantics.
  * `LDUMAXB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAXB--LDUMAXAB--LDUMAXALB--LDUMAXLB--Atomic-unsigned-maximum-on-byte-in-memory-"
    )
    this["ldumaxlb"] = OpCodeDoc(
        "LDUMAXLB",
        """Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
larger value back to memory, treating the values as unsigned numbers. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDUMAXAB` and `LDUMAXALB` load from memory with acquire semantics.
  * `LDUMAXLB` and `LDUMAXALB` store to memory with release semantics.
  * `LDUMAXB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAXB--LDUMAXAB--LDUMAXALB--LDUMAXLB--Atomic-unsigned-maximum-on-byte-in-memory-"
    )
    this["ldumaxah"] = OpCodeDoc(
        "LDUMAXAH",
        """Atomic unsigned maximum on halfword in memory atomically loads a 16-bit
halfword from memory, compares it against the value held in a register, and
stores the larger value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDUMAXAH` and `LDUMAXALH` load from memory with acquire semantics.
  * `LDUMAXLH` and `LDUMAXALH` store to memory with release semantics.
  * `LDUMAXH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAXH--LDUMAXAH--LDUMAXALH--LDUMAXLH--Atomic-unsigned-maximum-on-halfword-in-memory-"
    )
    this["ldumaxalh"] = OpCodeDoc(
        "LDUMAXALH",
        """Atomic unsigned maximum on halfword in memory atomically loads a 16-bit
halfword from memory, compares it against the value held in a register, and
stores the larger value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDUMAXAH` and `LDUMAXALH` load from memory with acquire semantics.
  * `LDUMAXLH` and `LDUMAXALH` store to memory with release semantics.
  * `LDUMAXH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAXH--LDUMAXAH--LDUMAXALH--LDUMAXLH--Atomic-unsigned-maximum-on-halfword-in-memory-"
    )
    this["ldumaxh"] = OpCodeDoc(
        "LDUMAXH",
        """Atomic unsigned maximum on halfword in memory atomically loads a 16-bit
halfword from memory, compares it against the value held in a register, and
stores the larger value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDUMAXAH` and `LDUMAXALH` load from memory with acquire semantics.
  * `LDUMAXLH` and `LDUMAXALH` store to memory with release semantics.
  * `LDUMAXH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAXH--LDUMAXAH--LDUMAXALH--LDUMAXLH--Atomic-unsigned-maximum-on-halfword-in-memory-"
    )
    this["ldumaxlh"] = OpCodeDoc(
        "LDUMAXLH",
        """Atomic unsigned maximum on halfword in memory atomically loads a 16-bit
halfword from memory, compares it against the value held in a register, and
stores the larger value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDUMAXAH` and `LDUMAXALH` load from memory with acquire semantics.
  * `LDUMAXLH` and `LDUMAXALH` store to memory with release semantics.
  * `LDUMAXH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMAXH--LDUMAXAH--LDUMAXALH--LDUMAXLH--Atomic-unsigned-maximum-on-halfword-in-memory-"
    )
    this["ldumin"] = OpCodeDoc(
        "LDUMIN",
        """Atomic unsigned minimum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the smaller value back to memory, treating the
values as unsigned numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDUMINA` and `LDUMINAL` load from memory with acquire semantics.
  * `LDUMINL` and `LDUMINAL` store to memory with release semantics.
  * `LDUMIN` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMIN--LDUMINA--LDUMINAL--LDUMINL--Atomic-unsigned-minimum-on-word-or-doubleword-in-memory-"
    )
    this["ldumina"] = OpCodeDoc(
        "LDUMINA",
        """Atomic unsigned minimum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the smaller value back to memory, treating the
values as unsigned numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDUMINA` and `LDUMINAL` load from memory with acquire semantics.
  * `LDUMINL` and `LDUMINAL` store to memory with release semantics.
  * `LDUMIN` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMIN--LDUMINA--LDUMINAL--LDUMINL--Atomic-unsigned-minimum-on-word-or-doubleword-in-memory-"
    )
    this["lduminal"] = OpCodeDoc(
        "LDUMINAL",
        """Atomic unsigned minimum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the smaller value back to memory, treating the
values as unsigned numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDUMINA` and `LDUMINAL` load from memory with acquire semantics.
  * `LDUMINL` and `LDUMINAL` store to memory with release semantics.
  * `LDUMIN` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMIN--LDUMINA--LDUMINAL--LDUMINL--Atomic-unsigned-minimum-on-word-or-doubleword-in-memory-"
    )
    this["lduminl"] = OpCodeDoc(
        "LDUMINL",
        """Atomic unsigned minimum on word or doubleword in memory atomically loads a
32-bit word or 64-bit doubleword from memory, compares it against the value
held in a register, and stores the smaller value back to memory, treating the
values as unsigned numbers. The value initially loaded from memory is returned
in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `LDUMINA` and `LDUMINAL` load from memory with acquire semantics.
  * `LDUMINL` and `LDUMINAL` store to memory with release semantics.
  * `LDUMIN` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMIN--LDUMINA--LDUMINAL--LDUMINL--Atomic-unsigned-minimum-on-word-or-doubleword-in-memory-"
    )
    this["lduminab"] = OpCodeDoc(
        "LDUMINAB",
        """Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as unsigned numbers. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDUMINAB` and `LDUMINALB` load from memory with acquire semantics.
  * `LDUMINLB` and `LDUMINALB` store to memory with release semantics.
  * `LDUMINB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMINB--LDUMINAB--LDUMINALB--LDUMINLB--Atomic-unsigned-minimum-on-byte-in-memory-"
    )
    this["lduminalb"] = OpCodeDoc(
        "LDUMINALB",
        """Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as unsigned numbers. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDUMINAB` and `LDUMINALB` load from memory with acquire semantics.
  * `LDUMINLB` and `LDUMINALB` store to memory with release semantics.
  * `LDUMINB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMINB--LDUMINAB--LDUMINALB--LDUMINLB--Atomic-unsigned-minimum-on-byte-in-memory-"
    )
    this["lduminb"] = OpCodeDoc(
        "LDUMINB",
        """Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as unsigned numbers. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDUMINAB` and `LDUMINALB` load from memory with acquire semantics.
  * `LDUMINLB` and `LDUMINALB` store to memory with release semantics.
  * `LDUMINB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMINB--LDUMINAB--LDUMINALB--LDUMINLB--Atomic-unsigned-minimum-on-byte-in-memory-"
    )
    this["lduminlb"] = OpCodeDoc(
        "LDUMINLB",
        """Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from
memory, compares it against the value held in a register, and stores the
smaller value back to memory, treating the values as unsigned numbers. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `LDUMINAB` and `LDUMINALB` load from memory with acquire semantics.
  * `LDUMINLB` and `LDUMINALB` store to memory with release semantics.
  * `LDUMINB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMINB--LDUMINAB--LDUMINALB--LDUMINLB--Atomic-unsigned-minimum-on-byte-in-memory-"
    )
    this["lduminah"] = OpCodeDoc(
        "LDUMINAH",
        """Atomic unsigned minimum on halfword in memory atomically loads a 16-bit
halfword from memory, compares it against the value held in a register, and
stores the smaller value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDUMINAH` and `LDUMINALH` load from memory with acquire semantics.
  * `LDUMINLH` and `LDUMINALH` store to memory with release semantics.
  * `LDUMINH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMINH--LDUMINAH--LDUMINALH--LDUMINLH--Atomic-unsigned-minimum-on-halfword-in-memory-"
    )
    this["lduminalh"] = OpCodeDoc(
        "LDUMINALH",
        """Atomic unsigned minimum on halfword in memory atomically loads a 16-bit
halfword from memory, compares it against the value held in a register, and
stores the smaller value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDUMINAH` and `LDUMINALH` load from memory with acquire semantics.
  * `LDUMINLH` and `LDUMINALH` store to memory with release semantics.
  * `LDUMINH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMINH--LDUMINAH--LDUMINALH--LDUMINLH--Atomic-unsigned-minimum-on-halfword-in-memory-"
    )
    this["lduminh"] = OpCodeDoc(
        "LDUMINH",
        """Atomic unsigned minimum on halfword in memory atomically loads a 16-bit
halfword from memory, compares it against the value held in a register, and
stores the smaller value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDUMINAH` and `LDUMINALH` load from memory with acquire semantics.
  * `LDUMINLH` and `LDUMINALH` store to memory with release semantics.
  * `LDUMINH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMINH--LDUMINAH--LDUMINALH--LDUMINLH--Atomic-unsigned-minimum-on-halfword-in-memory-"
    )
    this["lduminlh"] = OpCodeDoc(
        "LDUMINLH",
        """Atomic unsigned minimum on halfword in memory atomically loads a 16-bit
halfword from memory, compares it against the value held in a register, and
stores the smaller value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination
register.

  * If the destination register is not `WZR`, `LDUMINAH` and `LDUMINALH` load from memory with acquire semantics.
  * `LDUMINLH` and `LDUMINALH` store to memory with release semantics.
  * `LDUMINH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUMINH--LDUMINAH--LDUMINALH--LDUMINLH--Atomic-unsigned-minimum-on-halfword-in-memory-"
    )
    this["ldur"] = OpCodeDoc(
        "LDUR",
        """Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP
register from memory. The address that is used for the load is calculated from
a base register value and an optional immediate offset.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDUR--SIMD-FP---Load-simd-fp-register--unscaled-offset--"
    )
    this["ldurb"] = OpCodeDoc(
        "LDURB",
        """Load Register Byte (unscaled) calculates an address from a base register and
an immediate offset, loads a byte from memory, zero-extends it, and writes it
to a register. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDURB--Load-register-byte--unscaled--"
    )
    this["ldurh"] = OpCodeDoc(
        "LDURH",
        """Load Register Halfword (unscaled) calculates an address from a base register
and an immediate offset, loads a halfword from memory, zero-extends it, and
writes it to a register. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDURH--Load-register-halfword--unscaled--"
    )
    this["ldursb"] = OpCodeDoc(
        "LDURSB",
        """Load Register Signed Byte (unscaled) calculates an address from a base
register and an immediate offset, loads a signed byte from memory, sign-
extends it, and writes it to a register. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDURSB--Load-register-signed-byte--unscaled--"
    )
    this["ldursh"] = OpCodeDoc(
        "LDURSH",
        """Load Register Signed Halfword (unscaled) calculates an address from a base
register and an immediate offset, loads a signed halfword from memory, sign-
extends it, and writes it to a register. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDURSH--Load-register-signed-halfword--unscaled--"
    )
    this["ldursw"] = OpCodeDoc(
        "LDURSW",
        """Load Register Signed Word (unscaled) calculates an address from a base
register and an immediate offset, loads a signed word from memory, sign-
extends it, and writes it to a register. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDURSW--Load-register-signed-word--unscaled--"
    )
    this["ldxp"] = OpCodeDoc(
        "LDXP",
        """Load Exclusive Pair of Registers derives an address from a base register
value, loads two 32-bit words or two 64-bit doublewords from memory, and
writes them to two registers. For information on single-copy atomicity and
alignment requirements, see Requirements for single-copy atomicity and
Alignment of data accesses. The PE marks the physical address being accessed
as an exclusive access. This exclusive access mark is checked by Store
Exclusive instructions. See Synchronization and semaphores. For information
about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDXP--Load-exclusive-pair-of-registers-"
    )
    this["ldxr"] = OpCodeDoc(
        "LDXR",
        """Load Exclusive Register derives an address from a base register value, loads a
32-bit word or a 64-bit doubleword from memory, and writes it to a register.
The memory access is atomic. The PE marks the physical address being accessed
as an exclusive access. This exclusive access mark is checked by Store
Exclusive instructions. See Synchronization and semaphores. For information
about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDXR--Load-exclusive-register-"
    )
    this["ldxrb"] = OpCodeDoc(
        "LDXRB",
        """Load Exclusive Register Byte derives an address from a base register value,
loads a byte from memory, zero-extends it and writes it to a register. The
memory access is atomic. The PE marks the physical address being accessed as
an exclusive access. This exclusive access mark is checked by Store Exclusive
instructions. See Synchronization and semaphores. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDXRB--Load-exclusive-register-byte-"
    )
    this["ldxrh"] = OpCodeDoc(
        "LDXRH",
        """Load Exclusive Register Halfword derives an address from a base register
value, loads a halfword from memory, zero-extends it and writes it to a
register. The memory access is atomic. The PE marks the physical address being
accessed as an exclusive access. This exclusive access mark is checked by
Store Exclusive instructions. See Synchronization and semaphores. For
information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LDXRH--Load-exclusive-register-halfword-"
    )
    this["lsl"] = OpCodeDoc(
        "LSL",
        """Logical Shift Left (register) shifts a register value left by a variable
number of bits, shifting in zeros, and writes the result to the destination
register. The remainder obtained by dividing the second source register by the
data size defines the number of bits by which the first source register is
left-shifted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LSL--register---Logical-shift-left--register--"
    )
    this["lsl"] = OpCodeDoc(
        "LSL",
        """Logical Shift Left (immediate) shifts a register value left by an immediate
number of bits, shifting in zeros, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LSL--immediate---Logical-shift-left--immediate--"
    )
    this["lslr"] = OpCodeDoc(
        "LSLR",
        """Reversed shift left active elements of the second source vector by
corresponding elements of the first source vector and destructively place the
results in the corresponding elements of the first source vector. The shift
amount operand is a vector of unsigned elements in which all bits are
significant, and not used modulo the element size. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LSLR---"
    )
    this["lslv"] = OpCodeDoc(
        "LSLV",
        """Logical Shift Left Variable shifts a register value left by a variable number
of bits, shifting in zeros, and writes the result to the destination register.
The remainder obtained by dividing the second source register by the data size
defines the number of bits by which the first source register is left-shifted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LSLV--Logical-shift-left-variable-"
    )
    this["lsr"] = OpCodeDoc(
        "LSR",
        """Logical Shift Right (register) shifts a register value right by a variable
number of bits, shifting in zeros, and writes the result to the destination
register. The remainder obtained by dividing the second source register by the
data size defines the number of bits by which the first source register is
right-shifted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LSR--register---Logical-shift-right--register--"
    )
    this["lsr"] = OpCodeDoc(
        "LSR",
        """Logical Shift Right (immediate) shifts a register value right by an immediate
number of bits, shifting in zeros, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LSR--immediate---Logical-shift-right--immediate--"
    )
    this["lsrr"] = OpCodeDoc(
        "LSRR",
        """Reversed shift right, inserting zeroes, active elements of the second source
vector by corresponding elements of the first source vector and destructively
place the results in the corresponding elements of the first source vector.
The shift amount operand is a vector of unsigned elements in which all bits
are significant, and not used modulo the element size. Inactive elements in
the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LSRR---"
    )
    this["lsrv"] = OpCodeDoc(
        "LSRV",
        """Logical Shift Right Variable shifts a register value right by a variable
number of bits, shifting in zeros, and writes the result to the destination
register. The remainder obtained by dividing the second source register by the
data size defines the number of bits by which the first source register is
right-shifted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LSRV--Logical-shift-right-variable-"
    )
    this["luti2"] = OpCodeDoc(
        "LUTI2",
        """Copy 8-bit, 16-bit or 32-bit elements from ZT0 to two destination vectors
using packed 2-bit indices from a segment of the source vector register. A
segment corresponds to a portion of the source vector that is consumed in
order to fill the destination vector. The segment is selected by the vector
segment index modulo the total number of segments.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LUTI---two-registers----"
    )
    this["luti4"] = OpCodeDoc(
        "LUTI4",
        """Copy 8-bit, 16-bit or 32-bit elements from ZT0 to two destination vectors
using packed 4-bit indices from a segment of the source vector register. A
segment corresponds to a portion of the source vector that is consumed in
order to fill the destination vector. The segment is selected by the vector
segment index modulo the total number of segments.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/LUTI---two-registers----"
    )
    this["mad"] = OpCodeDoc(
        "MAD",
        """Multiply the corresponding active elements of the first and second source
vectors and add to elements of the third (addend) vector. Destructively place
the results in the destination and first source (multiplicand) vector.
Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MAD---"
    )
    this["madd"] = OpCodeDoc(
        "MADD",
        """Multiply-Add multiplies two register values, adds a third register value, and
writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MADD--Multiply-add-"
    )
    this["match"] = OpCodeDoc(
        "MATCH",
        """This instruction compares each active 8-bit or 16-bit character in the first
source vector with all of the characters in the corresponding 128-bit segment
of the second source vector. Where the first source element detects any
matching characters in the second segment it places true in the corresponding
element of the destination predicate, otherwise false. Inactive elements in
the destination predicate register are set to zero. Sets the First (N), None
(Z), !Last (C) condition flags based on the predicate result, and the V flag
to zero.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MATCH---"
    )
    this["mla"] = OpCodeDoc(
        "MLA",
        """Multiply-Add to accumulator (vector, by element). This instruction multiplies
the vector elements in the first source SIMD&FP register by the specified
value in the second source SIMD&FP register, and accumulates the results with
the vector elements of the destination SIMD&FP register. All the values in
this instruction are unsigned integer values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MLA--by-element---Multiply-add-to-accumulator--vector--by-element--"
    )
    this["mls"] = OpCodeDoc(
        "MLS",
        """Multiply-Subtract from accumulator (vector, by element). This instruction
multiplies the vector elements in the first source SIMD&FP register by the
specified value in the second source SIMD&FP register, and subtracts the
results from the vector elements of the destination SIMD&FP register. All the
values in this instruction are unsigned integer values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MLS--by-element---Multiply-subtract-from-accumulator--vector--by-element--"
    )
    this["mneg"] = OpCodeDoc(
        "MNEG",
        """Multiply-Negate multiplies two register values, negates the product, and
writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MNEG--Multiply-negate-"
    )
    this["mov"] = OpCodeDoc(
        "MOV",
        """Read active elements from the source predicate and place in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Does not set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOV--predicate--predicated--zeroing----"
    )
    this["mov"] = OpCodeDoc(
        "MOV",
        """Move (register) copies the value in a source register to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOV--register---Move--register--"
    )
    this["mova"] = OpCodeDoc(
        "MOVA",
        """The instruction operates on two consecutive horizontal or vertical slices
within a named ZA tile of the specified element size.

The consecutive slice numbers within the tile are selected starting from the
sum of the slice index register and immediate offset, modulo the number of
such elements in a vector. The immediate offset is a multiple of 2 in the
range 0 to the number of elements in a 128-bit vector segment minus 2.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOVA--tile-to-vector--two-registers----"
    )
    this["movaz"] = OpCodeDoc(
        "MOVAZ",
        """The instruction operates on two consecutive horizontal or vertical slices
within a named ZA tile of the specified element size. The tile slices are
zeroed after moving their contents to the destination vectors.

The consecutive slice numbers within the tile are selected starting from the
sum of the slice index register and immediate offset, modulo the number of
such elements in a vector. The immediate offset is a multiple of 2 in the
range 0 to the number of elements in a 128-bit vector segment minus 2.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOVAZ--tile-to-vector--two-registers----"
    )
    this["movi"] = OpCodeDoc(
        "MOVI",
        """Move Immediate (vector). This instruction places an immediate constant into
every vector element of the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOVI--Move-immediate--vector--"
    )
    this["movk"] = OpCodeDoc(
        "MOVK",
        """Move wide with keep moves an optionally-shifted 16-bit immediate value into a
register, keeping other bits unchanged.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOVK--Move-wide-with-keep-"
    )
    this["movn"] = OpCodeDoc(
        "MOVN",
        """Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate
value to a register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOVN--Move-wide-with-not-"
    )
    this["movprfx"] = OpCodeDoc(
        "MOVPRFX",
        """The predicated `MOVPRFX` instruction is a hint to hardware that the
instruction may be combined with the destructive instruction which follows it
in program order to create a single constructive operation. Since it is a hint
it is also permitted to be implemented as a discrete vector copy, and the
result of executing the pair of instructions with or without combining is
identical. The choice of combined versus discrete operation may vary
dynamically.

Unless the combination of a constructive operation with merging predication is
specifically required, it is strongly recommended that for performance reasons
software should prefer to use the zeroing form of predicated `MOVPRFX` or the
unpredicated `MOVPRFX` instruction.

Although the operation of the instruction is defined as a simple predicated
vector copy, it is required that the prefixed instruction at PC+4 must be an
SVE destructive binary or ternary instruction encoding, or a unary operation
with merging predication, but excluding other `MOVPRFX` instructions. The
prefixed instruction must specify the same predicate register, and have the
same maximum element size (ignoring a fixed 64-bit "wide vector" operand), and
the same destination vector as the `MOVPRFX` instruction. The prefixed
instruction must not use the destination register in any other operand
position, even if they have different names but refer to the same
architectural register state. Any other use is UNPREDICTABLE.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOVPRFX--predicated----"
    )
    this["movs"] = OpCodeDoc(
        "MOVS",
        """Read active elements from the source predicate and place in the corresponding
elements of the destination predicate. Inactive elements in the destination
predicate register are set to zero. Sets the First (N), None (Z), !Last (C)
condition flags based on the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOVS--predicated----"
    )
    this["movt"] = OpCodeDoc(
        "MOVT",
        """Move 8 bytes to a general-purpose register from the ZT0 register at the byte
offset specified by the immediate index. This instruction is UNDEFINED in Non-
debug state.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOVT--ZT--to-scalar----"
    )
    this["movz"] = OpCodeDoc(
        "MOVZ",
        """Move wide with zero moves an optionally-shifted 16-bit immediate value to a
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MOVZ--Move-wide-with-zero-"
    )
    this["mrrs"] = OpCodeDoc(
        "MRRS",
        """Move System Register to two adjacent general-purpose registers allows the PE
to read an AArch64 128-bit System register into two adjacent 64-bit general-
purpose registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MRRS--Move-system-register-to-two-adjacent-general-purpose-registers-"
    )
    this["mrs"] = OpCodeDoc(
        "MRS",
        """Move System Register to general-purpose register allows the PE to read an
AArch64 System register into a general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MRS--Move-system-register-to-general-purpose-register-"
    )
    this["msb"] = OpCodeDoc(
        "MSB",
        """Multiply the corresponding active elements of the first and second source
vectors and subtract from elements of the third (addend) vector. Destructively
place the results in the destination and first source (multiplicand) vector.
Inactive elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MSB---"
    )
    this["msr"] = OpCodeDoc(
        "MSR",
        """Move immediate value to Special Register moves an immediate value to selected
bits of the PSTATE. For more information, see Process state, PSTATE.

The bits that can be written by this instruction are:

  * PSTATE.D, PSTATE.A, PSTATE.I, PSTATE.F, and PSTATE.SP.
  * If FEAT_SSBS is implemented, PSTATE.SSBS.
  * If FEAT_PAN is implemented, PSTATE.PAN.
  * If FEAT_UAO is implemented, PSTATE.UAO.
  * If FEAT_DIT is implemented, PSTATE.DIT.
  * If FEAT_MTE is implemented, PSTATE.TCO.
  * If FEAT_NMI is implemented, PSTATE.ALLINT.
  * If FEAT_SME is implemented, PSTATE.SM and PSTATE.ZA.
  * If FEAT_EBEP is implemented, PSTATE.PM.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MSR--immediate---Move-immediate-value-to-special-register-"
    )
    this["msr"] = OpCodeDoc(
        "MSR",
        """Move general-purpose register to System Register allows the PE to write an
AArch64 System register from a general-purpose register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MSR--register---Move-general-purpose-register-to-system-register-"
    )
    this["msrr"] = OpCodeDoc(
        "MSRR",
        """Move two adjacent general-purpose registers to System Register allows the PE
to write an AArch64 128-bit System register from two adjacent 64-bit general-
purpose registers.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MSRR--Move-two-adjacent-general-purpose-registers-to-system-register-"
    )
    this["msub"] = OpCodeDoc(
        "MSUB",
        """Multiply-Subtract multiplies two register values, subtracts the product from a
third register value, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MSUB--Multiply-subtract-"
    )
    this["mul"] = OpCodeDoc(
        "MUL",
        """Multiply (vector, by element). This instruction multiplies the vector elements
in the first source SIMD&FP register by the specified value in the second
source SIMD&FP register, places the results in a vector, and writes the vector
to the destination SIMD&FP register. All the values in this instruction are
unsigned integer values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MUL--by-element---Multiply--vector--by-element--"
    )
    this["mul"] = OpCodeDoc(
        "MUL",
        """Multiply by an immediate each element of the source vector, and destructively
place the results in the corresponding elements of the source vector. The
immediate is a signed 8-bit value in the range -128 to +127, inclusive. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MUL--immediate----"
    )
    this["mvn"] = OpCodeDoc(
        "MVN",
        """Bitwise NOT (vector). This instruction reads each vector element from the
source SIMD&FP register, places the inverse of each value into a vector, and
writes the vector to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MVN--Bitwise-not--vector--"
    )
    this["mvni"] = OpCodeDoc(
        "MVNI",
        """Move inverted Immediate (vector). This instruction places the inverse of an
immediate constant into every vector element of the destination SIMD&FP
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/MVNI--Move-inverted-immediate--vector--"
    )
    this["nand"] = OpCodeDoc(
        "NAND",
        """Bitwise NAND active elements of the second source predicate with corresponding
elements of the first source predicate and place the results in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Does not set the condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NAND---"
    )
    this["nands"] = OpCodeDoc(
        "NANDS",
        """Bitwise NAND active elements of the second source predicate with corresponding
elements of the first source predicate and place the results in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Sets the First (N), None (Z),
!Last (C) condition flags based on the predicate result, and the V flag to
zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NANDS---"
    )
    this["nbsl"] = OpCodeDoc(
        "NBSL",
        """Selects bits from the first source vector where the corresponding bit in the
third source vector is '1', and from the second source vector where the
corresponding bit in the third source vector is '0'. The inverted result is
placed destructively in the destination and first source vector. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NBSL---"
    )
    this["neg"] = OpCodeDoc(
        "NEG",
        """Negate (vector). This instruction reads each vector element from the source
SIMD&FP register, negates each value, puts the result into a vector, and
writes the vector to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NEG--vector---Negate--vector--"
    )
    this["negs"] = OpCodeDoc(
        "NEGS",
        """Negate, setting flags, negates an optionally-shifted register value, and
writes the result to the destination register. It updates the condition flags
based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NEGS--Negate--setting-flags-"
    )
    this["ngc"] = OpCodeDoc(
        "NGC",
        """Negate with Carry negates the sum of a register value and the value of NOT
(Carry flag), and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NGC--Negate-with-carry-"
    )
    this["ngcs"] = OpCodeDoc(
        "NGCS",
        """Negate with Carry, setting flags, negates the sum of a register value and the
value of NOT (Carry flag), and writes the result to the destination register.
It updates the condition flags based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NGCS--Negate-with-carry--setting-flags-"
    )
    this["nmatch"] = OpCodeDoc(
        "NMATCH",
        """This instruction compares each active 8-bit or 16-bit character in the first
source vector with all of the characters in the corresponding 128-bit segment
of the second source vector. Where the first source element detects no
matching characters in the second segment it places true in the corresponding
element of the destination predicate, otherwise false. Inactive elements in
the destination predicate register are set to zero. Sets the First (N), None
(Z), !Last (C) condition flags based on the predicate result, and the V flag
to zero.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NMATCH---"
    )
    this["nop"] = OpCodeDoc(
        "NOP",
        """No Operation does nothing, other than advance the value of the program counter
by 4. This instruction can be used for instruction alignment purposes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NOP--No-operation-"
    )
    this["nor"] = OpCodeDoc(
        "NOR",
        """Bitwise NOR active elements of the second source predicate with corresponding
elements of the first source predicate and place the results in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Does not set the condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NOR---"
    )
    this["nors"] = OpCodeDoc(
        "NORS",
        """Bitwise NOR active elements of the second source predicate with corresponding
elements of the first source predicate and place the results in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Sets the First (N), None (Z),
!Last (C) condition flags based on the predicate result, and the V flag to
zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NORS---"
    )
    this["not"] = OpCodeDoc(
        "NOT",
        """Bitwise NOT (vector). This instruction reads each vector element from the
source SIMD&FP register, places the inverse of each value into a vector, and
writes the vector to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NOT--Bitwise-not--vector--"
    )
    this["nots"] = OpCodeDoc(
        "NOTS",
        """Bitwise invert each active element of the source predicate, and place the
results in the corresponding elements of the destination predicate. Inactive
elements in the destination predicate register are set to zero. Sets the First
(N), None (Z), !Last (C) condition flags based on the predicate result, and
the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/NOTS---"
    )
    this["orn"] = OpCodeDoc(
        "ORN",
        """Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT
between the two source SIMD&FP registers, and writes the result to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ORN--vector---Bitwise-inclusive-or-not--vector--"
    )
    this["orn"] = OpCodeDoc(
        "ORN",
        """Bitwise inclusive OR an inverted immediate with each 64-bit element of the
source vector, and destructively place the results in the corresponding
elements of the source vector. The immediate is a 64-bit value consisting of a
single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ORN--immediate----"
    )
    this["orns"] = OpCodeDoc(
        "ORNS",
        """Bitwise inclusive OR inverted active elements of the second source predicate
with corresponding elements of the first source predicate and place the
results in the corresponding elements of the destination predicate. Inactive
elements in the destination predicate register are set to zero. Sets the First
(N), None (Z), !Last (C) condition flags based on the predicate result, and
the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ORNS---"
    )
    this["orqv"] = OpCodeDoc(
        "ORQV",
        """Bitwise inclusive OR of the same element numbers from each 128-bit source
vector segment, placing each result into the corresponding element number of
the 128-bit SIMD&FP destination register. Inactive elements in the source
vector are treated as all zeros.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ORQV---"
    )
    this["orr"] = OpCodeDoc(
        "ORR",
        """Bitwise inclusive OR (vector, immediate). This instruction reads each vector
element from the destination SIMD&FP register, performs a bitwise OR between
each result and an immediate constant, places the result into a vector, and
writes the vector to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ORR--vector--immediate---Bitwise-inclusive-or--vector--immediate--"
    )
    this["orr"] = OpCodeDoc(
        "ORR",
        """Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value
and an immediate register value, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ORR--immediate---Bitwise-or--immediate--"
    )
    this["orr"] = OpCodeDoc(
        "ORR",
        """Bitwise inclusive OR an immediate with each 64-bit element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. The immediate is a 64-bit value consisting of a single run
of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction
is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ORR--immediate----"
    )
    this["orrs"] = OpCodeDoc(
        "ORRS",
        """Bitwise inclusive OR active elements of the second source predicate with
corresponding elements of the first source predicate and place the results in
the corresponding elements of the destination predicate. Inactive elements in
the destination predicate register are set to zero. Sets the First (N), None
(Z), !Last (C) condition flags based on the predicate result, and the V flag
to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ORRS---"
    )
    this["orv"] = OpCodeDoc(
        "ORV",
        """Bitwise inclusive OR horizontally across all lanes of a vector, and place the
result in the SIMD&FP scalar destination register. Inactive elements in the
source vector are treated as zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ORV---"
    )
    this["pacda"] = OpCodeDoc(
        "PACDA",
        """Pointer Authentication Code for Data address, using key A. This instruction
computes and inserts a pointer authentication code for a data address, using a
modifier and key A.

The address is in the general-purpose register that is specified by <Xd>.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACDA`.
  * The value zero, for `PACDZA`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACDA--PACDZA--Pointer-authentication-code-for-data-address--using-key-a-"
    )
    this["pacdza"] = OpCodeDoc(
        "PACDZA",
        """Pointer Authentication Code for Data address, using key A. This instruction
computes and inserts a pointer authentication code for a data address, using a
modifier and key A.

The address is in the general-purpose register that is specified by <Xd>.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACDA`.
  * The value zero, for `PACDZA`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACDA--PACDZA--Pointer-authentication-code-for-data-address--using-key-a-"
    )
    this["pacdb"] = OpCodeDoc(
        "PACDB",
        """Pointer Authentication Code for Data address, using key B. This instruction
computes and inserts a pointer authentication code for a data address, using a
modifier and key B.

The address is in the general-purpose register that is specified by <Xd>.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACDB`.
  * The value zero, for `PACDZB`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACDB--PACDZB--Pointer-authentication-code-for-data-address--using-key-b-"
    )
    this["pacdzb"] = OpCodeDoc(
        "PACDZB",
        """Pointer Authentication Code for Data address, using key B. This instruction
computes and inserts a pointer authentication code for a data address, using a
modifier and key B.

The address is in the general-purpose register that is specified by <Xd>.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACDB`.
  * The value zero, for `PACDZB`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACDB--PACDZB--Pointer-authentication-code-for-data-address--using-key-b-"
    )
    this["pacga"] = OpCodeDoc(
        "PACGA",
        """Pointer Authentication Code, using Generic key. This instruction computes the
pointer authentication code for a 64-bit value in the first source register,
using a modifier in the second source register, and the Generic key. The
computed pointer authentication code is written to the most significant 32
bits of the destination register, and the least significant 32 bits of the
destination register are set to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACGA--Pointer-authentication-code--using-generic-key-"
    )
    this["pacia"] = OpCodeDoc(
        "PACIA",
        """Pointer Authentication Code for Instruction address, using key A. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIA` and `PACIZA`.
  * In X17, for `PACIA1716`.
  * In X30, for `PACIASP` and `PACIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIA`.
  * The value zero, for `PACIZA` and `PACIAZ`.
  * In X16, for `PACIA1716`.
  * In SP, for `PACIASP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIA--PACIA------PACIASP--PACIAZ--PACIZA--Pointer-authentication-code-for-instruction-address--using-key-a-"
    )
    this["pacia1716"] = OpCodeDoc(
        "PACIA1716",
        """Pointer Authentication Code for Instruction address, using key A. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIA` and `PACIZA`.
  * In X17, for `PACIA1716`.
  * In X30, for `PACIASP` and `PACIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIA`.
  * The value zero, for `PACIZA` and `PACIAZ`.
  * In X16, for `PACIA1716`.
  * In SP, for `PACIASP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIA--PACIA------PACIASP--PACIAZ--PACIZA--Pointer-authentication-code-for-instruction-address--using-key-a-"
    )
    this["paciasp"] = OpCodeDoc(
        "PACIASP",
        """Pointer Authentication Code for Instruction address, using key A. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIA` and `PACIZA`.
  * In X17, for `PACIA1716`.
  * In X30, for `PACIASP` and `PACIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIA`.
  * The value zero, for `PACIZA` and `PACIAZ`.
  * In X16, for `PACIA1716`.
  * In SP, for `PACIASP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIA--PACIA------PACIASP--PACIAZ--PACIZA--Pointer-authentication-code-for-instruction-address--using-key-a-"
    )
    this["paciaz"] = OpCodeDoc(
        "PACIAZ",
        """Pointer Authentication Code for Instruction address, using key A. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIA` and `PACIZA`.
  * In X17, for `PACIA1716`.
  * In X30, for `PACIASP` and `PACIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIA`.
  * The value zero, for `PACIZA` and `PACIAZ`.
  * In X16, for `PACIA1716`.
  * In SP, for `PACIASP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIA--PACIA------PACIASP--PACIAZ--PACIZA--Pointer-authentication-code-for-instruction-address--using-key-a-"
    )
    this["paciza"] = OpCodeDoc(
        "PACIZA",
        """Pointer Authentication Code for Instruction address, using key A. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key A.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIA` and `PACIZA`.
  * In X17, for `PACIA1716`.
  * In X30, for `PACIASP` and `PACIAZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIA`.
  * The value zero, for `PACIZA` and `PACIAZ`.
  * In X16, for `PACIA1716`.
  * In SP, for `PACIASP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIA--PACIA------PACIASP--PACIAZ--PACIZA--Pointer-authentication-code-for-instruction-address--using-key-a-"
    )
    this["pacib"] = OpCodeDoc(
        "PACIB",
        """Pointer Authentication Code for Instruction address, using key B. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIB` and `PACIZB`.
  * In X17, for `PACIB1716`.
  * In X30, for `PACIBSP` and `PACIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIB`.
  * The value zero, for `PACIZB` and `PACIBZ`.
  * In X16, for `PACIB1716`.
  * In SP, for `PACIBSP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIB--PACIB------PACIBSP--PACIBZ--PACIZB--Pointer-authentication-code-for-instruction-address--using-key-b-"
    )
    this["pacib1716"] = OpCodeDoc(
        "PACIB1716",
        """Pointer Authentication Code for Instruction address, using key B. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIB` and `PACIZB`.
  * In X17, for `PACIB1716`.
  * In X30, for `PACIBSP` and `PACIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIB`.
  * The value zero, for `PACIZB` and `PACIBZ`.
  * In X16, for `PACIB1716`.
  * In SP, for `PACIBSP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIB--PACIB------PACIBSP--PACIBZ--PACIZB--Pointer-authentication-code-for-instruction-address--using-key-b-"
    )
    this["pacibsp"] = OpCodeDoc(
        "PACIBSP",
        """Pointer Authentication Code for Instruction address, using key B. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIB` and `PACIZB`.
  * In X17, for `PACIB1716`.
  * In X30, for `PACIBSP` and `PACIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIB`.
  * The value zero, for `PACIZB` and `PACIBZ`.
  * In X16, for `PACIB1716`.
  * In SP, for `PACIBSP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIB--PACIB------PACIBSP--PACIBZ--PACIZB--Pointer-authentication-code-for-instruction-address--using-key-b-"
    )
    this["pacibz"] = OpCodeDoc(
        "PACIBZ",
        """Pointer Authentication Code for Instruction address, using key B. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIB` and `PACIZB`.
  * In X17, for `PACIB1716`.
  * In X30, for `PACIBSP` and `PACIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIB`.
  * The value zero, for `PACIZB` and `PACIBZ`.
  * In X16, for `PACIB1716`.
  * In SP, for `PACIBSP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIB--PACIB------PACIBSP--PACIBZ--PACIZB--Pointer-authentication-code-for-instruction-address--using-key-b-"
    )
    this["pacizb"] = OpCodeDoc(
        "PACIZB",
        """Pointer Authentication Code for Instruction address, using key B. This
instruction computes and inserts a pointer authentication code for an
instruction address, using a modifier and key B.

The address is:

  * In the general-purpose register that is specified by <Xd> for `PACIB` and `PACIZB`.
  * In X17, for `PACIB1716`.
  * In X30, for `PACIBSP` and `PACIBZ`.

The modifier is:

  * In the general-purpose register or stack pointer that is specified by <Xn|SP> for `PACIB`.
  * The value zero, for `PACIZB` and `PACIBZ`.
  * In X16, for `PACIB1716`.
  * In SP, for `PACIBSP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PACIB--PACIB------PACIBSP--PACIBZ--PACIZB--Pointer-authentication-code-for-instruction-address--using-key-b-"
    )
    this["pext"] = OpCodeDoc(
        "PEXT",
        """Expands the source predicate-as-counter into a four-predicate wide mask and
copies one quarter of it into the destination predicate register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PEXT--predicate----"
    )
    this["pfalse"] = OpCodeDoc(
        "PFALSE",
        """Set all elements in the destination predicate to false.

For programmer convenience, an assembler must also accept predicate-as-counter
register name for the destination predicate register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PFALSE---"
    )
    this["pfirst"] = OpCodeDoc(
        "PFIRST",
        """Sets the first active element in the destination predicate to true, otherwise
elements from the source predicate are passed through unchanged. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PFIRST---"
    )
    this["pmov"] = OpCodeDoc(
        "PMOV",
        """Copy a packed bitmap, where bit value 0b1 represents TRUE and bit value 0b0
represents FALSE, from part of a source vector register to elements of a
destination SVE predicate register.

Because the number of bits in an SVE predicate element scales with the vector
element size, the behavior varies according to the specified element size.

  * When the predicate element specifier is.B, each bit [N] from the least-significant VL/8 bits in the source vector register is copied to bit [N] of the destination predicate register. The immediate index, if specified, must be 0. 
  * When the predicate element specifier is.H, each bit [N] within the indexed block of VL/16 bits in the source vector register is copied to bit [N*2] of the destination predicate register, and the other bits in the predicate are set to zero. The immediate index is in the range 0 to 1, inclusive. 
  * When the predicate elements specifier is.S, each bit [N] within the indexed block of VL/32 bits in the source vector register is copied to bit [N*4] of the destination predicate register, and the other bits in the predicate are set to zero. The immediate index is in the range 0 to 3, inclusive. 
  * When the predicate element specifier is.D, each bit [N] within the indexed block of VL/64 bits in the source vector register is copied to bit [N*8] of the destination predicate register, and the other bits in the predicate are set to zero. The immediate index is in the range 0 to 7, inclusive. 

The immediate index is optional, defaulting to 0 if omitted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PMOV--to-predicate----"
    )
    this["pmul"] = OpCodeDoc(
        "PMUL",
        """Polynomial Multiply. This instruction multiplies corresponding elements in the
vectors of the two source SIMD&FP registers, places the results in a vector,
and writes the vector to the destination SIMD&FP register.

For information about multiplying polynomials see Polynomial arithmetic over
{0, 1}.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PMUL--Polynomial-multiply-"
    )
    this["pmull"] = OpCodeDoc(
        "PMULL",
        """Polynomial Multiply Long. This instruction multiplies corresponding elements
in the lower or upper half of the vectors of the two source SIMD&FP registers,
places the results in a vector, and writes the vector to the destination
SIMD&FP register. The destination vector elements are twice as long as the
elements that are multiplied.

For information about multiplying polynomials, see Polynomial arithmetic over
{0, 1}.

The `PMULL` instruction extracts each source vector from the lower half of
each source register. The `PMULL2` instruction extracts each source vector
from the upper half of each source register.

The `PMULL` and `PMULL2` variants that operate on 64-bit source elements are
defined only when FEAT_PMULL is implemented.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PMULL--PMULL---Polynomial-multiply-long-"
    )
    this["pmull2"] = OpCodeDoc(
        "PMULL2",
        """Polynomial Multiply Long. This instruction multiplies corresponding elements
in the lower or upper half of the vectors of the two source SIMD&FP registers,
places the results in a vector, and writes the vector to the destination
SIMD&FP register. The destination vector elements are twice as long as the
elements that are multiplied.

For information about multiplying polynomials, see Polynomial arithmetic over
{0, 1}.

The `PMULL` instruction extracts each source vector from the lower half of
each source register. The `PMULL2` instruction extracts each source vector
from the upper half of each source register.

The `PMULL` and `PMULL2` variants that operate on 64-bit source elements are
defined only when FEAT_PMULL is implemented.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PMULL--PMULL---Polynomial-multiply-long-"
    )
    this["pmullb"] = OpCodeDoc(
        "PMULLB",
        """Polynomial multiply over [0, 1] the corresponding even-numbered elements of
the first and second source vectors, and place the results in the overlapping
double-width elements of the destination vector. This instruction is
unpredicated.

ID_AA64ZFR0_EL1.AES indicates whether the 128-bit element variant is
implemented. The 128-bit element variant is illegal when executed in Streaming
SVE mode, unless FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PMULLB---"
    )
    this["pmullt"] = OpCodeDoc(
        "PMULLT",
        """Polynomial multiply over [0, 1] the corresponding odd-numbered elements of the
first and second source vectors, and place the results in the overlapping
double-width elements of the destination vector. This instruction is
unpredicated.

ID_AA64ZFR0_EL1.AES indicates whether the 128-bit element variant is
implemented. The 128-bit element variant is illegal when executed in Streaming
SVE mode, unless FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PMULLT---"
    )
    this["pnext"] = OpCodeDoc(
        "PNEXT",
        """An instruction used to construct a loop which iterates over all true elements
in the vector select predicate register. If all elements in the first source
predicate register are false it determines the first true element in the
vector select predicate register, otherwise it determines the next true
element in the vector select predicate register that follows the last true
element in the first source predicate register. All elements of the
destination predicate register are set to false, except the element
corresponding to the determined vector select element, if any, which is set to
true. Sets the First (N), None (Z), !Last (C) condition flags based on the
predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PNEXT---"
    )
    this["prfb"] = OpCodeDoc(
        "PRFB",
        """Gather prefetch of bytes from the active memory addresses generated by a
vector base plus immediate index. The index is in the range 0 to 31. Inactive
addresses are not prefetched from memory.

The <prfop> symbol specifies the prefetch hint as a combination of three
options: access type `PLD` for load or `PST` for store; target cache level
`L1`, `L2` or `L3`; temporality (`KEEP` for temporal or `STRM` for non-
temporal).

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PRFB--vector-plus-immediate----"
    )
    this["prfd"] = OpCodeDoc(
        "PRFD",
        """Gather prefetch of doublewords from the active memory addresses generated by a
vector base plus immediate index. The index is a multiple of 8 in the range 0
to 248. Inactive addresses are not prefetched from memory.

The <prfop> symbol specifies the prefetch hint as a combination of three
options: access type `PLD` for load or `PST` for store; target cache level
`L1`, `L2` or `L3`; temporality (`KEEP` for temporal or `STRM` for non-
temporal).

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PRFD--vector-plus-immediate----"
    )
    this["prfh"] = OpCodeDoc(
        "PRFH",
        """Gather prefetch of halfwords from the active memory addresses generated by a
vector base plus immediate index. The index is a multiple of 2 in the range 0
to 62. Inactive addresses are not prefetched from memory.

The <prfop> symbol specifies the prefetch hint as a combination of three
options: access type `PLD` for load or `PST` for store; target cache level
`L1`, `L2` or `L3`; temporality (`KEEP` for temporal or `STRM` for non-
temporal).

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PRFH--vector-plus-immediate----"
    )
    this["prfm"] = OpCodeDoc(
        "PRFM",
        """Prefetch Memory (immediate) signals the memory system that data memory
accesses from a specified address are likely to occur in the near future. The
memory system can respond by taking actions that are expected to speed up the
memory accesses when they do occur, such as preloading the cache line
containing the specified address into one or more caches.

The effect of a `PRFM` instruction is implementation defined. For more
information, see Prefetch memory.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PRFM--immediate---Prefetch-memory--immediate--"
    )
    this["prfm"] = OpCodeDoc(
        "PRFM",
        """Prefetch Memory (register) signals the memory system that data memory accesses
from a specified address are likely to occur in the near future. The memory
system can respond by taking actions that are expected to speed up the memory
accesses when they do occur, such as preloading the cache line containing the
specified address into one or more caches.

The effect of a `PRFM` instruction is implementation defined. For more
information, see Prefetch memory.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PRFM--register---Prefetch-memory--register--"
    )
    this["prfum"] = OpCodeDoc(
        "PRFUM",
        """Prefetch Memory (unscaled offset) signals the memory system that data memory
accesses from a specified address are likely to occur in the near future. The
memory system can respond by taking actions that are expected to speed up the
memory accesses when they do occur, such as preloading the cache line
containing the specified address into one or more caches.

The effect of a `PRFUM` instruction is implementation defined. For more
information, see Prefetch memory.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PRFUM--Prefetch-memory--unscaled-offset--"
    )
    this["prfw"] = OpCodeDoc(
        "PRFW",
        """Gather prefetch of words from the active memory addresses generated by a
vector base plus immediate index. The index is a multiple of 4 in the range 0
to 124. Inactive addresses are not prefetched from memory.

The <prfop> symbol specifies the prefetch hint as a combination of three
options: access type `PLD` for load or `PST` for store; target cache level
`L1`, `L2` or `L3`; temporality (`KEEP` for temporal or `STRM` for non-
temporal).

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PRFW--vector-plus-immediate----"
    )
    this["psbcsync"] = OpCodeDoc(
        "PSBCSYNC",
        """Profiling Synchronization Barrier. This instruction is a barrier that ensures
that all existing profiling data for the current PE has been formatted, and
profiling buffer addresses have been translated such that all writes to the
profiling buffer have been initiated. A following `DSB` instruction completes
when the writes to the profiling buffer have completed.

If the Statistical Profiling Extension is not implemented, this instruction
executes as a `NOP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PSB-CSYNC--Profiling-synchronization-barrier-"
    )
    this["psel"] = OpCodeDoc(
        "PSEL",
        """If the indexed element of the second source predicate is true, place the
contents of the first source predicate register into the destination predicate
register, otherwise set the destination predicate to all-false. The indexed
element is determined by the sum of a general-purpose index register and an
immediate, modulo the number of elements. Does not set the condition flags.

For programmer convenience, an assembler must also accept predicate-as-counter
register names for the destination predicate register and the first source
predicate register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PSEL---"
    )
    this["pssbb"] = OpCodeDoc(
        "PSSBB",
        """Physical Speculative Store Bypass Barrier is a memory barrier that prevents
speculative loads from bypassing earlier stores to the same physical address
under certain conditions. For more information and details of the semantics,
see Physical Speculative Store Bypass Barrier (PSSBB).

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PSSBB--Physical-speculative-store-bypass-barrier-"
    )
    this["ptest"] = OpCodeDoc(
        "PTEST",
        """Sets the First (N), None (Z), !Last (C) condition flags based on the predicate
source register, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PTEST---"
    )
    this["ptrue"] = OpCodeDoc(
        "PTRUE",
        """Set elements of the destination predicate to true if the element number
satisfies the named predicate constraint, or to false otherwise. If the
constraint specifies more elements than are available at the current vector
length then all elements of the destination predicate are set to false.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception. Does not
set the condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PTRUE--predicate----"
    )
    this["ptrues"] = OpCodeDoc(
        "PTRUES",
        """Set elements of the destination predicate to true if the element number
satisfies the named predicate constraint, or to false otherwise. If the
constraint specifies more elements than are available at the current vector
length then all elements of the destination predicate are set to false.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PTRUES---"
    )
    this["punpkhi"] = OpCodeDoc(
        "PUNPKHI",
        """Unpack elements from the lowest or highest half of the source predicate and
place in elements of twice their size within the destination predicate. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PUNPKHI--PUNPKLO---"
    )
    this["punpklo"] = OpCodeDoc(
        "PUNPKLO",
        """Unpack elements from the lowest or highest half of the source predicate and
place in elements of twice their size within the destination predicate. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/PUNPKHI--PUNPKLO---"
    )
    this["raddhn"] = OpCodeDoc(
        "RADDHN",
        """Rounding Add returning High Narrow. This instruction adds each vector element
in the first source SIMD&FP register to the corresponding vector element in
the second source SIMD&FP register, places the most significant half of the
result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register.

The results are rounded. For truncated results, see ADDHN.

The `RADDHN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `RADDHN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RADDHN--RADDHN---Rounding-add-returning-high-narrow-"
    )
    this["raddhn2"] = OpCodeDoc(
        "RADDHN2",
        """Rounding Add returning High Narrow. This instruction adds each vector element
in the first source SIMD&FP register to the corresponding vector element in
the second source SIMD&FP register, places the most significant half of the
result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register.

The results are rounded. For truncated results, see ADDHN.

The `RADDHN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `RADDHN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RADDHN--RADDHN---Rounding-add-returning-high-narrow-"
    )
    this["raddhnb"] = OpCodeDoc(
        "RADDHNB",
        """Add each vector element of the first source vector to the corresponding vector
element of the second source vector, and place the most significant rounded
half of the result in the even-numbered half-width destination elements, while
setting the odd-numbered elements to zero. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RADDHNB---"
    )
    this["raddhnt"] = OpCodeDoc(
        "RADDHNT",
        """Add each vector element of the first source vector to the corresponding vector
element of the second source vector, and place the most significant rounded
half of the result in the odd-numbered half-width destination elements,
leaving the even-numbered elements unchanged. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RADDHNT---"
    )
    this["rax1"] = OpCodeDoc(
        "RAX1",
        """Rotate and Exclusive-OR rotates each 64-bit element of the 128-bit vector in a
source SIMD&FP register left by 1, performs a bitwise exclusive-OR of the
resulting 128-bit vector and the vector in another source SIMD&FP register,
and writes the result to the destination SIMD&FP register.

This instruction is implemented only when FEAT_SHA3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RAX---Rotate-and-exclusive-or-"
    )
    this["rbit"] = OpCodeDoc(
        "RBIT",
        """Reverse Bit order (vector). This instruction reads each vector element from
the source SIMD&FP register, reverses the bits of the element, places the
results into a vector, and writes the vector to the destination SIMD&FP
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RBIT--vector---Reverse-bit-order--vector--"
    )
    this["rcwcas"] = OpCodeDoc(
        "RCWCAS",
        """Read Check Write Compare and Swap doubleword in memory reads a 64-bit
doubleword from memory, and compares it against the value held in a register.
If the comparison is equal, the value in a second register is conditionally
written to memory. Storing back to memory is conditional on RCW Checks. If the
write is performed, the read and the write occur atomically such that no other
modification of the memory location can take place between the read and the
write. This instruction updates the condition flags based on the result of the
update of memory.

  * `RCWCASA` and `RCWCASAL` load from memory with acquire semantics.
  * `RCWCASL` and `RCWCASAL` store to memory with release semantics.
  * `RCWCAS` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCAS--RCWCASA--RCWCASL--RCWCASAL--Read-check-write-compare-and-swap-doubleword-in-memory-"
    )
    this["rcwcasa"] = OpCodeDoc(
        "RCWCASA",
        """Read Check Write Compare and Swap doubleword in memory reads a 64-bit
doubleword from memory, and compares it against the value held in a register.
If the comparison is equal, the value in a second register is conditionally
written to memory. Storing back to memory is conditional on RCW Checks. If the
write is performed, the read and the write occur atomically such that no other
modification of the memory location can take place between the read and the
write. This instruction updates the condition flags based on the result of the
update of memory.

  * `RCWCASA` and `RCWCASAL` load from memory with acquire semantics.
  * `RCWCASL` and `RCWCASAL` store to memory with release semantics.
  * `RCWCAS` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCAS--RCWCASA--RCWCASL--RCWCASAL--Read-check-write-compare-and-swap-doubleword-in-memory-"
    )
    this["rcwcasal"] = OpCodeDoc(
        "RCWCASAL",
        """Read Check Write Compare and Swap doubleword in memory reads a 64-bit
doubleword from memory, and compares it against the value held in a register.
If the comparison is equal, the value in a second register is conditionally
written to memory. Storing back to memory is conditional on RCW Checks. If the
write is performed, the read and the write occur atomically such that no other
modification of the memory location can take place between the read and the
write. This instruction updates the condition flags based on the result of the
update of memory.

  * `RCWCASA` and `RCWCASAL` load from memory with acquire semantics.
  * `RCWCASL` and `RCWCASAL` store to memory with release semantics.
  * `RCWCAS` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCAS--RCWCASA--RCWCASL--RCWCASAL--Read-check-write-compare-and-swap-doubleword-in-memory-"
    )
    this["rcwcasl"] = OpCodeDoc(
        "RCWCASL",
        """Read Check Write Compare and Swap doubleword in memory reads a 64-bit
doubleword from memory, and compares it against the value held in a register.
If the comparison is equal, the value in a second register is conditionally
written to memory. Storing back to memory is conditional on RCW Checks. If the
write is performed, the read and the write occur atomically such that no other
modification of the memory location can take place between the read and the
write. This instruction updates the condition flags based on the result of the
update of memory.

  * `RCWCASA` and `RCWCASAL` load from memory with acquire semantics.
  * `RCWCASL` and `RCWCASAL` store to memory with release semantics.
  * `RCWCAS` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCAS--RCWCASA--RCWCASL--RCWCASAL--Read-check-write-compare-and-swap-doubleword-in-memory-"
    )
    this["rcwcasp"] = OpCodeDoc(
        "RCWCASP",
        """Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword
from memory, and compares it against the value held in a pair of registers. If
the comparison is equal, the value in a second pair of registers is
conditionally written to memory. Storing back to memory is conditional on RCW
Checks. If the write is performed, the read and the write occur atomically
such that no other modification of the memory location can take place between
the read and the write. This instruction updates the condition flags based on
the result of the update of memory.

  * `RCWCASPA` and `RCWCASPAL` load from memory with acquire semantics.
  * `RCWCASPL` and `RCWCASPAL` store to memory with release semantics.
  * `RCWCASP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCASP--RCWCASPA--RCWCASPL--RCWCASPAL--Read-check-write-compare-and-swap-quadword-in-memory-"
    )
    this["rcwcaspa"] = OpCodeDoc(
        "RCWCASPA",
        """Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword
from memory, and compares it against the value held in a pair of registers. If
the comparison is equal, the value in a second pair of registers is
conditionally written to memory. Storing back to memory is conditional on RCW
Checks. If the write is performed, the read and the write occur atomically
such that no other modification of the memory location can take place between
the read and the write. This instruction updates the condition flags based on
the result of the update of memory.

  * `RCWCASPA` and `RCWCASPAL` load from memory with acquire semantics.
  * `RCWCASPL` and `RCWCASPAL` store to memory with release semantics.
  * `RCWCASP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCASP--RCWCASPA--RCWCASPL--RCWCASPAL--Read-check-write-compare-and-swap-quadword-in-memory-"
    )
    this["rcwcaspal"] = OpCodeDoc(
        "RCWCASPAL",
        """Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword
from memory, and compares it against the value held in a pair of registers. If
the comparison is equal, the value in a second pair of registers is
conditionally written to memory. Storing back to memory is conditional on RCW
Checks. If the write is performed, the read and the write occur atomically
such that no other modification of the memory location can take place between
the read and the write. This instruction updates the condition flags based on
the result of the update of memory.

  * `RCWCASPA` and `RCWCASPAL` load from memory with acquire semantics.
  * `RCWCASPL` and `RCWCASPAL` store to memory with release semantics.
  * `RCWCASP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCASP--RCWCASPA--RCWCASPL--RCWCASPAL--Read-check-write-compare-and-swap-quadword-in-memory-"
    )
    this["rcwcaspl"] = OpCodeDoc(
        "RCWCASPL",
        """Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword
from memory, and compares it against the value held in a pair of registers. If
the comparison is equal, the value in a second pair of registers is
conditionally written to memory. Storing back to memory is conditional on RCW
Checks. If the write is performed, the read and the write occur atomically
such that no other modification of the memory location can take place between
the read and the write. This instruction updates the condition flags based on
the result of the update of memory.

  * `RCWCASPA` and `RCWCASPAL` load from memory with acquire semantics.
  * `RCWCASPL` and `RCWCASPAL` store to memory with release semantics.
  * `RCWCASP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCASP--RCWCASPA--RCWCASPL--RCWCASPAL--Read-check-write-compare-and-swap-quadword-in-memory-"
    )
    this["rcwclr"] = OpCodeDoc(
        "RCWCLR",
        """Read Check Write atomic bit Clear on doubleword in memory atomically loads a
64-bit doubleword from memory, performs a bitwise AND with the complement of
the value held in a register on it, and conditionally stores the result back
to memory. Storing of the result back to memory is conditional on RCW Checks.
The value initially loaded from memory is returned in the destination
register. This instruction updates the condition flags based on the result of
the update of memory.

  * `RCWCLRA` and `RCWCLRAL` load from memory with acquire semantics.
  * `RCWCLRL` and `RCWCLRAL` store to memory with release semantics.
  * `RCWCLR` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCLR--RCWCLRA--RCWCLRL--RCWCLRAL--Read-check-write-atomic-bit-clear-on-doubleword-in-memory-"
    )
    this["rcwclra"] = OpCodeDoc(
        "RCWCLRA",
        """Read Check Write atomic bit Clear on doubleword in memory atomically loads a
64-bit doubleword from memory, performs a bitwise AND with the complement of
the value held in a register on it, and conditionally stores the result back
to memory. Storing of the result back to memory is conditional on RCW Checks.
The value initially loaded from memory is returned in the destination
register. This instruction updates the condition flags based on the result of
the update of memory.

  * `RCWCLRA` and `RCWCLRAL` load from memory with acquire semantics.
  * `RCWCLRL` and `RCWCLRAL` store to memory with release semantics.
  * `RCWCLR` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCLR--RCWCLRA--RCWCLRL--RCWCLRAL--Read-check-write-atomic-bit-clear-on-doubleword-in-memory-"
    )
    this["rcwclral"] = OpCodeDoc(
        "RCWCLRAL",
        """Read Check Write atomic bit Clear on doubleword in memory atomically loads a
64-bit doubleword from memory, performs a bitwise AND with the complement of
the value held in a register on it, and conditionally stores the result back
to memory. Storing of the result back to memory is conditional on RCW Checks.
The value initially loaded from memory is returned in the destination
register. This instruction updates the condition flags based on the result of
the update of memory.

  * `RCWCLRA` and `RCWCLRAL` load from memory with acquire semantics.
  * `RCWCLRL` and `RCWCLRAL` store to memory with release semantics.
  * `RCWCLR` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCLR--RCWCLRA--RCWCLRL--RCWCLRAL--Read-check-write-atomic-bit-clear-on-doubleword-in-memory-"
    )
    this["rcwclrl"] = OpCodeDoc(
        "RCWCLRL",
        """Read Check Write atomic bit Clear on doubleword in memory atomically loads a
64-bit doubleword from memory, performs a bitwise AND with the complement of
the value held in a register on it, and conditionally stores the result back
to memory. Storing of the result back to memory is conditional on RCW Checks.
The value initially loaded from memory is returned in the destination
register. This instruction updates the condition flags based on the result of
the update of memory.

  * `RCWCLRA` and `RCWCLRAL` load from memory with acquire semantics.
  * `RCWCLRL` and `RCWCLRAL` store to memory with release semantics.
  * `RCWCLR` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCLR--RCWCLRA--RCWCLRL--RCWCLRAL--Read-check-write-atomic-bit-clear-on-doubleword-in-memory-"
    )
    this["rcwclrp"] = OpCodeDoc(
        "RCWCLRP",
        """Read Check Write atomic bit Clear on quadword in memory atomically loads a
128-bit quadword from memory, performs a bitwise AND with the complement of
the value held in a pair of registers on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks. The value initially loaded from memory is returned in the same
pair of registers. This instruction updates the condition flags based on the
result of the update of memory.

  * `RCWCLRPA` and `RCWCLRPAL` load from memory with acquire semantics.
  * `RCWCLRPL` and `RCWCLRPAL` store to memory with release semantics.
  * `RCWCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCLRP--RCWCLRPA--RCWCLRPL--RCWCLRPAL--Read-check-write-atomic-bit-clear-on-quadword-in-memory-"
    )
    this["rcwclrpa"] = OpCodeDoc(
        "RCWCLRPA",
        """Read Check Write atomic bit Clear on quadword in memory atomically loads a
128-bit quadword from memory, performs a bitwise AND with the complement of
the value held in a pair of registers on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks. The value initially loaded from memory is returned in the same
pair of registers. This instruction updates the condition flags based on the
result of the update of memory.

  * `RCWCLRPA` and `RCWCLRPAL` load from memory with acquire semantics.
  * `RCWCLRPL` and `RCWCLRPAL` store to memory with release semantics.
  * `RCWCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCLRP--RCWCLRPA--RCWCLRPL--RCWCLRPAL--Read-check-write-atomic-bit-clear-on-quadword-in-memory-"
    )
    this["rcwclrpal"] = OpCodeDoc(
        "RCWCLRPAL",
        """Read Check Write atomic bit Clear on quadword in memory atomically loads a
128-bit quadword from memory, performs a bitwise AND with the complement of
the value held in a pair of registers on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks. The value initially loaded from memory is returned in the same
pair of registers. This instruction updates the condition flags based on the
result of the update of memory.

  * `RCWCLRPA` and `RCWCLRPAL` load from memory with acquire semantics.
  * `RCWCLRPL` and `RCWCLRPAL` store to memory with release semantics.
  * `RCWCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCLRP--RCWCLRPA--RCWCLRPL--RCWCLRPAL--Read-check-write-atomic-bit-clear-on-quadword-in-memory-"
    )
    this["rcwclrpl"] = OpCodeDoc(
        "RCWCLRPL",
        """Read Check Write atomic bit Clear on quadword in memory atomically loads a
128-bit quadword from memory, performs a bitwise AND with the complement of
the value held in a pair of registers on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks. The value initially loaded from memory is returned in the same
pair of registers. This instruction updates the condition flags based on the
result of the update of memory.

  * `RCWCLRPA` and `RCWCLRPAL` load from memory with acquire semantics.
  * `RCWCLRPL` and `RCWCLRPAL` store to memory with release semantics.
  * `RCWCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWCLRP--RCWCLRPA--RCWCLRPL--RCWCLRPAL--Read-check-write-atomic-bit-clear-on-quadword-in-memory-"
    )
    this["rcwscas"] = OpCodeDoc(
        "RCWSCAS",
        """Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit
doubleword from memory, and compares it against the value held in a register.
If the comparison is equal, the value in a second register is conditionally
written to memory. Storing back to memory is conditional on RCW Checks and
RCWS Checks. If the write is performed, the read and the write occur
atomically such that no other modification of the memory location can take
place between the read and the write. This instruction updates the condition
flags based on the result of the update of memory.

  * `RCWSCASA` and `RCWSCASAL` load from memory with acquire semantics.
  * `RCWSCASL` and `RCWSCASAL` store to memory with release semantics.
  * `RCWSCAS` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCAS--RCWSCASA--RCWSCASL--RCWSCASAL--Read-check-write-software-compare-and-swap-doubleword-in-memory-"
    )
    this["rcwscasa"] = OpCodeDoc(
        "RCWSCASA",
        """Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit
doubleword from memory, and compares it against the value held in a register.
If the comparison is equal, the value in a second register is conditionally
written to memory. Storing back to memory is conditional on RCW Checks and
RCWS Checks. If the write is performed, the read and the write occur
atomically such that no other modification of the memory location can take
place between the read and the write. This instruction updates the condition
flags based on the result of the update of memory.

  * `RCWSCASA` and `RCWSCASAL` load from memory with acquire semantics.
  * `RCWSCASL` and `RCWSCASAL` store to memory with release semantics.
  * `RCWSCAS` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCAS--RCWSCASA--RCWSCASL--RCWSCASAL--Read-check-write-software-compare-and-swap-doubleword-in-memory-"
    )
    this["rcwscasal"] = OpCodeDoc(
        "RCWSCASAL",
        """Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit
doubleword from memory, and compares it against the value held in a register.
If the comparison is equal, the value in a second register is conditionally
written to memory. Storing back to memory is conditional on RCW Checks and
RCWS Checks. If the write is performed, the read and the write occur
atomically such that no other modification of the memory location can take
place between the read and the write. This instruction updates the condition
flags based on the result of the update of memory.

  * `RCWSCASA` and `RCWSCASAL` load from memory with acquire semantics.
  * `RCWSCASL` and `RCWSCASAL` store to memory with release semantics.
  * `RCWSCAS` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCAS--RCWSCASA--RCWSCASL--RCWSCASAL--Read-check-write-software-compare-and-swap-doubleword-in-memory-"
    )
    this["rcwscasl"] = OpCodeDoc(
        "RCWSCASL",
        """Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit
doubleword from memory, and compares it against the value held in a register.
If the comparison is equal, the value in a second register is conditionally
written to memory. Storing back to memory is conditional on RCW Checks and
RCWS Checks. If the write is performed, the read and the write occur
atomically such that no other modification of the memory location can take
place between the read and the write. This instruction updates the condition
flags based on the result of the update of memory.

  * `RCWSCASA` and `RCWSCASAL` load from memory with acquire semantics.
  * `RCWSCASL` and `RCWSCASAL` store to memory with release semantics.
  * `RCWSCAS` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCAS--RCWSCASA--RCWSCASL--RCWSCASAL--Read-check-write-software-compare-and-swap-doubleword-in-memory-"
    )
    this["rcwscasp"] = OpCodeDoc(
        "RCWSCASP",
        """Read Check Write Software Compare and Swap quadword in memory reads a 128-bit
quadword from memory, and compares it against the value held in a pair of
registers. If the comparison is equal, the value in a second pair of registers
is conditionally written to memory. Storing back to memory is conditional on
RCW Checks and RCWS Checks. If the write is performed, the read and the write
occur atomically such that no other modification of the memory location can
take place between the read and the write. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSCASPA` and `RCWSCASPAL` load from memory with acquire semantics.
  * `RCWSCASPL` and `RCWSCASPAL` store to memory with release semantics.
  * `RCWSCASP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCASP--RCWSCASPA--RCWSCASPL--RCWSCASPAL--Read-check-write-software-compare-and-swap-quadword-in-memory-"
    )
    this["rcwscaspa"] = OpCodeDoc(
        "RCWSCASPA",
        """Read Check Write Software Compare and Swap quadword in memory reads a 128-bit
quadword from memory, and compares it against the value held in a pair of
registers. If the comparison is equal, the value in a second pair of registers
is conditionally written to memory. Storing back to memory is conditional on
RCW Checks and RCWS Checks. If the write is performed, the read and the write
occur atomically such that no other modification of the memory location can
take place between the read and the write. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSCASPA` and `RCWSCASPAL` load from memory with acquire semantics.
  * `RCWSCASPL` and `RCWSCASPAL` store to memory with release semantics.
  * `RCWSCASP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCASP--RCWSCASPA--RCWSCASPL--RCWSCASPAL--Read-check-write-software-compare-and-swap-quadword-in-memory-"
    )
    this["rcwscaspal"] = OpCodeDoc(
        "RCWSCASPAL",
        """Read Check Write Software Compare and Swap quadword in memory reads a 128-bit
quadword from memory, and compares it against the value held in a pair of
registers. If the comparison is equal, the value in a second pair of registers
is conditionally written to memory. Storing back to memory is conditional on
RCW Checks and RCWS Checks. If the write is performed, the read and the write
occur atomically such that no other modification of the memory location can
take place between the read and the write. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSCASPA` and `RCWSCASPAL` load from memory with acquire semantics.
  * `RCWSCASPL` and `RCWSCASPAL` store to memory with release semantics.
  * `RCWSCASP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCASP--RCWSCASPA--RCWSCASPL--RCWSCASPAL--Read-check-write-software-compare-and-swap-quadword-in-memory-"
    )
    this["rcwscaspl"] = OpCodeDoc(
        "RCWSCASPL",
        """Read Check Write Software Compare and Swap quadword in memory reads a 128-bit
quadword from memory, and compares it against the value held in a pair of
registers. If the comparison is equal, the value in a second pair of registers
is conditionally written to memory. Storing back to memory is conditional on
RCW Checks and RCWS Checks. If the write is performed, the read and the write
occur atomically such that no other modification of the memory location can
take place between the read and the write. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSCASPA` and `RCWSCASPAL` load from memory with acquire semantics.
  * `RCWSCASPL` and `RCWSCASPAL` store to memory with release semantics.
  * `RCWSCASP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCASP--RCWSCASPA--RCWSCASPL--RCWSCASPAL--Read-check-write-software-compare-and-swap-quadword-in-memory-"
    )
    this["rcwsclr"] = OpCodeDoc(
        "RCWSCLR",
        """Read Check Write Software atomic bit Clear on doubleword in memory atomically
loads a 64-bit doubleword from memory, performs a bitwise AND with the
complement of the value held in a register on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks and RCWS Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSCLRA` and `RCWSCLRAL` load from memory with acquire semantics.
  * `RCWSCLRL` and `RCWSCLRAL` store to memory with release semantics.
  * `RCWSCLR` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCLR--RCWSCLRA--RCWSCLRL--RCWSCLRAL--Read-check-write-software-atomic-bit-clear-on-doubleword-in-memory-"
    )
    this["rcwsclra"] = OpCodeDoc(
        "RCWSCLRA",
        """Read Check Write Software atomic bit Clear on doubleword in memory atomically
loads a 64-bit doubleword from memory, performs a bitwise AND with the
complement of the value held in a register on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks and RCWS Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSCLRA` and `RCWSCLRAL` load from memory with acquire semantics.
  * `RCWSCLRL` and `RCWSCLRAL` store to memory with release semantics.
  * `RCWSCLR` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCLR--RCWSCLRA--RCWSCLRL--RCWSCLRAL--Read-check-write-software-atomic-bit-clear-on-doubleword-in-memory-"
    )
    this["rcwsclral"] = OpCodeDoc(
        "RCWSCLRAL",
        """Read Check Write Software atomic bit Clear on doubleword in memory atomically
loads a 64-bit doubleword from memory, performs a bitwise AND with the
complement of the value held in a register on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks and RCWS Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSCLRA` and `RCWSCLRAL` load from memory with acquire semantics.
  * `RCWSCLRL` and `RCWSCLRAL` store to memory with release semantics.
  * `RCWSCLR` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCLR--RCWSCLRA--RCWSCLRL--RCWSCLRAL--Read-check-write-software-atomic-bit-clear-on-doubleword-in-memory-"
    )
    this["rcwsclrl"] = OpCodeDoc(
        "RCWSCLRL",
        """Read Check Write Software atomic bit Clear on doubleword in memory atomically
loads a 64-bit doubleword from memory, performs a bitwise AND with the
complement of the value held in a register on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks and RCWS Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSCLRA` and `RCWSCLRAL` load from memory with acquire semantics.
  * `RCWSCLRL` and `RCWSCLRAL` store to memory with release semantics.
  * `RCWSCLR` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCLR--RCWSCLRA--RCWSCLRL--RCWSCLRAL--Read-check-write-software-atomic-bit-clear-on-doubleword-in-memory-"
    )
    this["rcwsclrp"] = OpCodeDoc(
        "RCWSCLRP",
        """Read Check Write Software atomic bit Clear on quadword in memory atomically
loads a 128-bit quadword from memory, performs a bitwise AND with the
complement of the value held in a pair of registers on it, and conditionally
stores the result back to memory. Storing of the result back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the same pair of registers. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSCLRPA` and `RCWSCLRPAL` load from memory with acquire semantics.
  * `RCWSCLRPL` and `RCWSCLRPAL` store to memory with release semantics.
  * `RCWSCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCLRP--RCWSCLRPA--RCWSCLRPL--RCWSCLRPAL--Read-check-write-software-atomic-bit-clear-on-quadword-in-memory-"
    )
    this["rcwsclrpa"] = OpCodeDoc(
        "RCWSCLRPA",
        """Read Check Write Software atomic bit Clear on quadword in memory atomically
loads a 128-bit quadword from memory, performs a bitwise AND with the
complement of the value held in a pair of registers on it, and conditionally
stores the result back to memory. Storing of the result back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the same pair of registers. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSCLRPA` and `RCWSCLRPAL` load from memory with acquire semantics.
  * `RCWSCLRPL` and `RCWSCLRPAL` store to memory with release semantics.
  * `RCWSCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCLRP--RCWSCLRPA--RCWSCLRPL--RCWSCLRPAL--Read-check-write-software-atomic-bit-clear-on-quadword-in-memory-"
    )
    this["rcwsclrpal"] = OpCodeDoc(
        "RCWSCLRPAL",
        """Read Check Write Software atomic bit Clear on quadword in memory atomically
loads a 128-bit quadword from memory, performs a bitwise AND with the
complement of the value held in a pair of registers on it, and conditionally
stores the result back to memory. Storing of the result back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the same pair of registers. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSCLRPA` and `RCWSCLRPAL` load from memory with acquire semantics.
  * `RCWSCLRPL` and `RCWSCLRPAL` store to memory with release semantics.
  * `RCWSCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCLRP--RCWSCLRPA--RCWSCLRPL--RCWSCLRPAL--Read-check-write-software-atomic-bit-clear-on-quadword-in-memory-"
    )
    this["rcwsclrpl"] = OpCodeDoc(
        "RCWSCLRPL",
        """Read Check Write Software atomic bit Clear on quadword in memory atomically
loads a 128-bit quadword from memory, performs a bitwise AND with the
complement of the value held in a pair of registers on it, and conditionally
stores the result back to memory. Storing of the result back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the same pair of registers. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSCLRPA` and `RCWSCLRPAL` load from memory with acquire semantics.
  * `RCWSCLRPL` and `RCWSCLRPAL` store to memory with release semantics.
  * `RCWSCLRP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSCLRP--RCWSCLRPA--RCWSCLRPL--RCWSCLRPAL--Read-check-write-software-atomic-bit-clear-on-quadword-in-memory-"
    )
    this["rcwset"] = OpCodeDoc(
        "RCWSET",
        """Read Check Write atomic bit Set on doubleword in memory atomically loads a
64-bit doubleword from memory, performs a bitwise OR with the complement of
the value held in a register on it, and conditionally stores the result back
to memory. Storing of the result back to memory is conditional on RCW Checks.
The value initially loaded from memory is returned in the destination
register. This instruction updates the condition flags based on the result of
the update of memory.

  * `RCWSETA` and `RCWSETAL` load from memory with acquire semantics.
  * `RCWSETL` and `RCWSETAL` store to memory with release semantics.
  * `RCWSET` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSET--RCWSETA--RCWSETL--RCWSETAL--Read-check-write-atomic-bit-set-on-doubleword-in-memory-"
    )
    this["rcwseta"] = OpCodeDoc(
        "RCWSETA",
        """Read Check Write atomic bit Set on doubleword in memory atomically loads a
64-bit doubleword from memory, performs a bitwise OR with the complement of
the value held in a register on it, and conditionally stores the result back
to memory. Storing of the result back to memory is conditional on RCW Checks.
The value initially loaded from memory is returned in the destination
register. This instruction updates the condition flags based on the result of
the update of memory.

  * `RCWSETA` and `RCWSETAL` load from memory with acquire semantics.
  * `RCWSETL` and `RCWSETAL` store to memory with release semantics.
  * `RCWSET` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSET--RCWSETA--RCWSETL--RCWSETAL--Read-check-write-atomic-bit-set-on-doubleword-in-memory-"
    )
    this["rcwsetal"] = OpCodeDoc(
        "RCWSETAL",
        """Read Check Write atomic bit Set on doubleword in memory atomically loads a
64-bit doubleword from memory, performs a bitwise OR with the complement of
the value held in a register on it, and conditionally stores the result back
to memory. Storing of the result back to memory is conditional on RCW Checks.
The value initially loaded from memory is returned in the destination
register. This instruction updates the condition flags based on the result of
the update of memory.

  * `RCWSETA` and `RCWSETAL` load from memory with acquire semantics.
  * `RCWSETL` and `RCWSETAL` store to memory with release semantics.
  * `RCWSET` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSET--RCWSETA--RCWSETL--RCWSETAL--Read-check-write-atomic-bit-set-on-doubleword-in-memory-"
    )
    this["rcwsetl"] = OpCodeDoc(
        "RCWSETL",
        """Read Check Write atomic bit Set on doubleword in memory atomically loads a
64-bit doubleword from memory, performs a bitwise OR with the complement of
the value held in a register on it, and conditionally stores the result back
to memory. Storing of the result back to memory is conditional on RCW Checks.
The value initially loaded from memory is returned in the destination
register. This instruction updates the condition flags based on the result of
the update of memory.

  * `RCWSETA` and `RCWSETAL` load from memory with acquire semantics.
  * `RCWSETL` and `RCWSETAL` store to memory with release semantics.
  * `RCWSET` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSET--RCWSETA--RCWSETL--RCWSETAL--Read-check-write-atomic-bit-set-on-doubleword-in-memory-"
    )
    this["rcwsetp"] = OpCodeDoc(
        "RCWSETP",
        """Read Check Write atomic bit Set on quadword in memory atomically loads a
128-bit quadword from memory, performs a bitwise OR with the value held in a
pair of registers on it, and conditionally stores the result back to memory.
Storing of the result back to memory is conditional on RCW Checks. The value
initially loaded from memory is returned in the same pair of registers. This
instruction updates the condition flags based on the result of the update of
memory.

  * `RCWSETPA` and `RCWSETPAL` load from memory with acquire semantics.
  * `RCWSETPL` and `RCWSETPAL` store to memory with release semantics.
  * `RCWSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSETP--RCWSETPA--RCWSETPL--RCWSETPAL--Read-check-write-atomic-bit-set-on-quadword-in-memory-"
    )
    this["rcwsetpa"] = OpCodeDoc(
        "RCWSETPA",
        """Read Check Write atomic bit Set on quadword in memory atomically loads a
128-bit quadword from memory, performs a bitwise OR with the value held in a
pair of registers on it, and conditionally stores the result back to memory.
Storing of the result back to memory is conditional on RCW Checks. The value
initially loaded from memory is returned in the same pair of registers. This
instruction updates the condition flags based on the result of the update of
memory.

  * `RCWSETPA` and `RCWSETPAL` load from memory with acquire semantics.
  * `RCWSETPL` and `RCWSETPAL` store to memory with release semantics.
  * `RCWSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSETP--RCWSETPA--RCWSETPL--RCWSETPAL--Read-check-write-atomic-bit-set-on-quadword-in-memory-"
    )
    this["rcwsetpal"] = OpCodeDoc(
        "RCWSETPAL",
        """Read Check Write atomic bit Set on quadword in memory atomically loads a
128-bit quadword from memory, performs a bitwise OR with the value held in a
pair of registers on it, and conditionally stores the result back to memory.
Storing of the result back to memory is conditional on RCW Checks. The value
initially loaded from memory is returned in the same pair of registers. This
instruction updates the condition flags based on the result of the update of
memory.

  * `RCWSETPA` and `RCWSETPAL` load from memory with acquire semantics.
  * `RCWSETPL` and `RCWSETPAL` store to memory with release semantics.
  * `RCWSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSETP--RCWSETPA--RCWSETPL--RCWSETPAL--Read-check-write-atomic-bit-set-on-quadword-in-memory-"
    )
    this["rcwsetpl"] = OpCodeDoc(
        "RCWSETPL",
        """Read Check Write atomic bit Set on quadword in memory atomically loads a
128-bit quadword from memory, performs a bitwise OR with the value held in a
pair of registers on it, and conditionally stores the result back to memory.
Storing of the result back to memory is conditional on RCW Checks. The value
initially loaded from memory is returned in the same pair of registers. This
instruction updates the condition flags based on the result of the update of
memory.

  * `RCWSETPA` and `RCWSETPAL` load from memory with acquire semantics.
  * `RCWSETPL` and `RCWSETPAL` store to memory with release semantics.
  * `RCWSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSETP--RCWSETPA--RCWSETPL--RCWSETPAL--Read-check-write-atomic-bit-set-on-quadword-in-memory-"
    )
    this["rcwsset"] = OpCodeDoc(
        "RCWSSET",
        """Read Check Write Software atomic bit Set on doubleword in memory atomically
loads a 64-bit doubleword from memory, performs a bitwise OR with the
complement of the value held in a register on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks and RCWS Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSSETA` and `RCWSSETAL` load from memory with acquire semantics.
  * `RCWSSETL` and `RCWSSETAL` store to memory with release semantics.
  * `RCWSSET` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSET--RCWSSETA--RCWSSETL--RCWSSETAL--Read-check-write-software-atomic-bit-set-on-doubleword-in-memory-"
    )
    this["rcwsseta"] = OpCodeDoc(
        "RCWSSETA",
        """Read Check Write Software atomic bit Set on doubleword in memory atomically
loads a 64-bit doubleword from memory, performs a bitwise OR with the
complement of the value held in a register on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks and RCWS Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSSETA` and `RCWSSETAL` load from memory with acquire semantics.
  * `RCWSSETL` and `RCWSSETAL` store to memory with release semantics.
  * `RCWSSET` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSET--RCWSSETA--RCWSSETL--RCWSSETAL--Read-check-write-software-atomic-bit-set-on-doubleword-in-memory-"
    )
    this["rcwssetal"] = OpCodeDoc(
        "RCWSSETAL",
        """Read Check Write Software atomic bit Set on doubleword in memory atomically
loads a 64-bit doubleword from memory, performs a bitwise OR with the
complement of the value held in a register on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks and RCWS Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSSETA` and `RCWSSETAL` load from memory with acquire semantics.
  * `RCWSSETL` and `RCWSSETAL` store to memory with release semantics.
  * `RCWSSET` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSET--RCWSSETA--RCWSSETL--RCWSSETAL--Read-check-write-software-atomic-bit-set-on-doubleword-in-memory-"
    )
    this["rcwssetl"] = OpCodeDoc(
        "RCWSSETL",
        """Read Check Write Software atomic bit Set on doubleword in memory atomically
loads a 64-bit doubleword from memory, performs a bitwise OR with the
complement of the value held in a register on it, and conditionally stores the
result back to memory. Storing of the result back to memory is conditional on
RCW Checks and RCWS Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSSETA` and `RCWSSETAL` load from memory with acquire semantics.
  * `RCWSSETL` and `RCWSSETAL` store to memory with release semantics.
  * `RCWSSET` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSET--RCWSSETA--RCWSSETL--RCWSSETAL--Read-check-write-software-atomic-bit-set-on-doubleword-in-memory-"
    )
    this["rcwssetp"] = OpCodeDoc(
        "RCWSSETP",
        """Read Check Write Software atomic bit Set on quadword in memory atomically
loads a 128-bit quadword from memory, performs a bitwise OR with the value
held in a pair of registers on it, and conditionally stores the result back to
memory. Storing of the result back to memory is conditional on RCW Checks and
RCWS Checks. The value initially loaded from memory is returned in the same
pair of registers. This instruction updates the condition flags based on the
result of the update of memory.

  * `RCWSSETPA` and `RCWSSETPAL` load from memory with acquire semantics.
  * `RCWSSETPL` and `RCWSSETPAL` store to memory with release semantics.
  * `RCWSSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSETP--RCWSSETPA--RCWSSETPL--RCWSSETPAL--Read-check-write-software-atomic-bit-set-on-quadword-in-memory-"
    )
    this["rcwssetpa"] = OpCodeDoc(
        "RCWSSETPA",
        """Read Check Write Software atomic bit Set on quadword in memory atomically
loads a 128-bit quadword from memory, performs a bitwise OR with the value
held in a pair of registers on it, and conditionally stores the result back to
memory. Storing of the result back to memory is conditional on RCW Checks and
RCWS Checks. The value initially loaded from memory is returned in the same
pair of registers. This instruction updates the condition flags based on the
result of the update of memory.

  * `RCWSSETPA` and `RCWSSETPAL` load from memory with acquire semantics.
  * `RCWSSETPL` and `RCWSSETPAL` store to memory with release semantics.
  * `RCWSSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSETP--RCWSSETPA--RCWSSETPL--RCWSSETPAL--Read-check-write-software-atomic-bit-set-on-quadword-in-memory-"
    )
    this["rcwssetpal"] = OpCodeDoc(
        "RCWSSETPAL",
        """Read Check Write Software atomic bit Set on quadword in memory atomically
loads a 128-bit quadword from memory, performs a bitwise OR with the value
held in a pair of registers on it, and conditionally stores the result back to
memory. Storing of the result back to memory is conditional on RCW Checks and
RCWS Checks. The value initially loaded from memory is returned in the same
pair of registers. This instruction updates the condition flags based on the
result of the update of memory.

  * `RCWSSETPA` and `RCWSSETPAL` load from memory with acquire semantics.
  * `RCWSSETPL` and `RCWSSETPAL` store to memory with release semantics.
  * `RCWSSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSETP--RCWSSETPA--RCWSSETPL--RCWSSETPAL--Read-check-write-software-atomic-bit-set-on-quadword-in-memory-"
    )
    this["rcwssetpl"] = OpCodeDoc(
        "RCWSSETPL",
        """Read Check Write Software atomic bit Set on quadword in memory atomically
loads a 128-bit quadword from memory, performs a bitwise OR with the value
held in a pair of registers on it, and conditionally stores the result back to
memory. Storing of the result back to memory is conditional on RCW Checks and
RCWS Checks. The value initially loaded from memory is returned in the same
pair of registers. This instruction updates the condition flags based on the
result of the update of memory.

  * `RCWSSETPA` and `RCWSSETPAL` load from memory with acquire semantics.
  * `RCWSSETPL` and `RCWSSETPAL` store to memory with release semantics.
  * `RCWSSETP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSETP--RCWSSETPA--RCWSSETPL--RCWSSETPAL--Read-check-write-software-atomic-bit-set-on-quadword-in-memory-"
    )
    this["rcwsswp"] = OpCodeDoc(
        "RCWSSWP",
        """Read Check Write Software Swap doubleword in memory atomically loads a 64-bit
doubleword from a memory location, and conditionally stores the value held in
a register back to the same memory location. Storing back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the destination register. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSSWPA` and `RCWSSWPAL` load from memory with acquire semantics.
  * `RCWSSWPL` and `RCWSSWPAL` store to memory with release semantics.
  * `RCWSSWP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSWP--RCWSSWPA--RCWSSWPL--RCWSSWPAL--Read-check-write-software-swap-doubleword-in-memory-"
    )
    this["rcwsswpa"] = OpCodeDoc(
        "RCWSSWPA",
        """Read Check Write Software Swap doubleword in memory atomically loads a 64-bit
doubleword from a memory location, and conditionally stores the value held in
a register back to the same memory location. Storing back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the destination register. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSSWPA` and `RCWSSWPAL` load from memory with acquire semantics.
  * `RCWSSWPL` and `RCWSSWPAL` store to memory with release semantics.
  * `RCWSSWP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSWP--RCWSSWPA--RCWSSWPL--RCWSSWPAL--Read-check-write-software-swap-doubleword-in-memory-"
    )
    this["rcwsswpal"] = OpCodeDoc(
        "RCWSSWPAL",
        """Read Check Write Software Swap doubleword in memory atomically loads a 64-bit
doubleword from a memory location, and conditionally stores the value held in
a register back to the same memory location. Storing back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the destination register. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSSWPA` and `RCWSSWPAL` load from memory with acquire semantics.
  * `RCWSSWPL` and `RCWSSWPAL` store to memory with release semantics.
  * `RCWSSWP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSWP--RCWSSWPA--RCWSSWPL--RCWSSWPAL--Read-check-write-software-swap-doubleword-in-memory-"
    )
    this["rcwsswpl"] = OpCodeDoc(
        "RCWSSWPL",
        """Read Check Write Software Swap doubleword in memory atomically loads a 64-bit
doubleword from a memory location, and conditionally stores the value held in
a register back to the same memory location. Storing back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the destination register. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSSWPA` and `RCWSSWPAL` load from memory with acquire semantics.
  * `RCWSSWPL` and `RCWSSWPAL` store to memory with release semantics.
  * `RCWSSWP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSWP--RCWSSWPA--RCWSSWPL--RCWSSWPAL--Read-check-write-software-swap-doubleword-in-memory-"
    )
    this["rcwsswpp"] = OpCodeDoc(
        "RCWSSWPP",
        """Read Check Write Software Swap quadword in memory atomically loads a 128-bit
quadword from a memory location, and conditionally stores the value held in a
pair of registers back to the same memory location. Storing back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the same pair of registers. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSSWPPA` and `RCWSSWPPAL` load from memory with acquire semantics.
  * `RCWSSWPPL` and `RCWSSWPPAL` store to memory with release semantics.
  * `RCWSSWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSWPP--RCWSSWPPA--RCWSSWPPL--RCWSSWPPAL--Read-check-write-software-swap-quadword-in-memory-"
    )
    this["rcwsswppa"] = OpCodeDoc(
        "RCWSSWPPA",
        """Read Check Write Software Swap quadword in memory atomically loads a 128-bit
quadword from a memory location, and conditionally stores the value held in a
pair of registers back to the same memory location. Storing back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the same pair of registers. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSSWPPA` and `RCWSSWPPAL` load from memory with acquire semantics.
  * `RCWSSWPPL` and `RCWSSWPPAL` store to memory with release semantics.
  * `RCWSSWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSWPP--RCWSSWPPA--RCWSSWPPL--RCWSSWPPAL--Read-check-write-software-swap-quadword-in-memory-"
    )
    this["rcwsswppal"] = OpCodeDoc(
        "RCWSSWPPAL",
        """Read Check Write Software Swap quadword in memory atomically loads a 128-bit
quadword from a memory location, and conditionally stores the value held in a
pair of registers back to the same memory location. Storing back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the same pair of registers. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSSWPPA` and `RCWSSWPPAL` load from memory with acquire semantics.
  * `RCWSSWPPL` and `RCWSSWPPAL` store to memory with release semantics.
  * `RCWSSWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSWPP--RCWSSWPPA--RCWSSWPPL--RCWSSWPPAL--Read-check-write-software-swap-quadword-in-memory-"
    )
    this["rcwsswppl"] = OpCodeDoc(
        "RCWSSWPPL",
        """Read Check Write Software Swap quadword in memory atomically loads a 128-bit
quadword from a memory location, and conditionally stores the value held in a
pair of registers back to the same memory location. Storing back to memory is
conditional on RCW Checks and RCWS Checks. The value initially loaded from
memory is returned in the same pair of registers. This instruction updates the
condition flags based on the result of the update of memory.

  * `RCWSSWPPA` and `RCWSSWPPAL` load from memory with acquire semantics.
  * `RCWSSWPPL` and `RCWSSWPPAL` store to memory with release semantics.
  * `RCWSSWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSSWPP--RCWSSWPPA--RCWSSWPPL--RCWSSWPPAL--Read-check-write-software-swap-quadword-in-memory-"
    )
    this["rcwswp"] = OpCodeDoc(
        "RCWSWP",
        """Read Check Write Swap doubleword in memory atomically loads a 64-bit
doubleword from a memory location, and conditionally stores the value held in
a register back to the same memory location. Storing back to memory is
conditional on RCW Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSWPA` and `RCWSWPAL` load from memory with acquire semantics.
  * `RCWSWPL` and `RCWSWPAL` store to memory with release semantics.
  * `RCWSWP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSWP--RCWSWPA--RCWSWPL--RCWSWPAL--Read-check-write-swap-doubleword-in-memory-"
    )
    this["rcwswpa"] = OpCodeDoc(
        "RCWSWPA",
        """Read Check Write Swap doubleword in memory atomically loads a 64-bit
doubleword from a memory location, and conditionally stores the value held in
a register back to the same memory location. Storing back to memory is
conditional on RCW Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSWPA` and `RCWSWPAL` load from memory with acquire semantics.
  * `RCWSWPL` and `RCWSWPAL` store to memory with release semantics.
  * `RCWSWP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSWP--RCWSWPA--RCWSWPL--RCWSWPAL--Read-check-write-swap-doubleword-in-memory-"
    )
    this["rcwswpal"] = OpCodeDoc(
        "RCWSWPAL",
        """Read Check Write Swap doubleword in memory atomically loads a 64-bit
doubleword from a memory location, and conditionally stores the value held in
a register back to the same memory location. Storing back to memory is
conditional on RCW Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSWPA` and `RCWSWPAL` load from memory with acquire semantics.
  * `RCWSWPL` and `RCWSWPAL` store to memory with release semantics.
  * `RCWSWP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSWP--RCWSWPA--RCWSWPL--RCWSWPAL--Read-check-write-swap-doubleword-in-memory-"
    )
    this["rcwswpl"] = OpCodeDoc(
        "RCWSWPL",
        """Read Check Write Swap doubleword in memory atomically loads a 64-bit
doubleword from a memory location, and conditionally stores the value held in
a register back to the same memory location. Storing back to memory is
conditional on RCW Checks. The value initially loaded from memory is returned
in the destination register. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSWPA` and `RCWSWPAL` load from memory with acquire semantics.
  * `RCWSWPL` and `RCWSWPAL` store to memory with release semantics.
  * `RCWSWP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSWP--RCWSWPA--RCWSWPL--RCWSWPAL--Read-check-write-swap-doubleword-in-memory-"
    )
    this["rcwswpp"] = OpCodeDoc(
        "RCWSWPP",
        """Read Check Write Swap quadword in memory atomically loads a 128-bit quadword
from a memory location, and conditionally stores the value held in a pair of
registers back to the same memory location. Storing back to memory is
conditional on RCW Checks. The value initially loaded from memory is returned
in the same pair of registers. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSWPPA` and `RCWSWPPAL` load from memory with acquire semantics.
  * `RCWSWPPL` and `RCWSWPPAL` store to memory with release semantics.
  * `RCWSWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSWPP--RCWSWPPA--RCWSWPPL--RCWSWPPAL--Read-check-write-swap-quadword-in-memory-"
    )
    this["rcwswppa"] = OpCodeDoc(
        "RCWSWPPA",
        """Read Check Write Swap quadword in memory atomically loads a 128-bit quadword
from a memory location, and conditionally stores the value held in a pair of
registers back to the same memory location. Storing back to memory is
conditional on RCW Checks. The value initially loaded from memory is returned
in the same pair of registers. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSWPPA` and `RCWSWPPAL` load from memory with acquire semantics.
  * `RCWSWPPL` and `RCWSWPPAL` store to memory with release semantics.
  * `RCWSWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSWPP--RCWSWPPA--RCWSWPPL--RCWSWPPAL--Read-check-write-swap-quadword-in-memory-"
    )
    this["rcwswppal"] = OpCodeDoc(
        "RCWSWPPAL",
        """Read Check Write Swap quadword in memory atomically loads a 128-bit quadword
from a memory location, and conditionally stores the value held in a pair of
registers back to the same memory location. Storing back to memory is
conditional on RCW Checks. The value initially loaded from memory is returned
in the same pair of registers. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSWPPA` and `RCWSWPPAL` load from memory with acquire semantics.
  * `RCWSWPPL` and `RCWSWPPAL` store to memory with release semantics.
  * `RCWSWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSWPP--RCWSWPPA--RCWSWPPL--RCWSWPPAL--Read-check-write-swap-quadword-in-memory-"
    )
    this["rcwswppl"] = OpCodeDoc(
        "RCWSWPPL",
        """Read Check Write Swap quadword in memory atomically loads a 128-bit quadword
from a memory location, and conditionally stores the value held in a pair of
registers back to the same memory location. Storing back to memory is
conditional on RCW Checks. The value initially loaded from memory is returned
in the same pair of registers. This instruction updates the condition flags
based on the result of the update of memory.

  * `RCWSWPPA` and `RCWSWPPAL` load from memory with acquire semantics.
  * `RCWSWPPL` and `RCWSWPPAL` store to memory with release semantics.
  * `RCWSWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RCWSWPP--RCWSWPPA--RCWSWPPL--RCWSWPPAL--Read-check-write-swap-quadword-in-memory-"
    )
    this["rdffr"] = OpCodeDoc(
        "RDFFR",
        """Read the first-fault register (FFR) and place in the destination predicate
without predication.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RDFFR--unpredicated----"
    )
    this["rdffrs"] = OpCodeDoc(
        "RDFFRS",
        """Read the first-fault register (FFR) and place active elements in the
corresponding elements of the destination predicate. Inactive elements in the
destination predicate register are set to zero. Sets the First (N), None (Z),
!Last (C) condition flags based on the predicate result, and the V flag to
zero.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RDFFRS---"
    )
    this["rdsvl"] = OpCodeDoc(
        "RDSVL",
        """Multiply the Streaming SVE vector register size in bytes by an immediate in
the range -32 to 31 and place the result in the 64-bit destination general-
purpose register.

This instruction does not require the PE to be in Streaming SVE mode.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RDSVL---"
    )
    this["rdvl"] = OpCodeDoc(
        "RDVL",
        """Multiply the current vector register size in bytes by an immediate in the
range -32 to 31 and place the result in the 64-bit destination general-purpose
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RDVL---"
    )
    this["ret"] = OpCodeDoc(
        "RET",
        """Return from subroutine branches unconditionally to an address in a register,
with a hint that this is a subroutine return.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RET--Return-from-subroutine-"
    )
    this["retaa"] = OpCodeDoc(
        "RETAA",
        """Return from subroutine, with pointer authentication. This instruction
authenticates the address that is held in LR, using SP as the modifier and the
specified key, branches to the authenticated address, with a hint that this
instruction is a subroutine return.

Key A is used for `RETAA`. Key B is used for `RETAB`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to LR.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RETAA--RETAB--Return-from-subroutine--with-pointer-authentication-"
    )
    this["retab"] = OpCodeDoc(
        "RETAB",
        """Return from subroutine, with pointer authentication. This instruction
authenticates the address that is held in LR, using SP as the modifier and the
specified key, branches to the authenticated address, with a hint that this
instruction is a subroutine return.

Key A is used for `RETAA`. Key B is used for `RETAB`.

If the authentication passes, the PE continues execution at the target of the
branch. For information on behavior if the authentication fails, see Faulting
on pointer authentication.

The authenticated address is not written back to LR.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RETAA--RETAB--Return-from-subroutine--with-pointer-authentication-"
    )
    this["rev"] = OpCodeDoc(
        "REV",
        """Reverse Bytes reverses the byte order in a register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/REV--Reverse-bytes-"
    )
    this["rev16"] = OpCodeDoc(
        "REV16",
        """Reverse elements in 16-bit halfwords (vector). This instruction reverses the
order of 8-bit elements in each halfword of the vector in the source SIMD&FP
register, places the results into a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/REV----vector---Reverse-elements-in----bit-halfwords--vector--"
    )
    this["rev32"] = OpCodeDoc(
        "REV32",
        """Reverse elements in 32-bit words (vector). This instruction reverses the order
of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP
register, places the results into a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/REV----vector---Reverse-elements-in----bit-words--vector--"
    )
    this["rev64"] = OpCodeDoc(
        "REV64",
        """Reverse elements in 64-bit doublewords (vector). This instruction reverses the
order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in
the source SIMD&FP register, places the results into a vector, and writes the
vector to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/REV----Reverse-elements-in----bit-doublewords--vector--"
    )
    this["revb"] = OpCodeDoc(
        "REVB",
        """Reverse the order of 8-bit bytes, 16-bit halfwords or 32-bit words within each
active element of the source vector, and place the results in the
corresponding elements of the destination vector. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/REVB--REVH--REVW---"
    )
    this["revh"] = OpCodeDoc(
        "REVH",
        """Reverse the order of 8-bit bytes, 16-bit halfwords or 32-bit words within each
active element of the source vector, and place the results in the
corresponding elements of the destination vector. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/REVB--REVH--REVW---"
    )
    this["revw"] = OpCodeDoc(
        "REVW",
        """Reverse the order of 8-bit bytes, 16-bit halfwords or 32-bit words within each
active element of the source vector, and place the results in the
corresponding elements of the destination vector. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/REVB--REVH--REVW---"
    )
    this["revd"] = OpCodeDoc(
        "REVD",
        """Reverse the order of 64-bit doublewords within each active element of the
source vector, and place the results in the corresponding elements of the
destination vector. Inactive elements in the destination vector register
remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/REVD---"
    )
    this["rmif"] = OpCodeDoc(
        "RMIF",
        """Performs a rotation right of a value held in a general purpose register by an
immediate value, and then inserts a selection of the bottom four bits of the
result of the rotation into the PSTATE flags, under the control of a second
immediate mask.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RMIF--Rotate--mask-insert-flags-"
    )
    this["ror"] = OpCodeDoc(
        "ROR",
        """Rotate right (immediate) provides the value of the contents of a register
rotated by a variable number of bits. The bits that are rotated off the right
end are inserted into the vacated bit positions on the left.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ROR--immediate---Rotate-right--immediate--"
    )
    this["ror"] = OpCodeDoc(
        "ROR",
        """Rotate Right (register) provides the value of the contents of a register
rotated by a variable number of bits. The bits that are rotated off the right
end are inserted into the vacated bit positions on the left. The remainder
obtained by dividing the second source register by the data size defines the
number of bits by which the first source register is right-shifted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ROR--register---Rotate-right--register--"
    )
    this["rorv"] = OpCodeDoc(
        "RORV",
        """Rotate Right Variable provides the value of the contents of a register rotated
by a variable number of bits. The bits that are rotated off the right end are
inserted into the vacated bit positions on the left. The remainder obtained by
dividing the second source register by the data size defines the number of
bits by which the first source register is right-shifted.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RORV--Rotate-right-variable-"
    )
    this["rprfm"] = OpCodeDoc(
        "RPRFM",
        """Range Prefetch Memory signals the memory system that data memory accesses from
a specified range of addresses are likely to occur in the near future. The
instruction may also signal the memory system about the likelihood of data
reuse of the specified range of addresses. The memory system can respond by
taking actions that are expected to speed up the memory accesses when they do
occur, such as prefetching locations within the specified address ranges into
one or more caches. The memory system may also exploit the data reuse hints to
decide whether to retain the data in other caches upon eviction from the
innermost caches or to discard it.

The effect of an `RPRFM` instruction is implementation defined, but because
these signals are only hints, the instruction cannot cause a synchronous Data
Abort exception and is guaranteed not to access Device memory. It is valid for
the PE to treat this instruction as a NOP.

An `RPRFM` instruction specifies the type of accesses and range of addresses
using the following parameters:

  * 'Type', in the <rprfop> operand opcode bits, specifies whether the prefetched data will be accessed by load or store instructions.
  * 'Policy', in the <rprfop> operand opcode bits, specifies whether the data is likely to be reused or if it is a streaming, non-temporal prefetch. If a streaming prefetch is specified, then the 'ReuseDistance' parameter is ignored.
  * 'BaseAddress', in the 64-bit base register, holds the initial block address for the accesses.
  * 'ReuseDistance', in the metadata register bits[63:60], indicates the maximum number of bytes to be accessed by this PE before executing the next `RPRFM` instruction that specifies the same range. This includes the total number of bytes inside and outside of the range that will be accessed by the same PE. This parameter can be used to influence cache eviction and replacement policies, in order to retain the data in the most optimal levels of the memory hierarchy after each access. If software cannot easily determine the amount of other memory that will be accessed, these bits can be set to zero to indicate that 'ReuseDistance' is not known. Otherwise, these four bits encode decreasing powers of two in the range 512MiB (0b0001) to 32KiB (0b1111).
  * 'Stride', in the metadata register bits[59:38], is a signed, two's complement integer encoding of the number of bytes to advance the block address after 'Length' bytes have been accessed, in the range -2MiB to +2MiB-1B. A negative value indicates that the block address is advanced in a descending direction.
  * 'Count', in the metadata register bits[37:22], is an unsigned integer encoding of the number of blocks of data to be accessed minus 1, representing the range 1 to 65536 blocks. If 'Count' is 0, then the 'Stride' parameter is ignored and only a single block of contiguous bytes from 'BaseAddress' to ('BaseAddress' + 'Length' - 1) is described.
  * 'Length', in the metadata register bits[21:0], is a signed, two's complement integer encoding of the number of contiguous bytes to be accessed starting from the current block address, without changing the block address, in the range -2MiB to +2MiB-1B. A negative value indicates that the bytes are accessed in a descending direction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RPRFM--Range-prefetch-memory-"
    )
    this["rshrn"] = OpCodeDoc(
        "RSHRN",
        """Rounding Shift Right Narrow (immediate). This instruction reads each unsigned
integer value from the vector in the source SIMD&FP register, right shifts
each result by an immediate value, writes the final result to a vector, and
writes the vector to the lower or upper half of the destination SIMD&FP
register. The destination vector elements are half as long as the source
vector elements. The results are rounded. For truncated results, see SHRN.

The `RSHRN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `RSHRN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RSHRN--RSHRN---Rounding-shift-right-narrow--immediate--"
    )
    this["rshrn2"] = OpCodeDoc(
        "RSHRN2",
        """Rounding Shift Right Narrow (immediate). This instruction reads each unsigned
integer value from the vector in the source SIMD&FP register, right shifts
each result by an immediate value, writes the final result to a vector, and
writes the vector to the lower or upper half of the destination SIMD&FP
register. The destination vector elements are half as long as the source
vector elements. The results are rounded. For truncated results, see SHRN.

The `RSHRN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `RSHRN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RSHRN--RSHRN---Rounding-shift-right-narrow--immediate--"
    )
    this["rshrnb"] = OpCodeDoc(
        "RSHRNB",
        """Shift each unsigned integer value in the source vector elements right by an
immediate value, and place the rounded results in the even-numbered half-width
destination elements, while setting the odd-numbered elements to zero. The
immediate shift amount is an unsigned value in the range 1 to number of bits
per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RSHRNB---"
    )
    this["rshrnt"] = OpCodeDoc(
        "RSHRNT",
        """Shift each unsigned integer value in the source vector elements right by an
immediate value, and place the rounded results in the odd-numbered half-width
destination elements, leaving the even-numbered elements unchanged. The
immediate shift amount is an unsigned value in the range 1 to number of bits
per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RSHRNT---"
    )
    this["rsubhn"] = OpCodeDoc(
        "RSUBHN",
        """Rounding Subtract returning High Narrow. This instruction subtracts each
vector element of the second source SIMD&FP register from the corresponding
vector element of the first source SIMD&FP register, places the most
significant half of the result into a vector, and writes the vector to the
lower or upper half of the destination SIMD&FP register.

The results are rounded. For truncated results, see SUBHN.

The `RSUBHN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `RSUBHN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RSUBHN--RSUBHN---Rounding-subtract-returning-high-narrow-"
    )
    this["rsubhn2"] = OpCodeDoc(
        "RSUBHN2",
        """Rounding Subtract returning High Narrow. This instruction subtracts each
vector element of the second source SIMD&FP register from the corresponding
vector element of the first source SIMD&FP register, places the most
significant half of the result into a vector, and writes the vector to the
lower or upper half of the destination SIMD&FP register.

The results are rounded. For truncated results, see SUBHN.

The `RSUBHN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `RSUBHN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RSUBHN--RSUBHN---Rounding-subtract-returning-high-narrow-"
    )
    this["rsubhnb"] = OpCodeDoc(
        "RSUBHNB",
        """Subtract each vector element of the second source vector from the
corresponding vector element in the first source vector, and place the most
significant rounded half of the result in the even-numbered half-width
destination elements, while setting the odd-numbered half-width destination
elements to zero. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RSUBHNB---"
    )
    this["rsubhnt"] = OpCodeDoc(
        "RSUBHNT",
        """Subtract each vector element of the second source vector from the
corresponding vector element in the first source vector, and place the most
significant rounded half of the result in the odd-numbered half-width
destination elements, leaving the even-numbered elements unchanged. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/RSUBHNT---"
    )
    this["saba"] = OpCodeDoc(
        "SABA",
        """Signed Absolute difference and Accumulate. This instruction subtracts the
elements of the vector of the second source SIMD&FP register from the
corresponding elements of the first source SIMD&FP register, and accumulates
the absolute values of the results into the elements of the vector of the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABA--Signed-absolute-difference-and-accumulate-"
    )
    this["sabal"] = OpCodeDoc(
        "SABAL",
        """Signed Absolute difference and Accumulate Long. This instruction subtracts the
vector elements in the lower or upper half of the second source SIMD&FP
register from the corresponding vector elements of the first source SIMD&FP
register, and accumulates the absolute values of the results into the vector
elements of the destination SIMD&FP register. The destination vector elements
are twice as long as the source vector elements.

The `SABAL` instruction extracts each source vector from the lower half of
each source register. The `SABAL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABAL--SABAL---Signed-absolute-difference-and-accumulate-long-"
    )
    this["sabal2"] = OpCodeDoc(
        "SABAL2",
        """Signed Absolute difference and Accumulate Long. This instruction subtracts the
vector elements in the lower or upper half of the second source SIMD&FP
register from the corresponding vector elements of the first source SIMD&FP
register, and accumulates the absolute values of the results into the vector
elements of the destination SIMD&FP register. The destination vector elements
are twice as long as the source vector elements.

The `SABAL` instruction extracts each source vector from the lower half of
each source register. The `SABAL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABAL--SABAL---Signed-absolute-difference-and-accumulate-long-"
    )
    this["sabalb"] = OpCodeDoc(
        "SABALB",
        """Compute the absolute difference between even-numbered signed integer values in
elements of the second source vector and corresponding elements of the first
source vector, and destructively add to the overlapping double-width elements
of the addend vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABALB---"
    )
    this["sabalt"] = OpCodeDoc(
        "SABALT",
        """Compute the absolute difference between odd-numbered signed elements of the
second source vector and corresponding elements of the first source vector,
and destructively add to the overlapping double-width elements of the addend
vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABALT---"
    )
    this["sabd"] = OpCodeDoc(
        "SABD",
        """Signed Absolute Difference. This instruction subtracts the elements of the
vector of the second source SIMD&FP register from the corresponding elements
of the first source SIMD&FP register, places the absolute values of the
results into a vector, and writes the vector to the destination SIMD&FP
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABD--Signed-absolute-difference-"
    )
    this["sabdl"] = OpCodeDoc(
        "SABDL",
        """Signed Absolute Difference Long. This instruction subtracts the vector
elements in the lower or upper half of the second source SIMD&FP register from
the corresponding vector elements of the first source SIMD&FP register, places
the absolute value of the results into a vector, and writes the vector to the
destination SIMD&FP register. The destination vector elements are twice as
long as the source vector elements.

The `SABDL` instruction extracts each source vector from the lower half of
each source register. The `SABDL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABDL--SABDL---Signed-absolute-difference-long-"
    )
    this["sabdl2"] = OpCodeDoc(
        "SABDL2",
        """Signed Absolute Difference Long. This instruction subtracts the vector
elements in the lower or upper half of the second source SIMD&FP register from
the corresponding vector elements of the first source SIMD&FP register, places
the absolute value of the results into a vector, and writes the vector to the
destination SIMD&FP register. The destination vector elements are twice as
long as the source vector elements.

The `SABDL` instruction extracts each source vector from the lower half of
each source register. The `SABDL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABDL--SABDL---Signed-absolute-difference-long-"
    )
    this["sabdlb"] = OpCodeDoc(
        "SABDLB",
        """Compute the absolute difference between even-numbered signed integer values in
elements of the second source vector and corresponding elements of the first
source vector, and place the results in the overlapping double-width elements
of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABDLB---"
    )
    this["sabdlt"] = OpCodeDoc(
        "SABDLT",
        """Compute the absolute difference between odd-numbered signed integer values in
elements of the second source vector and corresponding elements of the first
source vector, and place the results in overlapping double-width elements of
the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SABDLT---"
    )
    this["sadalp"] = OpCodeDoc(
        "SADALP",
        """Signed Add and Accumulate Long Pairwise. This instruction adds pairs of
adjacent signed integer values from the vector in the source SIMD&FP register
and accumulates the results into the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the
source vector elements.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADALP--Signed-add-and-accumulate-long-pairwise-"
    )
    this["saddl"] = OpCodeDoc(
        "SADDL",
        """Signed Add Long (vector). This instruction adds each vector element in the
lower or upper half of the first source SIMD&FP register to the corresponding
vector element of the second source SIMD&FP register, places the results into
a vector, and writes the vector to the destination SIMD&FP register. The
destination vector elements are twice as long as the source vector elements.
All the values in this instruction are signed integer values.

The `SADDL` instruction extracts each source vector from the lower half of
each source register. The `SADDL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDL--SADDL---Signed-add-long--vector--"
    )
    this["saddl2"] = OpCodeDoc(
        "SADDL2",
        """Signed Add Long (vector). This instruction adds each vector element in the
lower or upper half of the first source SIMD&FP register to the corresponding
vector element of the second source SIMD&FP register, places the results into
a vector, and writes the vector to the destination SIMD&FP register. The
destination vector elements are twice as long as the source vector elements.
All the values in this instruction are signed integer values.

The `SADDL` instruction extracts each source vector from the lower half of
each source register. The `SADDL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDL--SADDL---Signed-add-long--vector--"
    )
    this["saddlb"] = OpCodeDoc(
        "SADDLB",
        """Add the corresponding even-numbered signed elements of the first and second
source vectors, and place the results in the overlapping double-width elements
of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDLB---"
    )
    this["saddlbt"] = OpCodeDoc(
        "SADDLBT",
        """Add the even-numbered signed elements of the first source vector to the odd-
numbered signed elements of the second source vector, and place the results in
the overlapping double-width elements of the destination vector. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDLBT---"
    )
    this["saddlp"] = OpCodeDoc(
        "SADDLP",
        """Signed Add Long Pairwise. This instruction adds pairs of adjacent signed
integer values from the vector in the source SIMD&FP register, places the
result into a vector, and writes the vector to the destination SIMD&FP
register. The destination vector elements are twice as long as the source
vector elements.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDLP--Signed-add-long-pairwise-"
    )
    this["saddlt"] = OpCodeDoc(
        "SADDLT",
        """Add the corresponding odd-numbered signed elements of the first and second
source vectors, and place the results in the overlapping double-width elements
of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDLT---"
    )
    this["saddlv"] = OpCodeDoc(
        "SADDLV",
        """Signed Add Long across Vector. This instruction adds every vector element in
the source SIMD&FP register together, and writes the scalar result to the
destination SIMD&FP register. The destination scalar is twice as long as the
source vector elements. All the values in this instruction are signed integer
values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDLV--Signed-add-long-across-vector-"
    )
    this["saddv"] = OpCodeDoc(
        "SADDV",
        """Signed add horizontally across all lanes of a vector, and place the result in
the SIMD&FP scalar destination register. Narrow elements are first sign-
extended to 64 bits. Inactive elements in the source vector are treated as
zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDV---"
    )
    this["saddw"] = OpCodeDoc(
        "SADDW",
        """Signed Add Wide. This instruction adds vector elements of the first source
SIMD&FP register to the corresponding vector elements in the lower or upper
half of the second source SIMD&FP register, places the results in a vector,
and writes the vector to the SIMD&FP destination register.

The `SADDW` instruction extracts the second source vector from the lower half
of the second source register. The `SADDW2` instruction extracts the second
source vector from the upper half of the second source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDW--SADDW---Signed-add-wide-"
    )
    this["saddw2"] = OpCodeDoc(
        "SADDW2",
        """Signed Add Wide. This instruction adds vector elements of the first source
SIMD&FP register to the corresponding vector elements in the lower or upper
half of the second source SIMD&FP register, places the results in a vector,
and writes the vector to the SIMD&FP destination register.

The `SADDW` instruction extracts the second source vector from the lower half
of the second source register. The `SADDW2` instruction extracts the second
source vector from the upper half of the second source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDW--SADDW---Signed-add-wide-"
    )
    this["saddwb"] = OpCodeDoc(
        "SADDWB",
        """Add the even-numbered signed elements of the second source vector to the
overlapping double-width elements of the first source vector and place the
results in the corresponding double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDWB---"
    )
    this["saddwt"] = OpCodeDoc(
        "SADDWT",
        """Add the odd-numbered signed elements of the second source vector to the
overlapping double-width elements of the first source vector and place the
results in the corresponding double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SADDWT---"
    )
    this["sb"] = OpCodeDoc(
        "SB",
        """Speculation Barrier is a barrier that controls speculation.

The semantics of the Speculation Barrier are that the execution, until the
barrier completes, of any instruction that appears later in the program order
than the barrier:

  * Cannot be performed speculatively to the extent that such speculation can be observed through side-channels as a result of control flow speculation or data value speculation.
  * Can be speculatively executed as a result of predicting that a potentially exception generating instruction has not generated an exception.

In particular, any instruction that appears later in the program order than
the barrier cannot cause a speculative allocation into any caching structure
where the allocation of that entry could be indicative of any data value
present in memory or in the registers.

The SB instruction:

  * Cannot be speculatively executed as a result of control flow speculation or data value speculation.
  * Can be speculatively executed as a result of predicting that a potentially exception generating instruction has not generated an exception. The potentially exception generating instruction can complete once it is known not to be speculative, and all data values generated by instructions appearing in program order before the SB instruction have their predicted values confirmed.

When the prediction of the instruction stream is not informed by data taken
from the register outputs of the speculative execution of instructions
appearing in program order after an uncompleted SB instruction, the SB
instruction has no effect on the use of prediction resources to predict the
instruction stream that is being fetched.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SB--Speculation-barrier-"
    )
    this["sbc"] = OpCodeDoc(
        "SBC",
        """Subtract with Carry subtracts a register value and the value of NOT (Carry
flag) from a register value, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SBC--Subtract-with-carry-"
    )
    this["sbclb"] = OpCodeDoc(
        "SBCLB",
        """Subtract the even-numbered elements of the first source vector and the
inverted 1-bit carry from the least-significant bit of the odd-numbered
elements of the second source vector from the even-numbered elements of the
destination and accumulator vector. The 1-bit carry output is placed in the
corresponding odd-numbered element of the destination vector.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SBCLB---"
    )
    this["sbclt"] = OpCodeDoc(
        "SBCLT",
        """Subtract the odd-numbered elements of the first source vector and the inverted
1-bit carry from the least-significant bit of the odd-numbered elements of the
second source vector from the even-numbered elements of the destination and
accumulator vector. The 1-bit carry output is placed in the corresponding odd-
numbered element of the destination vector.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SBCLT---"
    )
    this["sbcs"] = OpCodeDoc(
        "SBCS",
        """Subtract with Carry, setting flags, subtracts a register value and the value
of NOT (Carry flag) from a register value, and writes the result to the
destination register. It updates the condition flags based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SBCS--Subtract-with-carry--setting-flags-"
    )
    this["sbfiz"] = OpCodeDoc(
        "SBFIZ",
        """Signed Bitfield Insert in Zeros copies a bitfield of <width> bits from the
least significant bits of the source register to bit position <lsb> of the
destination register, setting the destination bits below the bitfield to zero,
and the bits above the bitfield to a copy of the most significant bit of the
bitfield.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SBFIZ--Signed-bitfield-insert-in-zero-"
    )
    this["sbfm"] = OpCodeDoc(
        "SBFM",
        """Signed Bitfield Move is usually accessed via one of its aliases, which are
always preferred for disassembly.

If <imms> is greater than or equal to <immr>, this copies a bitfield of
(<imms>-<immr>+1) bits starting from bit position <immr> in the source
register to the least significant bits of the destination register.

If <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from
the least significant bits of the source register to bit position
(regsize-<immr>) of the destination register, where regsize is the destination
register size of 32 or 64 bits.

In both cases the destination bits below the bitfield are set to zero, and the
bits above the bitfield are set to a copy of the most significant bit of the
bitfield.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SBFM--Signed-bitfield-move-"
    )
    this["sbfx"] = OpCodeDoc(
        "SBFX",
        """Signed Bitfield Extract copies a bitfield of <width> bits starting from bit
position <lsb> in the source register to the least significant bits of the
destination register, and sets destination bits above the bitfield to a copy
of the most significant bit of the bitfield.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SBFX--Signed-bitfield-extract-"
    )
    this["sclamp"] = OpCodeDoc(
        "SCLAMP",
        """Clamp each signed element in the two or four destination vectors to between
the signed minimum value in the corresponding element of the first source
vector and the signed maximum value in the corresponding element of the second
source vector and destructively place the clamped results in the corresponding
elements of the two or four destination vectors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SCLAMP---"
    )
    this["scvtf"] = OpCodeDoc(
        "SCVTF",
        """Signed fixed-point Convert to Floating-point (vector). This instruction
converts each element in a vector from fixed-point to floating-point using the
rounding mode that is specified by the FPCR, and writes the result to the
SIMD&FP destination register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SCVTF--vector--fixed-point---Signed-fixed-point-convert-to-floating-point--vector--"
    )
    this["sdiv"] = OpCodeDoc(
        "SDIV",
        """Signed Divide divides a signed integer register value by another signed
integer register value, and writes the result to the destination register. The
condition flags are not affected.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SDIV--Signed-divide-"
    )
    this["sdivr"] = OpCodeDoc(
        "SDIVR",
        """Signed reversed divide active elements of the second source vector by
corresponding elements of the first source vector and destructively place the
quotient in the corresponding elements of the first source vector. Inactive
elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SDIVR---"
    )
    this["sdot"] = OpCodeDoc(
        "SDOT",
        """Dot Product signed arithmetic (vector, by element). This instruction performs
the dot product of the four 8-bit elements in each 32-bit element of the first
source register with the four 8-bit elements of an indexed 32-bit element in
the second source register, accumulating the result into the corresponding
32-bit element of the destination register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

In Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is
mandatory for all implementations to support it.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SDOT--by-element---Dot-product-signed-arithmetic--vector--by-element--"
    )
    this["sel"] = OpCodeDoc(
        "SEL",
        """Read active elements from the two or four first source vectors and inactive
elements from the two or four second source vectors and place in the
corresponding elements of the two or four destination vectors.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SEL---"
    )
    this["setf16"] = OpCodeDoc(
        "SETF16",
        """Set the PSTATE.NZV flags based on the value in the specified general-purpose
register. `SETF8` treats the value as an 8 bit value, and `SETF16` treats the
value as an 16 bit value.

The PSTATE.C flag is not affected by these instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETF---SETF----Evaluation-of---or----bit-flag-values-"
    )
    this["setf8"] = OpCodeDoc(
        "SETF8",
        """Set the PSTATE.NZV flags based on the value in the specified general-purpose
register. `SETF8` treats the value as an 8 bit value, and `SETF16` treats the
value as an 16 bit value.

The PSTATE.C flag is not affected by these instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETF---SETF----Evaluation-of---or----bit-flag-values-"
    )
    this["setffr"] = OpCodeDoc(
        "SETFFR",
        """Initialise the first-fault register (FFR) to all true prior to a sequence of
first-fault or non-fault loads. This instruction is unpredicated.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETFFR---"
    )
    this["setge"] = OpCodeDoc(
        "SETGE",
        """Memory Set with tag setting. These instructions perform a memory set using the
value in the bottom byte of the source register and store an Allocation Tag to
memory for each Tag Granule written. The Allocation Tag is calculated from the
Logical Address Tag in the register which holds the first address that the set
is made to. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: SETGP, then SETGM,
and then SETGE.

SETGP performs some preconditioning of the arguments suitable for using the
SETGM instruction, and performs an implementation defined amount of the memory
set. SETGM performs an implementation defined amount of the memory set. SETGE
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGP, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGP, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGP--SETGM--SETGE--Memory-set-with-tag-setting-"
    )
    this["setgm"] = OpCodeDoc(
        "SETGM",
        """Memory Set with tag setting. These instructions perform a memory set using the
value in the bottom byte of the source register and store an Allocation Tag to
memory for each Tag Granule written. The Allocation Tag is calculated from the
Logical Address Tag in the register which holds the first address that the set
is made to. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: SETGP, then SETGM,
and then SETGE.

SETGP performs some preconditioning of the arguments suitable for using the
SETGM instruction, and performs an implementation defined amount of the memory
set. SETGM performs an implementation defined amount of the memory set. SETGE
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGP, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGP, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGP--SETGM--SETGE--Memory-set-with-tag-setting-"
    )
    this["setgp"] = OpCodeDoc(
        "SETGP",
        """Memory Set with tag setting. These instructions perform a memory set using the
value in the bottom byte of the source register and store an Allocation Tag to
memory for each Tag Granule written. The Allocation Tag is calculated from the
Logical Address Tag in the register which holds the first address that the set
is made to. The prologue, main, and epilogue instructions are expected to be
run in succession and to appear consecutively in memory: SETGP, then SETGM,
and then SETGE.

SETGP performs some preconditioning of the arguments suitable for using the
SETGM instruction, and performs an implementation defined amount of the memory
set. SETGM performs an implementation defined amount of the memory set. SETGE
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGP, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGP, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGP--SETGM--SETGE--Memory-set-with-tag-setting-"
    )
    this["setgen"] = OpCodeDoc(
        "SETGEN",
        """Memory Set with tag setting, non-temporal. These instructions perform a memory
set using the value in the bottom byte of the source register and store an
Allocation Tag to memory for each Tag Granule written. The Allocation Tag is
calculated from the Logical Address Tag in the register which holds the first
address that the set is made to. The prologue, main, and epilogue instructions
are expected to be run in succession and to appear consecutively in memory:
SETGPN, then SETGMN, and then SETGEN.

SETGPN performs some preconditioning of the arguments suitable for using the
SETGMN instruction, and performs an implementation defined amount of the
memory set. SETGMN performs an implementation defined amount of the memory
set. SETGEN performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGPN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGPN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGMN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGMN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGEN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGEN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGPN--SETGMN--SETGEN--Memory-set-with-tag-setting--non-temporal-"
    )
    this["setgmn"] = OpCodeDoc(
        "SETGMN",
        """Memory Set with tag setting, non-temporal. These instructions perform a memory
set using the value in the bottom byte of the source register and store an
Allocation Tag to memory for each Tag Granule written. The Allocation Tag is
calculated from the Logical Address Tag in the register which holds the first
address that the set is made to. The prologue, main, and epilogue instructions
are expected to be run in succession and to appear consecutively in memory:
SETGPN, then SETGMN, and then SETGEN.

SETGPN performs some preconditioning of the arguments suitable for using the
SETGMN instruction, and performs an implementation defined amount of the
memory set. SETGMN performs an implementation defined amount of the memory
set. SETGEN performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGPN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGPN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGMN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGMN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGEN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGEN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGPN--SETGMN--SETGEN--Memory-set-with-tag-setting--non-temporal-"
    )
    this["setgpn"] = OpCodeDoc(
        "SETGPN",
        """Memory Set with tag setting, non-temporal. These instructions perform a memory
set using the value in the bottom byte of the source register and store an
Allocation Tag to memory for each Tag Granule written. The Allocation Tag is
calculated from the Logical Address Tag in the register which holds the first
address that the set is made to. The prologue, main, and epilogue instructions
are expected to be run in succession and to appear consecutively in memory:
SETGPN, then SETGMN, and then SETGEN.

SETGPN performs some preconditioning of the arguments suitable for using the
SETGMN instruction, and performs an implementation defined amount of the
memory set. SETGMN performs an implementation defined amount of the memory
set. SETGEN performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGPN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGPN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGMN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGMN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGEN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGEN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGPN--SETGMN--SETGEN--Memory-set-with-tag-setting--non-temporal-"
    )
    this["setget"] = OpCodeDoc(
        "SETGET",
        """Memory Set with tag setting, unprivileged. These instructions perform a memory
set using the value in the bottom byte of the source register and store an
Allocation Tag to memory for each Tag Granule written. The Allocation Tag is
calculated from the Logical Address Tag in the register which holds the first
address that the set is made to. The prologue, main, and epilogue instructions
are expected to be run in succession and to appear consecutively in memory:
SETGPT, then SETGMT, and then SETGET.

SETGPT performs some preconditioning of the arguments suitable for using the
SETGMT instruction, and performs an implementation defined amount of the
memory set. SETGMT performs an implementation defined amount of the memory
set. SETGET performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGPT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGPT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGMT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGMT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGET, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGET, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGPT--SETGMT--SETGET--Memory-set-with-tag-setting--unprivileged-"
    )
    this["setgmt"] = OpCodeDoc(
        "SETGMT",
        """Memory Set with tag setting, unprivileged. These instructions perform a memory
set using the value in the bottom byte of the source register and store an
Allocation Tag to memory for each Tag Granule written. The Allocation Tag is
calculated from the Logical Address Tag in the register which holds the first
address that the set is made to. The prologue, main, and epilogue instructions
are expected to be run in succession and to appear consecutively in memory:
SETGPT, then SETGMT, and then SETGET.

SETGPT performs some preconditioning of the arguments suitable for using the
SETGMT instruction, and performs an implementation defined amount of the
memory set. SETGMT performs an implementation defined amount of the memory
set. SETGET performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGPT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGPT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGMT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGMT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGET, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGET, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGPT--SETGMT--SETGET--Memory-set-with-tag-setting--unprivileged-"
    )
    this["setgpt"] = OpCodeDoc(
        "SETGPT",
        """Memory Set with tag setting, unprivileged. These instructions perform a memory
set using the value in the bottom byte of the source register and store an
Allocation Tag to memory for each Tag Granule written. The Allocation Tag is
calculated from the Logical Address Tag in the register which holds the first
address that the set is made to. The prologue, main, and epilogue instructions
are expected to be run in succession and to appear consecutively in memory:
SETGPT, then SETGMT, and then SETGET.

SETGPT performs some preconditioning of the arguments suitable for using the
SETGMT instruction, and performs an implementation defined amount of the
memory set. SETGMT performs an implementation defined amount of the memory
set. SETGET performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGPT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGPT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGMT, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGMT, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGET, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGET, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGPT--SETGMT--SETGET--Memory-set-with-tag-setting--unprivileged-"
    )
    this["setgetn"] = OpCodeDoc(
        "SETGETN",
        """Memory Set with tag setting, unprivileged and non-temporal. These instructions
perform a memory set using the value in the bottom byte of the source register
and store an Allocation Tag to memory for each Tag Granule written. The
Allocation Tag is calculated from the Logical Address Tag in the register
which holds the first address that the set is made to. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: SETGPTN, then SETGMTN, and then SETGETN.

SETGPTN performs some preconditioning of the arguments suitable for using the
SETGMTN instruction, and performs an implementation defined amount of the
memory set. SETGMTN performs an implementation defined amount of the memory
set. SETGETN performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGPTN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGPTN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGPTN--SETGMTN--SETGETN--Memory-set-with-tag-setting--unprivileged-and-non-temporal-"
    )
    this["setgmtn"] = OpCodeDoc(
        "SETGMTN",
        """Memory Set with tag setting, unprivileged and non-temporal. These instructions
perform a memory set using the value in the bottom byte of the source register
and store an Allocation Tag to memory for each Tag Granule written. The
Allocation Tag is calculated from the Logical Address Tag in the register
which holds the first address that the set is made to. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: SETGPTN, then SETGMTN, and then SETGETN.

SETGPTN performs some preconditioning of the arguments suitable for using the
SETGMTN instruction, and performs an implementation defined amount of the
memory set. SETGMTN performs an implementation defined amount of the memory
set. SETGETN performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGPTN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGPTN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGPTN--SETGMTN--SETGETN--Memory-set-with-tag-setting--unprivileged-and-non-temporal-"
    )
    this["setgptn"] = OpCodeDoc(
        "SETGPTN",
        """Memory Set with tag setting, unprivileged and non-temporal. These instructions
perform a memory set using the value in the bottom byte of the source register
and store an Allocation Tag to memory for each Tag Granule written. The
Allocation Tag is calculated from the Logical Address Tag in the register
which holds the first address that the set is made to. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: SETGPTN, then SETGMTN, and then SETGETN.

SETGPTN performs some preconditioning of the arguments suitable for using the
SETGMTN instruction, and performs an implementation defined amount of the
memory set. SETGMTN performs an implementation defined amount of the memory
set. SETGETN performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETGPTN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETGPTN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFF0.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETGMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* number of bytes remaining to be set in the memory set in total.

For SETGMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETGETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETGETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETGPTN--SETGMTN--SETGETN--Memory-set-with-tag-setting--unprivileged-and-non-temporal-"
    )
    this["sete"] = OpCodeDoc(
        "SETE",
        """Memory Set. These instructions perform a memory set using the value in the
bottom byte of the source register. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: SETP, then SETM, and then SETE.

SETP performs some preconditioning of the arguments suitable for using the
SETM instruction, and performs an implementation defined amount of the memory
set. SETM performs an implementation defined amount of the memory set. SETE
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETP, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETP, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETP--SETM--SETE--Memory-set-"
    )
    this["setm"] = OpCodeDoc(
        "SETM",
        """Memory Set. These instructions perform a memory set using the value in the
bottom byte of the source register. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: SETP, then SETM, and then SETE.

SETP performs some preconditioning of the arguments suitable for using the
SETM instruction, and performs an implementation defined amount of the memory
set. SETM performs an implementation defined amount of the memory set. SETE
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETP, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETP, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETP--SETM--SETE--Memory-set-"
    )
    this["setp"] = OpCodeDoc(
        "SETP",
        """Memory Set. These instructions perform a memory set using the value in the
bottom byte of the source register. The prologue, main, and epilogue
instructions are expected to be run in succession and to appear consecutively
in memory: SETP, then SETM, and then SETE.

SETP performs some preconditioning of the arguments suitable for using the
SETM instruction, and performs an implementation defined amount of the memory
set. SETM performs an implementation defined amount of the memory set. SETE
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETP, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETP, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETM, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETM, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETE, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETE, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETP--SETM--SETE--Memory-set-"
    )
    this["seten"] = OpCodeDoc(
        "SETEN",
        """Memory Set, non-temporal. These instructions perform a memory set using the
value in the bottom byte of the source register. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: SETPN, then SETMN, and then SETEN.

SETPN performs some preconditioning of the arguments suitable for using the
SETMN instruction, and performs an implementation defined amount of the memory
set. SETMN performs an implementation defined amount of the memory set. SETEN
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETPN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETPN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETMN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETMN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETEN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETEN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETPN--SETMN--SETEN--Memory-set--non-temporal-"
    )
    this["setmn"] = OpCodeDoc(
        "SETMN",
        """Memory Set, non-temporal. These instructions perform a memory set using the
value in the bottom byte of the source register. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: SETPN, then SETMN, and then SETEN.

SETPN performs some preconditioning of the arguments suitable for using the
SETMN instruction, and performs an implementation defined amount of the memory
set. SETMN performs an implementation defined amount of the memory set. SETEN
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETPN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETPN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETMN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETMN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETEN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETEN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETPN--SETMN--SETEN--Memory-set--non-temporal-"
    )
    this["setpn"] = OpCodeDoc(
        "SETPN",
        """Memory Set, non-temporal. These instructions perform a memory set using the
value in the bottom byte of the source register. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: SETPN, then SETMN, and then SETEN.

SETPN performs some preconditioning of the arguments suitable for using the
SETMN instruction, and performs an implementation defined amount of the memory
set. SETMN performs an implementation defined amount of the memory set. SETEN
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETPN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETPN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETMN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETMN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETEN, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETEN, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETPN--SETMN--SETEN--Memory-set--non-temporal-"
    )
    this["setet"] = OpCodeDoc(
        "SETET",
        """Memory Set, unprivileged. These instructions perform a memory set using the
value in the bottom byte of the source register. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: SETPT, then SETMT, and then SETET.

SETPT performs some preconditioning of the arguments suitable for using the
SETMT instruction, and performs an implementation defined amount of the memory
set. SETMT performs an implementation defined amount of the memory set. SETET
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETPT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETPT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETMT, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETMT, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETET, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETET, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETPT--SETMT--SETET--Memory-set--unprivileged-"
    )
    this["setmt"] = OpCodeDoc(
        "SETMT",
        """Memory Set, unprivileged. These instructions perform a memory set using the
value in the bottom byte of the source register. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: SETPT, then SETMT, and then SETET.

SETPT performs some preconditioning of the arguments suitable for using the
SETMT instruction, and performs an implementation defined amount of the memory
set. SETMT performs an implementation defined amount of the memory set. SETET
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETPT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETPT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETMT, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETMT, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETET, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETET, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETPT--SETMT--SETET--Memory-set--unprivileged-"
    )
    this["setpt"] = OpCodeDoc(
        "SETPT",
        """Memory Set, unprivileged. These instructions perform a memory set using the
value in the bottom byte of the source register. The prologue, main, and
epilogue instructions are expected to be run in succession and to appear
consecutively in memory: SETPT, then SETMT, and then SETET.

SETPT performs some preconditioning of the arguments suitable for using the
SETMT instruction, and performs an implementation defined amount of the memory
set. SETMT performs an implementation defined amount of the memory set. SETET
performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETPT, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETPT, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETMT, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETMT, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETET, option A (encoded by PSTATE.C = 0), the format of the arguments is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETET, option B (encoded by PSTATE.C = 1), the format of the arguments is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETPT--SETMT--SETET--Memory-set--unprivileged-"
    )
    this["setetn"] = OpCodeDoc(
        "SETETN",
        """Memory Set, unprivileged and non-temporal. These instructions perform a memory
set using the value in the bottom byte of the source register. The prologue,
main, and epilogue instructions are expected to be run in succession and to
appear consecutively in memory: SETPTN, then SETMTN, and then SETETN.

SETPTN performs some preconditioning of the arguments suitable for using the
SETMTN instruction, and performs an implementation defined amount of the
memory set. SETMTN performs an implementation defined amount of the memory
set. SETETN performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETPTN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETPTN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETPTN--SETMTN--SETETN--Memory-set--unprivileged-and-non-temporal-"
    )
    this["setmtn"] = OpCodeDoc(
        "SETMTN",
        """Memory Set, unprivileged and non-temporal. These instructions perform a memory
set using the value in the bottom byte of the source register. The prologue,
main, and epilogue instructions are expected to be run in succession and to
appear consecutively in memory: SETPTN, then SETMTN, and then SETETN.

SETPTN performs some preconditioning of the arguments suitable for using the
SETMTN instruction, and performs an implementation defined amount of the
memory set. SETMTN performs an implementation defined amount of the memory
set. SETETN performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETPTN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETPTN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETPTN--SETMTN--SETETN--Memory-set--unprivileged-and-non-temporal-"
    )
    this["setptn"] = OpCodeDoc(
        "SETPTN",
        """Memory Set, unprivileged and non-temporal. These instructions perform a memory
set using the value in the bottom byte of the source register. The prologue,
main, and epilogue instructions are expected to be run in succession and to
appear consecutively in memory: SETPTN, then SETMTN, and then SETETN.

SETPTN performs some preconditioning of the arguments suitable for using the
SETMTN instruction, and performs an implementation defined amount of the
memory set. SETMTN performs an implementation defined amount of the memory
set. SETETN performs the last part of the memory set.

The architecture supports two algorithms for the memory set: option A and
option B. Which algorithm is used is implementation defined.

After execution of SETPTN, option A (which results in encoding PSTATE.C = 0):

  * If Xn<63> == 1, the set size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + saturated Xn.
  * Xn holds -1* saturated Xn + an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

After execution of SETPTN, option B (which results in encoding PSTATE.C = 1):

  * If Xn<63> == 1, the copy size is saturated to 0x7FFFFFFFFFFFFFFF.
  * Xd holds the original Xd + an implementation defined number of bytes set.
  * Xn holds the saturated Xn - an implementation defined number of bytes set.
  * PSTATE.{N,Z,V} are set to {0,0,0}.

For SETMTN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with -1* the number of bytes remaining to be set in the memory set in total.

For SETMTN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with the number of bytes remaining to be set in the memory set in total.
  * the value of Xd is written back with the lowest address that has not been set.

For SETETN, option A (encoded by PSTATE.C = 0), the format of the arguments
is:

  * Xn is treated as a signed 64-bit number.
  * Xn holds -1* the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to -Xn.
  * At the end of the instruction, the value of Xn is written back with 0.

For SETETN, option B (encoded by PSTATE.C = 1), the format of the arguments
is:

  * Xn holds the number of bytes remaining to be set in the memory set in total.
  * Xd holds the lowest address that the set is made to.
  * At the end of the instruction:
  * the value of Xn is written back with 0.
  * the value of Xd is written back with the lowest address that has not been set.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SETPTN--SETMTN--SETETN--Memory-set--unprivileged-and-non-temporal-"
    )
    this["sev"] = OpCodeDoc(
        "SEV",
        """Send Event is a hint instruction. It causes an event to be signaled to all PEs
in the multiprocessor system. For more information, see Wait for Event
mechanism and Send event.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SEV--Send-event-"
    )
    this["sevl"] = OpCodeDoc(
        "SEVL",
        """Send Event Local is a hint instruction that causes an event to be signaled
locally without requiring the event to be signaled to other PEs in the
multiprocessor system. It can prime a wait-loop which starts with a `WFE`
instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SEVL--Send-event-local-"
    )
    this["sha1c"] = OpCodeDoc(
        "SHA1C",
        """SHA1 hash update (choose).

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA-C--Sha--hash-update--choose--"
    )
    this["sha1h"] = OpCodeDoc(
        "SHA1H",
        """SHA1 fixed rotate.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA-H--Sha--fixed-rotate-"
    )
    this["sha1m"] = OpCodeDoc(
        "SHA1M",
        """SHA1 hash update (majority).

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA-M--Sha--hash-update--majority--"
    )
    this["sha1p"] = OpCodeDoc(
        "SHA1P",
        """SHA1 hash update (parity).

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA-P--Sha--hash-update--parity--"
    )
    this["sha1su0"] = OpCodeDoc(
        "SHA1SU0",
        """SHA1 schedule update 0.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA-SU---Sha--schedule-update---"
    )
    this["sha1su1"] = OpCodeDoc(
        "SHA1SU1",
        """SHA1 schedule update 1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA-SU---Sha--schedule-update---"
    )
    this["sha256h2"] = OpCodeDoc(
        "SHA256H2",
        """SHA256 hash update (part 2).

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA---H---Sha----hash-update--part----"
    )
    this["sha256h"] = OpCodeDoc(
        "SHA256H",
        """SHA256 hash update (part 1).

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA---H--Sha----hash-update--part----"
    )
    this["sha256su0"] = OpCodeDoc(
        "SHA256SU0",
        """SHA256 schedule update 0.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA---SU---Sha----schedule-update---"
    )
    this["sha256su1"] = OpCodeDoc(
        "SHA256SU1",
        """SHA256 schedule update 1.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA---SU---Sha----schedule-update---"
    )
    this["sha512h2"] = OpCodeDoc(
        "SHA512H2",
        """SHA512 Hash update part 2 takes the values from the three 128-bit source
SIMD&FP registers and produces a 128-bit output value that combines the sigma0
and majority functions of two iterations of the SHA512 computation. It returns
this value to the destination SIMD&FP register.

This instruction is implemented only when FEAT_SHA512 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA---H---Sha----hash-update-part---"
    )
    this["sha512h"] = OpCodeDoc(
        "SHA512H",
        """SHA512 Hash update part 1 takes the values from the three 128-bit source
SIMD&FP registers and produces a 128-bit output value that combines the sigma1
and chi functions of two iterations of the SHA512 computation. It returns this
value to the destination SIMD&FP register.

This instruction is implemented only when FEAT_SHA512 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA---H--Sha----hash-update-part---"
    )
    this["sha512su0"] = OpCodeDoc(
        "SHA512SU0",
        """SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP
registers and produces a 128-bit output value that combines the gamma0
functions of two iterations of the SHA512 schedule update that are performed
after the first 16 iterations within a block. It returns this value to the
destination SIMD&FP register.

This instruction is implemented only when FEAT_SHA512 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA---SU---Sha----schedule-update---"
    )
    this["sha512su1"] = OpCodeDoc(
        "SHA512SU1",
        """SHA512 Schedule Update 1 takes the values from the three source SIMD&FP
registers and produces a 128-bit output value that combines the gamma1
functions of two iterations of the SHA512 schedule update that are performed
after the first 16 iterations within a block. It returns this value to the
destination SIMD&FP register.

This instruction is implemented only when FEAT_SHA512 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHA---SU---Sha----schedule-update---"
    )
    this["shadd"] = OpCodeDoc(
        "SHADD",
        """Signed Halving Add. This instruction adds corresponding signed integer values
from the two source SIMD&FP registers, shifts each result right one bit,
places the results into a vector, and writes the vector to the destination
SIMD&FP register.

The results are truncated. For rounded results, see SRHADD.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHADD--Signed-halving-add-"
    )
    this["shl"] = OpCodeDoc(
        "SHL",
        """Shift Left (immediate). This instruction reads each value from a vector, left
shifts each result by an immediate value, writes the final result to a vector,
and writes the vector to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHL--Shift-left--immediate--"
    )
    this["shll"] = OpCodeDoc(
        "SHLL",
        """Shift Left Long (by element size). This instruction reads each vector element
in the lower or upper half of the source SIMD&FP register, left shifts each
result by the element size, writes the final result to a vector, and writes
the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the source vector elements.

The `SHLL` instruction extracts vector elements from the lower half of the
source register. The `SHLL2` instruction extracts vector elements from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHLL--SHLL---Shift-left-long--by-element-size--"
    )
    this["shll2"] = OpCodeDoc(
        "SHLL2",
        """Shift Left Long (by element size). This instruction reads each vector element
in the lower or upper half of the source SIMD&FP register, left shifts each
result by the element size, writes the final result to a vector, and writes
the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the source vector elements.

The `SHLL` instruction extracts vector elements from the lower half of the
source register. The `SHLL2` instruction extracts vector elements from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHLL--SHLL---Shift-left-long--by-element-size--"
    )
    this["shrn"] = OpCodeDoc(
        "SHRN",
        """Shift Right Narrow (immediate). This instruction reads each unsigned integer
value from the source SIMD&FP register, right shifts each result by an
immediate value, puts the final result into a vector, and writes the vector to
the lower or upper half of the destination SIMD&FP register. The destination
vector elements are half as long as the source vector elements. The results
are truncated. For rounded results, see RSHRN.

The `RSHRN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `RSHRN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHRN--SHRN---Shift-right-narrow--immediate--"
    )
    this["shrn2"] = OpCodeDoc(
        "SHRN2",
        """Shift Right Narrow (immediate). This instruction reads each unsigned integer
value from the source SIMD&FP register, right shifts each result by an
immediate value, puts the final result into a vector, and writes the vector to
the lower or upper half of the destination SIMD&FP register. The destination
vector elements are half as long as the source vector elements. The results
are truncated. For rounded results, see RSHRN.

The `RSHRN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `RSHRN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHRN--SHRN---Shift-right-narrow--immediate--"
    )
    this["shrnb"] = OpCodeDoc(
        "SHRNB",
        """Shift each unsigned integer value in the source vector elements right by an
immediate value, and place the truncated results in the even-numbered half-
width destination elements, while setting the odd-numbered elements to zero.
The immediate shift amount is an unsigned value in the range 1 to number of
bits per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHRNB---"
    )
    this["shrnt"] = OpCodeDoc(
        "SHRNT",
        """Shift each unsigned integer value in the source vector elements right by an
immediate value, and place the truncated results in the odd-numbered half-
width destination elements, leaving the even-numbered elements unchanged. The
immediate shift amount is an unsigned value in the range 1 to number of bits
per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHRNT---"
    )
    this["shsub"] = OpCodeDoc(
        "SHSUB",
        """Signed Halving Subtract. This instruction subtracts the elements in the vector
in the second source SIMD&FP register from the corresponding elements in the
vector in the first source SIMD&FP register, shifts each result right one bit,
places each result into elements of a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHSUB--Signed-halving-subtract-"
    )
    this["shsubr"] = OpCodeDoc(
        "SHSUBR",
        """Subtract active signed elements of the first source vector from corresponding
signed elements of the second source vector, shift right one bit, and
destructively place the results in the corresponding elements of the first
source vector. Inactive elements in the destination vector register remain
unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SHSUBR---"
    )
    this["sli"] = OpCodeDoc(
        "SLI",
        """Shift Left and Insert (immediate). This instruction reads each vector element
in the source SIMD&FP register, left shifts each vector element by an
immediate value, and inserts the result into the corresponding vector element
in the destination SIMD&FP register such that the new zero bits created by the
shift are not inserted but retain their existing value. Bits shifted out of
the left of each vector element in the source register are lost.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SLI--Shift-left-and-insert--immediate--"
    )
    this["sm3partw1"] = OpCodeDoc(
        "SM3PARTW1",
        """SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers
and returns a 128-bit result in the destination SIMD&FP register. The result
is obtained by a three-way exclusive-OR of the elements within the input
vectors with some fixed rotations, see the Operation pseudocode for more
information.

This instruction is implemented only when FEAT_SM3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SM-PARTW---Sm-partw--"
    )
    this["sm3partw2"] = OpCodeDoc(
        "SM3PARTW2",
        """SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and
returns a 128-bit result in the destination SIMD&FP register. The result is
obtained by a three-way exclusive-OR of the elements within the input vectors
with some fixed rotations, see the Operation pseudocode for more information.

This instruction is implemented only when FEAT_SM3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SM-PARTW---Sm-partw--"
    )
    this["sm3ss1"] = OpCodeDoc(
        "SM3SS1",
        """SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source
SIMD&FP register by 12, and adds that 32-bit value to the two other 32-bit
values held in the top 32 bits of each of the 128-bit vectors in the second
and third source SIMD&FP registers, rotating this result left by 7 and writing
the final result into the top 32 bits of the vector in the destination SIMD&FP
register, with the bottom 96 bits of the vector being written to 0.

This instruction is implemented only when FEAT_SM3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SM-SS---Sm-ss--"
    )
    this["sm3tt1a"] = OpCodeDoc(
        "SM3TT1A",
        """SM3TT1A takes three 128-bit vectors from three source SIMD&FP registers and a
2-bit immediate index value, and returns a 128-bit result in the destination
SIMD&FP register. It performs a three-way exclusive-OR of the three 32-bit
fields held in the upper three elements of the first source vector, and adds
the resulting 32-bit value and the following three other 32-bit values:

  * The bottom 32-bit element of the first source vector, Vd, that was used for the three-way exclusive-OR.
  * The result of the exclusive-OR of the top 32-bit element of the second source vector, Vn, with a rotation left by 12 of the top 32-bit element of the first source vector.
  * A 32-bit element indexed out of the third source vector, Vm.

The result of this addition is returned as the top element of the result. The
other elements of the result are taken from elements of the first source
vector, with the element returned in bits<63:32> being rotated left by 9.

This instruction is implemented only when FEAT_SM3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SM-TT-A--Sm-tt-a-"
    )
    this["sm3tt1b"] = OpCodeDoc(
        "SM3TT1B",
        """SM3TT1B takes three 128-bit vectors from three source SIMD&FP registers and a
2-bit immediate index value, and returns a 128-bit result in the destination
SIMD&FP register. It performs a 32-bit majority function between the three
32-bit fields held in the upper three elements of the first source vector, and
adds the resulting 32-bit value and the following three other 32-bit values:

  * The bottom 32-bit element of the first source vector, Vd, that was used for the 32-bit majority function.
  * The result of the exclusive-OR of the top 32-bit element of the second source vector, Vn, with a rotation left by 12 of the top 32-bit element of the first source vector.
  * A 32-bit element indexed out of the third source vector, Vm.

The result of this addition is returned as the top element of the result. The
other elements of the result are taken from elements of the first source
vector, with the element returned in bits<63:32> being rotated left by 9.

This instruction is implemented only when FEAT_SM3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SM-TT-B--Sm-tt-b-"
    )
    this["sm3tt2a"] = OpCodeDoc(
        "SM3TT2A",
        """SM3TT2A takes three 128-bit vectors from three source SIMD&FP register and a
2-bit immediate index value, and returns a 128-bit result in the destination
SIMD&FP register. It performs a three-way exclusive-OR of the three 32-bit
fields held in the upper three elements of the first source vector, and adds
the resulting 32-bit value and the following three other 32-bit values:

  * The bottom 32-bit element of the first source vector, Vd, that was used for the three-way exclusive-OR.
  * The 32-bit element held in the top 32 bits of the second source vector, Vn.
  * A 32-bit element indexed out of the third source vector, Vm.

A three-way exclusive-OR is performed of the result of this addition, the
result of the addition rotated left by 9, and the result of the addition
rotated left by 17. The result of this exclusive-OR is returned as the top
element of the returned result. The other elements of this result are taken
from elements of the first source vector, with the element returned in
bits<63:32> being rotated left by 19.

This instruction is implemented only when FEAT_SM3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SM-TT-A--Sm-tt-a-"
    )
    this["sm3tt2b"] = OpCodeDoc(
        "SM3TT2B",
        """SM3TT2B takes three 128-bit vectors from three source SIMD&FP registers, and a
2-bit immediate index value, and returns a 128-bit result in the destination
SIMD&FP register. It performs a 32-bit majority function between the three
32-bit fields held in the upper three elements of the first source vector, and
adds the resulting 32-bit value and the following three other 32-bit values:

  * The bottom 32-bit element of the first source vector, Vd, that was used for the 32-bit majority function.
  * The 32-bit element held in the top 32 bits of the second source vector, Vn.
  * A 32-bit element indexed out of the third source vector, Vm.

A three-way exclusive-OR is performed of the result of this addition, the
result of the addition rotated left by 9, and the result of the addition
rotated left by 17. The result of this exclusive-OR is returned as the top
element of the returned result. The other elements of this result are taken
from elements of the first source vector, with the element returned in
bits<63:32> being rotated left by 19.

This instruction is implemented only when FEAT_SM3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SM-TT-B--Sm-tt-b-"
    )
    this["sm4e"] = OpCodeDoc(
        "SM4E",
        """SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP
register, and four iterations of the round key held as the elements of the
128-bit vector in the second source SIMD&FP register. It encrypts the data by
four rounds, in accordance with the SM4 standard, returning the 128-bit result
to the destination SIMD&FP register.

This instruction is implemented only when FEAT_SM4 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SM-E--Sm--encode-"
    )
    this["sm4ekey"] = OpCodeDoc(
        "SM4EKEY",
        """SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP
register and a 128-bit constant from the second SIMD&FP register. It derives
four iterations of the output key, in accordance with the SM4 standard,
returning the 128-bit result to the destination SIMD&FP register.

This instruction is implemented only when FEAT_SM4 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SM-EKEY--Sm--key-"
    )
    this["smaddl"] = OpCodeDoc(
        "SMADDL",
        """Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit
register value, and writes the result to the 64-bit destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMADDL--Signed-multiply-add-long-"
    )
    this["smax"] = OpCodeDoc(
        "SMAX",
        """Signed Maximum (vector). This instruction compares corresponding elements in
the vectors in the two source SIMD&FP registers, places the larger of each
pair of signed integer values into a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMAX--Signed-maximum--vector--"
    )
    this["smax"] = OpCodeDoc(
        "SMAX",
        """Signed Maximum (immediate) determines the signed maximum of the source
register value and immediate, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMAX--immediate---Signed-maximum--immediate--"
    )
    this["smax"] = OpCodeDoc(
        "SMAX",
        """Signed Maximum (register) determines the signed maximum of the two source
register values and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMAX--register---Signed-maximum--register--"
    )
    this["smax"] = OpCodeDoc(
        "SMAX",
        """Determine the signed maximum of an immediate and each element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. The immediate is a signed 8-bit value in the range -128 to
+127, inclusive. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMAX--immediate----"
    )
    this["smaxp"] = OpCodeDoc(
        "SMAXP",
        """Signed Maximum Pairwise. This instruction creates a vector by concatenating
the vector elements of the first source SIMD&FP register after the vector
elements of the second source SIMD&FP register, reads each pair of adjacent
vector elements in the two source SIMD&FP registers, writes the largest of
each pair of signed integer values into a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMAXP--Signed-maximum-pairwise-"
    )
    this["smaxqv"] = OpCodeDoc(
        "SMAXQV",
        """Signed maximum of the same element numbers from each 128-bit source vector
segment, placing each result into the corresponding element number of the
128-bit SIMD&FP destination register. Inactive elements in the source vector
are treated as the minimum signed integer for the element size.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMAXQV---"
    )
    this["smaxv"] = OpCodeDoc(
        "SMAXV",
        """Signed Maximum across Vector. This instruction compares all the vector
elements in the source SIMD&FP register, and writes the largest of the values
as a scalar to the destination SIMD&FP register. All the values in this
instruction are signed integer values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMAXV--Signed-maximum-across-vector-"
    )
    this["smc"] = OpCodeDoc(
        "SMC",
        """Secure Monitor Call causes an exception to EL3.

`SMC` is available only for software executing at EL1 or higher. It is
undefined in EL0.

If the values of HCR_EL2.TSC and SCR_EL3.SMD are both 0, execution of an `SMC`
instruction at EL1 or higher generates a Secure Monitor Call exception,
recording it in ESR_ELx, using the EC value 0x17, that is taken to EL3.

If the value of HCR_EL2.TSC is 1 and EL2 is enabled in the current Security
state, execution of an `SMC` instruction at EL1 generates an exception that is
taken to EL2, regardless of the value of SCR_EL3.SMD.

If the value of HCR_EL2.TSC is 0 and the value of SCR_EL3.SMD is 1, the SMC
instruction is undefined.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMC--Secure-monitor-call-"
    )
    this["smin"] = OpCodeDoc(
        "SMIN",
        """Signed Minimum (vector). This instruction compares corresponding elements in
the vectors in the two source SIMD&FP registers, places the smaller of each of
the two signed integer values into a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMIN--Signed-minimum--vector--"
    )
    this["smin"] = OpCodeDoc(
        "SMIN",
        """Signed Minimum (immediate) determines the signed minimum of the source
register value and immediate, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMIN--immediate---Signed-minimum--immediate--"
    )
    this["smin"] = OpCodeDoc(
        "SMIN",
        """Signed Minimum (register) determines the signed minimum of the two source
register values and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMIN--register---Signed-minimum--register--"
    )
    this["smin"] = OpCodeDoc(
        "SMIN",
        """Determine the signed minimum of an immediate and each element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. The immediate is a signed 8-bit value in the range -128 to
+127, inclusive. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMIN--immediate----"
    )
    this["sminp"] = OpCodeDoc(
        "SMINP",
        """Signed Minimum Pairwise. This instruction creates a vector by concatenating
the vector elements of the first source SIMD&FP register after the vector
elements of the second source SIMD&FP register, reads each pair of adjacent
vector elements in the two source SIMD&FP registers, writes the smallest of
each pair of signed integer values into a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMINP--Signed-minimum-pairwise-"
    )
    this["sminqv"] = OpCodeDoc(
        "SMINQV",
        """Signed minimum of the same element numbers from each 128-bit source vector
segment, placing each result into the corresponding element number of the
128-bit SIMD&FP destination register. Inactive elements in the source vector
are treated as the maximum signed integer for the element size.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMINQV---"
    )
    this["sminv"] = OpCodeDoc(
        "SMINV",
        """Signed Minimum across Vector. This instruction compares all the vector
elements in the source SIMD&FP register, and writes the smallest of the values
as a scalar to the destination SIMD&FP register. All the values in this
instruction are signed integer values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMINV--Signed-minimum-across-vector-"
    )
    this["smlal"] = OpCodeDoc(
        "SMLAL",
        """Signed Multiply-Add Long (vector, by element). This instruction multiplies
each vector element in the lower or upper half of the first source SIMD&FP
register by the specified vector element in the second source SIMD&FP
register, and accumulates the results with the vector elements of the
destination SIMD&FP register. The destination vector elements are twice as
long as the elements that are multiplied. All the values in this instruction
are signed integer values.

The `SMLAL` instruction extracts vector elements from the lower half of the
first source register. The `SMLAL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLAL--SMLAL---by-element---Signed-multiply-add-long--vector--by-element--"
    )
    this["smlal2"] = OpCodeDoc(
        "SMLAL2",
        """Signed Multiply-Add Long (vector, by element). This instruction multiplies
each vector element in the lower or upper half of the first source SIMD&FP
register by the specified vector element in the second source SIMD&FP
register, and accumulates the results with the vector elements of the
destination SIMD&FP register. The destination vector elements are twice as
long as the elements that are multiplied. All the values in this instruction
are signed integer values.

The `SMLAL` instruction extracts vector elements from the lower half of the
first source register. The `SMLAL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLAL--SMLAL---by-element---Signed-multiply-add-long--vector--by-element--"
    )
    this["smlalb"] = OpCodeDoc(
        "SMLALB",
        """Multiply the corresponding even-numbered signed elements of the first and
second source vectors and destructively add to the overlapping double-width
elements of the addend vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLALB--vectors----"
    )
    this["smlall"] = OpCodeDoc(
        "SMLALL",
        """This signed integer multiply-add long-long instruction multiplies each signed
8-bit or 16-bit element in the one, two, or four first source vectors with
each signed 8-bit or 16-bit indexed element of second source vector, widens
each product to 32-bits or 64-bits and destructively adds these values to the
corresponding 32-bit or 64-bit elements of the ZA quad-vector groups.

The elements within the second source vector are specified using an immediate
element index which selects the same element position within each 128-bit
vector segment. The index range is from 0 to one less than the number of
elements per 128-bit segment, encoded in 3 to 4 bits depending on the size of
the element. The lowest of the four consecutive vector numbers forming the
quad-vector group within all of, each half of, or each quarter of the ZA array
are selected by the sum of the vector select register and immediate offset,
modulo all, half, or quarter the number of ZA array vectors.

The vector group symbol, VGx2 or VGx4, indicates that the ZA operand consists
of two or four ZA quad-vector groups respectively. The vector group symbol is
preferred for disassembly, but optional in assembler source code.

This instruction is unpredicated.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 16-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLALL--multiple-and-indexed-vector----"
    )
    this["smlalt"] = OpCodeDoc(
        "SMLALT",
        """Multiply the corresponding odd-numbered signed elements of the first and
second source vectors and destructively add to the overlapping double-width
elements of the addend vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLALT--vectors----"
    )
    this["smlsl"] = OpCodeDoc(
        "SMLSL",
        """Signed Multiply-Subtract Long (vector, by element). This instruction
multiplies each vector element in the lower or upper half of the first source
SIMD&FP register by the specified vector element of the second source SIMD&FP
register and subtracts the results from the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the
elements that are multiplied.

The `SMLSL` instruction extracts vector elements from the lower half of the
first source register. The `SMLSL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLSL--SMLSL---by-element---Signed-multiply-subtract-long--vector--by-element--"
    )
    this["smlsl2"] = OpCodeDoc(
        "SMLSL2",
        """Signed Multiply-Subtract Long (vector, by element). This instruction
multiplies each vector element in the lower or upper half of the first source
SIMD&FP register by the specified vector element of the second source SIMD&FP
register and subtracts the results from the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the
elements that are multiplied.

The `SMLSL` instruction extracts vector elements from the lower half of the
first source register. The `SMLSL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLSL--SMLSL---by-element---Signed-multiply-subtract-long--vector--by-element--"
    )
    this["smlslb"] = OpCodeDoc(
        "SMLSLB",
        """Multiply the corresponding even-numbered signed elements of the first and
second source vectors and destructively subtract from the overlapping double-
width elements of the addend vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLSLB--vectors----"
    )
    this["smlsll"] = OpCodeDoc(
        "SMLSLL",
        """This signed integer multiply-subtract long-long instruction multiplies each
signed 8-bit or 16-bit element in the one, two, or four first source vectors
with each signed 8-bit or 16-bit indexed element of second source vector,
widens each product to 32-bits or 64-bits and destructively subtracts these
values from the corresponding 32-bit or 64-bit elements of the ZA quad-vector
groups.

The elements within the second source vector are specified using an immediate
element index which selects the same element position within each 128-bit
vector segment. The index range is from 0 to one less than the number of
elements per 128-bit segment, encoded in 3 to 4 bits depending on the size of
the element. The lowest of the four consecutive vector numbers forming the
quad-vector group within all of, each half of, or each quarter of the ZA array
are selected by the sum of the vector select register and immediate offset,
modulo all, half, or quarter the number of ZA array vectors.

The vector group symbol, VGx2 or VGx4, indicates that the ZA operand consists
of two or four ZA quad-vector groups respectively. The vector group symbol is
preferred for disassembly, but optional in assembler source code.

This instruction is unpredicated.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 16-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLSLL--multiple-and-indexed-vector----"
    )
    this["smlslt"] = OpCodeDoc(
        "SMLSLT",
        """Multiply the corresponding odd-numbered signed elements of the first and
second source vectors and destructively subtract from the overlapping double-
width elements of the addend vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMLSLT--vectors----"
    )
    this["smmla"] = OpCodeDoc(
        "SMMLA",
        """Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies
the 2x8 matrix of signed 8-bit integer values in the first source vector by
the 8x2 matrix of signed 8-bit integer values in the second source vector. The
resulting 2x2 32-bit integer matrix product is destructively added to the
32-bit integer matrix accumulator in the destination vector. This is
equivalent to performing an 8-way dot product per destination element.

From Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is
mandatory for implementations that include Advanced SIMD to support it.
ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMMLA--vector---Signed---bit-integer-matrix-multiply-accumulate--vector--"
    )
    this["smnegl"] = OpCodeDoc(
        "SMNEGL",
        """Signed Multiply-Negate Long multiplies two 32-bit register values, negates the
product, and writes the result to the 64-bit destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMNEGL--Signed-multiply-negate-long-"
    )
    this["smopa"] = OpCodeDoc(
        "SMOPA",
        """This instruction works with a 32-bit element ZA tile.

The signed integer sum of outer products and accumulate instructions multiply
the sub-matrix in the first source vector by the sub-matrix in the second
source vector. The first source holds SVLS2 sub-matrix of signed 16-bit
integer values, and the second source holds 2SVLS sub-matrix of signed 16-bit
integer values.

Each source vector is independently predicated by a corresponding governing
predicate. When a 16-bit source element is inactive, it is treated as having
the value 0.

The resulting SVLSSVLS widened 32-bit integer sum of outer products is then
destructively added to the 32-bit integer destination tile. This is equivalent
to performing a 2-way dot product and accumulate to each of the destination
tile elements.

Each 32-bit container of the first source vector holds 2 consecutive column
elements of each row of a SVLS2 sub-matrix, and each 32-bit container of the
second source vector holds 2 consecutive row elements of each column of a
2SVLS sub-matrix.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMOPA----way----"
    )
    this["smops"] = OpCodeDoc(
        "SMOPS",
        """This instruction works with a 32-bit element ZA tile.

The signed integer sum of outer products and subtract instructions multiply
the sub-matrix in the first source vector by the sub-matrix in the second
source vector. The first source holds SVLS2 sub-matrix of signed 16-bit
integer values, and the second source holds 2SVLS sub-matrix of signed 16-bit
integer values.

Each source vector is independently predicated by a corresponding governing
predicate. When a 16-bit source element is inactive, it is treated as having
the value 0.

The resulting SVLSSVLS widened 32-bit integer sum of outer products is then
destructively subtracted from the 32-bit integer destination tile. This is
equivalent to performing a 2-way dot product and subtract from each of the
destination tile elements.

Each 32-bit container of the first source vector holds 2 consecutive column
elements of each row of a SVLS2 sub-matrix, and each 32-bit container of the
second source vector holds 2 consecutive row elements of each column of a
2SVLS sub-matrix.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMOPS----way----"
    )
    this["smov"] = OpCodeDoc(
        "SMOV",
        """Signed Move vector element to general-purpose register. This instruction reads
the signed integer from the source SIMD&FP register, sign-extends it to form a
32-bit or 64-bit value, and writes the result to destination general-purpose
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMOV--Signed-move-vector-element-to-general-purpose-register-"
    )
    this["smstart"] = OpCodeDoc(
        "SMSTART",
        """Enables access to Streaming SVE mode and SME architectural state.

SMSTART enters Streaming SVE mode, and enables the SME ZA storage.

SMSTART SM enters Streaming SVE mode, but does not enable the SME ZA storage.

SMSTART ZA enables the SME ZA storage, but does not cause an entry to
Streaming SVE mode.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMSTART--Enables-access-to-streaming-sve-mode-and-sme-architectural-state-"
    )
    this["smstop"] = OpCodeDoc(
        "SMSTOP",
        """Disables access to Streaming SVE mode and SME architectural state.

SMSTOP exits Streaming SVE mode, and disables the SME ZA storage.

SMSTOP SM exits Streaming SVE mode, but does not disable the SME ZA storage.

SMSTOP ZA disables the SME ZA storage, but does not cause an exit from
Streaming SVE mode.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMSTOP--Disables-access-to-streaming-sve-mode-and-sme-architectural-state-"
    )
    this["smsubl"] = OpCodeDoc(
        "SMSUBL",
        """Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts
the product from a 64-bit register value, and writes the result to the 64-bit
destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMSUBL--Signed-multiply-subtract-long-"
    )
    this["smulh"] = OpCodeDoc(
        "SMULH",
        """Signed Multiply High multiplies two 64-bit register values, and writes
bits[127:64] of the 128-bit result to the 64-bit destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMULH--Signed-multiply-high-"
    )
    this["smull"] = OpCodeDoc(
        "SMULL",
        """Signed Multiply Long (vector, by element). This instruction multiplies each
vector element in the lower or upper half of the first source SIMD&FP register
by the specified vector element of the second source SIMD&FP register, places
the result in a vector, and writes the vector to the destination SIMD&FP
register. The destination vector elements are twice as long as the elements
that are multiplied.

The `SMULL` instruction extracts vector elements from the lower half of the
first source register. The `SMULL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMULL--SMULL---by-element---Signed-multiply-long--vector--by-element--"
    )
    this["smull2"] = OpCodeDoc(
        "SMULL2",
        """Signed Multiply Long (vector, by element). This instruction multiplies each
vector element in the lower or upper half of the first source SIMD&FP register
by the specified vector element of the second source SIMD&FP register, places
the result in a vector, and writes the vector to the destination SIMD&FP
register. The destination vector elements are twice as long as the elements
that are multiplied.

The `SMULL` instruction extracts vector elements from the lower half of the
first source register. The `SMULL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMULL--SMULL---by-element---Signed-multiply-long--vector--by-element--"
    )
    this["smullb"] = OpCodeDoc(
        "SMULLB",
        """Multiply the corresponding even-numbered signed elements of the first and
second source vectors, and place the results in the overlapping double-width
elements of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMULLB--vectors----"
    )
    this["smullt"] = OpCodeDoc(
        "SMULLT",
        """Multiply the corresponding odd-numbered signed elements of the first and
second source vectors, and place the results in the overlapping double-width
elements of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SMULLT--vectors----"
    )
    this["splice"] = OpCodeDoc(
        "SPLICE",
        """Select a region from the first source vector and copy it to the lowest-
numbered elements of the result. Then set any remaining elements of the result
to a copy of the lowest-numbered elements from the second source vector. The
region is selected using the first and last true elements in the vector select
predicate register. The result is placed destructively in the destination and
first source vector, or constructively in the destination vector.

The Destructive encoding of this instruction might be immediately preceded in
program order by a MOVPRFX instruction. The MOVPRFX instruction must conform
to all of the following requirements, otherwise the behavior of the MOVPRFX
and this instruction is UNPREDICTABLE: The MOVPRFX instruction must be
unpredicated. The MOVPRFX instruction must specify the same destination
register as this instruction. The destination register must not refer to
architectural register state referenced by any other source operand register
of this instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SPLICE---"
    )
    this["sqabs"] = OpCodeDoc(
        "SQABS",
        """Signed saturating Absolute value. This instruction reads each vector element
from the source SIMD&FP register, puts the absolute value of the result into a
vector, and writes the vector to the destination SIMD&FP register. All the
values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQABS--Signed-saturating-absolute-value-"
    )
    this["sqadd"] = OpCodeDoc(
        "SQADD",
        """Signed saturating Add. This instruction adds the values of corresponding
elements of the two source SIMD&FP registers, places the results into a
vector, and writes the vector to the destination SIMD&FP register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQADD--Signed-saturating-add-"
    )
    this["sqadd"] = OpCodeDoc(
        "SQADD",
        """Signed saturating add of an unsigned immediate to each element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. Each result element is saturated to the N-bit element's
signed integer range -2(N-1)  to (2(N-1) )-1. This instruction is
unpredicated.

The immediate is an unsigned value in the range 0 to 255, and for element
widths of 16 bits or higher it may also be a positive multiple of 256 in the
range 256 to 65280.

The immediate is encoded in 8 bits with an optional left shift by 8. The
preferred disassembly when the shift option is specified is "#<uimm8>, LSL
#8". However an assembler and disassembler may also allow use of the shifted
16-bit value unless the immediate is 0 and the shift amount is 8, which must
be unambiguously described as "#0, LSL #8".

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQADD--immediate----"
    )
    this["sqcadd"] = OpCodeDoc(
        "SQCADD",
        """Add the real and imaginary components of the integral complex numbers from the
first source vector to the complex numbers from the second source vector which
have first been rotated by 90 or 270 degrees in the direction from the
positive real axis towards the positive imaginary axis, when considered in
polar representation, equivalent to multiplying the complex numbers in the
second source vector by j beforehand. Destructively place the results in the
corresponding elements of the first source vector. Each result element is
saturated to the N-bit element's signed integer range -2(N-1)  to (2(N-1) )-1.
This instruction is unpredicated.

Each complex number is represented in a vector register as an even/odd pair of
elements with the real part in the even-numbered element and the imaginary
part in the odd-numbered element.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQCADD---"
    )
    this["sqcvt"] = OpCodeDoc(
        "SQCVT",
        """Saturate the signed integer value in each element of the two source vectors to
half the original source element width, and place the results in the half-
width destination elements.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQCVT--two-registers----"
    )
    this["sqcvtn"] = OpCodeDoc(
        "SQCVTN",
        """Saturate the signed integer value in each element of the group of two source
vectors to half the original source element width, and place the two-way
interleaved results in the half-width destination elements.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQCVTN---"
    )
    this["sqcvtu"] = OpCodeDoc(
        "SQCVTU",
        """Saturate the signed integer value in each element of the two source vectors to
unsigned integer value that is half the original source element width, and
place the results in the half-width destination elements.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQCVTU--two-registers----"
    )
    this["sqcvtun"] = OpCodeDoc(
        "SQCVTUN",
        """Saturate the signed integer value in each element of the group of two source
vectors to unsigned integer value that is half the original source element
width, and place the two-way interleaved results in the half-width destination
elements.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQCVTUN---"
    )
    this["sqdecb"] = OpCodeDoc(
        "SQDECB",
        """Determines the number of active 8-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination. The result is
saturated to the source general-purpose register's signed integer range. A
32-bit saturated result is then sign-extended to 64 bits.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDECB---"
    )
    this["sqdecd"] = OpCodeDoc(
        "SQDECD",
        """Determines the number of active 64-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination. The result is
saturated to the source general-purpose register's signed integer range. A
32-bit saturated result is then sign-extended to 64 bits.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDECD--scalar----"
    )
    this["sqdech"] = OpCodeDoc(
        "SQDECH",
        """Determines the number of active 16-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination. The result is
saturated to the source general-purpose register's signed integer range. A
32-bit saturated result is then sign-extended to 64 bits.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDECH--scalar----"
    )
    this["sqdecp"] = OpCodeDoc(
        "SQDECP",
        """Counts the number of true elements in the source predicate and then uses the
result to decrement the scalar destination. The result is saturated to the
source general-purpose register's signed integer range. A 32-bit saturated
result is then sign-extended to 64 bits.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDECP--scalar----"
    )
    this["sqdecw"] = OpCodeDoc(
        "SQDECW",
        """Determines the number of active 32-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination. The result is
saturated to the source general-purpose register's signed integer range. A
32-bit saturated result is then sign-extended to 64 bits.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDECW--scalar----"
    )
    this["sqdmlal"] = OpCodeDoc(
        "SQDMLAL",
        """Signed saturating Doubling Multiply-Add Long (by element). This instruction
multiplies each vector element in the lower or upper half of the first source
SIMD&FP register by the specified vector element of the second source SIMD&FP
register, doubles the results, and accumulates the final results with the
vector elements of the destination SIMD&FP register. The destination vector
elements are twice as long as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQDMLAL` instruction extracts vector elements from the lower half of the
first source register. The `SQDMLAL2` instruction extracts vector elements
from the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLAL--SQDMLAL---by-element---Signed-saturating-doubling-multiply-add-long--by-element--"
    )
    this["sqdmlal2"] = OpCodeDoc(
        "SQDMLAL2",
        """Signed saturating Doubling Multiply-Add Long (by element). This instruction
multiplies each vector element in the lower or upper half of the first source
SIMD&FP register by the specified vector element of the second source SIMD&FP
register, doubles the results, and accumulates the final results with the
vector elements of the destination SIMD&FP register. The destination vector
elements are twice as long as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQDMLAL` instruction extracts vector elements from the lower half of the
first source register. The `SQDMLAL2` instruction extracts vector elements
from the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLAL--SQDMLAL---by-element---Signed-saturating-doubling-multiply-add-long--by-element--"
    )
    this["sqdmlalb"] = OpCodeDoc(
        "SQDMLALB",
        """Multiply then double the corresponding even-numbered signed elements of the
first and second source vectors. Each intermediate value is saturated to the
double-width N-bit value's signed integer range -2(N-1)  to (2(N-1) )-1. Then
destructively add to the overlapping double-width elements of the addend and
destination vector. Each destination element is saturated to the double-width
N-bit element's signed integer range -2(N-1)  to (2(N-1) )-1. This instruction
is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLALB--vectors----"
    )
    this["sqdmlalbt"] = OpCodeDoc(
        "SQDMLALBT",
        """Multiply then double the corresponding even-numbered signed elements of the
first and odd-numbered signed elements of the second source vector. Each
intermediate value is saturated to the double-width N-bit value's signed
integer range -2(N-1)  to (2(N-1) )-1. Then destructively add to the
overlapping double-width elements of the addend and destination vector. Each
destination element is saturated to the double-width N-bit element's signed
integer range -2(N-1)  to (2(N-1) )-1. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLALBT---"
    )
    this["sqdmlalt"] = OpCodeDoc(
        "SQDMLALT",
        """Multiply then double the corresponding odd-numbered signed elements of the
first and second source vectors. Each intermediate value is saturated to the
double-width N-bit value's signed integer range -2(N-1)  to (2(N-1) )-1. Then
destructively add to the overlapping double-width elements of the addend and
destination vector. Each destination element is saturated to the double-width
N-bit element's signed integer range -2(N-1)  to (2(N-1) )-1. This instruction
is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLALT--vectors----"
    )
    this["sqdmlsl"] = OpCodeDoc(
        "SQDMLSL",
        """Signed saturating Doubling Multiply-Subtract Long (by element). This
instruction multiplies each vector element in the lower or upper half of the
first source SIMD&FP register by the specified vector element of the second
source SIMD&FP register, doubles the results, and subtracts the final results
from the vector elements of the destination SIMD&FP register. The destination
vector elements are twice as long as the elements that are multiplied. All the
values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQDMLSL` instruction extracts vector elements from the lower half of the
first source register. The `SQDMLSL2` instruction extracts vector elements
from the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLSL--SQDMLSL---by-element---Signed-saturating-doubling-multiply-subtract-long--by-element--"
    )
    this["sqdmlsl2"] = OpCodeDoc(
        "SQDMLSL2",
        """Signed saturating Doubling Multiply-Subtract Long (by element). This
instruction multiplies each vector element in the lower or upper half of the
first source SIMD&FP register by the specified vector element of the second
source SIMD&FP register, doubles the results, and subtracts the final results
from the vector elements of the destination SIMD&FP register. The destination
vector elements are twice as long as the elements that are multiplied. All the
values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQDMLSL` instruction extracts vector elements from the lower half of the
first source register. The `SQDMLSL2` instruction extracts vector elements
from the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLSL--SQDMLSL---by-element---Signed-saturating-doubling-multiply-subtract-long--by-element--"
    )
    this["sqdmlslb"] = OpCodeDoc(
        "SQDMLSLB",
        """Multiply then double the corresponding even-numbered signed elements of the
first and second source vectors. Each intermediate value is saturated to the
double-width N-bit value's signed integer range -2(N-1)  to (2(N-1) )-1. Then
destructively subtract from the overlapping double-width elements of the
addend and destination vector. Each destination element is saturated to the
double-width N-bit element's signed integer range -2(N-1)  to (2(N-1) )-1.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLSLB--vectors----"
    )
    this["sqdmlslbt"] = OpCodeDoc(
        "SQDMLSLBT",
        """Multiply then double the corresponding even-numbered signed elements of the
first and odd-numbered signed elements of the second source vector. Each
intermediate value is saturated to the double-width N-bit value's signed
integer range -2(N-1)  to (2(N-1) )-1. Then destructively subtract from the
overlapping double-width elements of the addend and destination vector. Each
destination element is saturated to the double-width N-bit element's signed
integer range -2(N-1)  to (2(N-1) )-1. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLSLBT---"
    )
    this["sqdmlslt"] = OpCodeDoc(
        "SQDMLSLT",
        """Multiply then double the corresponding odd-numbered signed elements of the
first and second source vectors. Each intermediate value is saturated to the
double-width N-bit value's signed integer range -2(N-1)  to (2(N-1) )-1. Then
destructively subtract from the overlapping double-width elements of the
addend and destination vector. Each destination element is saturated to the
double-width N-bit element's signed integer range -2(N-1)  to (2(N-1) )-1.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMLSLT--vectors----"
    )
    this["sqdmulh"] = OpCodeDoc(
        "SQDMULH",
        """Signed saturating Doubling Multiply returning High half (by element). This
instruction multiplies each vector element in the first source SIMD&FP
register by the specified vector element of the second source SIMD&FP
register, doubles the results, places the most significant half of the final
results into a vector, and writes the vector to the destination SIMD&FP
register.

The results are truncated. For rounded results, see SQRDMULH.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMULH--by-element---Signed-saturating-doubling-multiply-returning-high-half--by-element--"
    )
    this["sqdmull"] = OpCodeDoc(
        "SQDMULL",
        """Signed saturating Doubling Multiply Long (by element). This instruction
multiplies each vector element in the lower or upper half of the first source
SIMD&FP register by the specified vector element of the second source SIMD&FP
register, doubles the results, places the final results in a vector, and
writes the vector to the destination SIMD&FP register. All the values in this
instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQDMULL` instruction extracts the first source vector from the lower half
of the first source register. The `SQDMULL2` instruction extracts the first
source vector from the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMULL--SQDMULL---by-element---Signed-saturating-doubling-multiply-long--by-element--"
    )
    this["sqdmull2"] = OpCodeDoc(
        "SQDMULL2",
        """Signed saturating Doubling Multiply Long (by element). This instruction
multiplies each vector element in the lower or upper half of the first source
SIMD&FP register by the specified vector element of the second source SIMD&FP
register, doubles the results, places the final results in a vector, and
writes the vector to the destination SIMD&FP register. All the values in this
instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQDMULL` instruction extracts the first source vector from the lower half
of the first source register. The `SQDMULL2` instruction extracts the first
source vector from the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMULL--SQDMULL---by-element---Signed-saturating-doubling-multiply-long--by-element--"
    )
    this["sqdmullb"] = OpCodeDoc(
        "SQDMULLB",
        """Multiply the corresponding even-numbered signed elements of the first and
second source vectors, double and place the results in the overlapping double-
width elements of the destination vector. Each result element is saturated to
the double-width N-bit element's signed integer range -2(N-1)  to (2(N-1) )-1.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMULLB--vectors----"
    )
    this["sqdmullt"] = OpCodeDoc(
        "SQDMULLT",
        """Multiply the corresponding odd-numbered signed elements of the first and
second source vectors, double and place the results in the overlapping double-
width elements of the destination vector. Each result element is saturated to
the double-width N-bit element's signed integer range -2(N-1)  to (2(N-1) )-1.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQDMULLT--vectors----"
    )
    this["sqincb"] = OpCodeDoc(
        "SQINCB",
        """Determines the number of active 8-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination. The result is
saturated to the source general-purpose register's signed integer range. A
32-bit saturated result is then sign-extended to 64 bits.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQINCB---"
    )
    this["sqincd"] = OpCodeDoc(
        "SQINCD",
        """Determines the number of active 64-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination. The result is
saturated to the source general-purpose register's signed integer range. A
32-bit saturated result is then sign-extended to 64 bits.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQINCD--scalar----"
    )
    this["sqinch"] = OpCodeDoc(
        "SQINCH",
        """Determines the number of active 16-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination. The result is
saturated to the source general-purpose register's signed integer range. A
32-bit saturated result is then sign-extended to 64 bits.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQINCH--scalar----"
    )
    this["sqincp"] = OpCodeDoc(
        "SQINCP",
        """Counts the number of true elements in the source predicate and then uses the
result to increment the scalar destination. The result is saturated to the
source general-purpose register's signed integer range. A 32-bit saturated
result is then sign-extended to 64 bits.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQINCP--scalar----"
    )
    this["sqincw"] = OpCodeDoc(
        "SQINCW",
        """Determines the number of active 32-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination. The result is
saturated to the source general-purpose register's signed integer range. A
32-bit saturated result is then sign-extended to 64 bits.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQINCW--scalar----"
    )
    this["sqneg"] = OpCodeDoc(
        "SQNEG",
        """Signed saturating Negate. This instruction reads each vector element from the
source SIMD&FP register, negates each value, places the result into a vector,
and writes the vector to the destination SIMD&FP register. All the values in
this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQNEG--Signed-saturating-negate-"
    )
    this["sqrdcmlah"] = OpCodeDoc(
        "SQRDCMLAH",
        """Multiply without saturation the duplicated real components for rotations 0 and
180, or imaginary components for rotations 90 and 270, of the integral numbers
in the first source vector by the corresponding complex number in the second
source vector rotated by 0, 90, 180 or 270 degrees in the direction from the
positive real axis towards the positive imaginary axis, when considered in
polar representation.

Then double and add the products to the corresponding components of the
complex numbers in the addend vector. Destructively place the most significant
rounded half of the results in the corresponding elements of the addend
vector. Each result element is saturated to the N-bit element's signed integer
range -2(N-1)  to (2(N-1) )-1. This instruction is unpredicated.

These transformations permit the creation of a variety of multiply-add and
multiply-subtract operations on complex numbers by combining two of these
instructions with the same vector operands but with rotations that are 90
degrees apart.

Each complex number is represented in a vector register as an even/odd pair of
elements with the real part in the even-numbered element and the imaginary
part in the odd-numbered element.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRDCMLAH--vectors----"
    )
    this["sqrdmlah"] = OpCodeDoc(
        "SQRDMLAH",
        """Signed Saturating Rounding Doubling Multiply Accumulate returning High Half
(by element). This instruction multiplies the vector elements of the first
source SIMD&FP register with the value of a vector element of the second
source SIMD&FP register without saturating the multiply results, doubles the
results, and accumulates the most significant half of the final results with
the vector elements of the destination SIMD&FP register. The results are
rounded.

If any of the results overflow, they are saturated. The cumulative saturation
bit, FPSR.QC, is set if saturation occurs.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRDMLAH--by-element---Signed-saturating-rounding-doubling-multiply-accumulate-returning-high-half--by-element--"
    )
    this["sqrdmlsh"] = OpCodeDoc(
        "SQRDMLSH",
        """Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by
element). This instruction multiplies the vector elements of the first source
SIMD&FP register with the value of a vector element of the second source
SIMD&FP register without saturating the multiply results, doubles the results,
and subtracts the most significant half of the final results from the vector
elements of the destination SIMD&FP register. The results are rounded.

If any of the results overflow, they are saturated. The cumulative saturation
bit, FPSR.QC, is set if saturation occurs.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRDMLSH--by-element---Signed-saturating-rounding-doubling-multiply-subtract-returning-high-half--by-element--"
    )
    this["sqrdmulh"] = OpCodeDoc(
        "SQRDMULH",
        """Signed saturating Rounding Doubling Multiply returning High half (by element).
This instruction multiplies each vector element in the first source SIMD&FP
register by the specified vector element of the second source SIMD&FP
register, doubles the results, places the most significant half of the final
results into a vector, and writes the vector to the destination SIMD&FP
register.

The results are rounded. For truncated results, see SQDMULH.

If any of the results overflows, they are saturated. If saturation occurs, the
cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRDMULH--by-element---Signed-saturating-rounding-doubling-multiply-returning-high-half--by-element--"
    )
    this["sqrshl"] = OpCodeDoc(
        "SQRSHL",
        """Signed saturating Rounding Shift Left (register). This instruction takes each
vector element in the first source SIMD&FP register, shifts it by a value from
the least significant byte of the corresponding vector element of the second
source SIMD&FP register, places the results into a vector, and writes the
vector to the destination SIMD&FP register.

If the shift value is positive, the operation is a left shift. Otherwise, it
is a right shift. The results are rounded. For truncated results, see SQSHL.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHL--Signed-saturating-rounding-shift-left--register--"
    )
    this["sqrshlr"] = OpCodeDoc(
        "SQRSHLR",
        """Shift active signed elements of the second source vector by corresponding
elements of the first source vector and destructively place the rounded
results in the corresponding elements of the first source vector. A positive
shift amount performs a left shift, otherwise a right shift by the negated
shift amount is performed. Each result element is saturated to the N-bit
element's signed integer range -2(N-1)  to (2(N-1) )-1. Inactive elements in
the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHLR---"
    )
    this["sqrshr"] = OpCodeDoc(
        "SQRSHR",
        """Shift right by an immediate value, the signed integer value in each element of
the two source vectors and place the rounded results in the half-width
destination elements. Each result element is saturated to the half-width N-bit
element's signed integer range -2(N-1) to (2(N-1))-1. The immediate shift
amount is an unsigned value in the range 1 to 16.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHR--two-registers----"
    )
    this["sqrshrn"] = OpCodeDoc(
        "SQRSHRN",
        """Signed saturating Rounded Shift Right Narrow (immediate). This instruction
reads each vector element in the source SIMD&FP register, right shifts each
result by an immediate value, saturates each shifted result to a value that is
half the original width, puts the final result into a vector, and writes the
vector to the lower or upper half of the destination SIMD&FP register. All the
values in this instruction are signed integer values. The destination vector
elements are half as long as the source vector elements. The results are
rounded. For truncated results, see SQSHRN.

The `SQRSHRN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQRSHRN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHRN--SQRSHRN---Signed-saturating-rounded-shift-right-narrow--immediate--"
    )
    this["sqrshrn2"] = OpCodeDoc(
        "SQRSHRN2",
        """Signed saturating Rounded Shift Right Narrow (immediate). This instruction
reads each vector element in the source SIMD&FP register, right shifts each
result by an immediate value, saturates each shifted result to a value that is
half the original width, puts the final result into a vector, and writes the
vector to the lower or upper half of the destination SIMD&FP register. All the
values in this instruction are signed integer values. The destination vector
elements are half as long as the source vector elements. The results are
rounded. For truncated results, see SQSHRN.

The `SQRSHRN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQRSHRN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHRN--SQRSHRN---Signed-saturating-rounded-shift-right-narrow--immediate--"
    )
    this["sqrshrnb"] = OpCodeDoc(
        "SQRSHRNB",
        """Shift each signed integer value in the source vector elements right by an
immediate value, and place the rounded results in the even-numbered half-width
destination elements, while setting the odd-numbered elements to zero. Each
result element is saturated to the half-width N-bit element's signed integer
range -2(N-1)  to (2(N-1) )-1. The immediate shift amount is an unsigned value
in the range 1 to number of bits per element. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHRNB---"
    )
    this["sqrshrnt"] = OpCodeDoc(
        "SQRSHRNT",
        """Shift each signed integer value in the source vector elements right by an
immediate value, and place the rounded results in the odd-numbered half-width
destination elements, leaving the even-numbered elements unchanged. Each
result element is saturated to the half-width N-bit element's signed integer
range -2(N-1)  to (2(N-1) )-1. The immediate shift amount is an unsigned value
in the range 1 to number of bits per element. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHRNT---"
    )
    this["sqrshru"] = OpCodeDoc(
        "SQRSHRU",
        """Shift right by an immediate value, the signed integer value in each element of
the two source vectors and place the rounded results in the half-width
destination elements. Each result element is saturated to the half-width N-bit
element's unsigned integer range 0 to (2N)-1. The immediate shift amount is an
unsigned value in the range 1 to 16.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHRU--two-registers----"
    )
    this["sqrshrun"] = OpCodeDoc(
        "SQRSHRUN",
        """Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This
instruction reads each signed integer value in the vector of the source
SIMD&FP register, right shifts each value by an immediate value, saturates the
result to an unsigned integer value that is half the original width, places
the final result into a vector, and writes the vector to the destination
SIMD&FP register. The results are rounded. For truncated results, see SQSHRUN.

The `SQRSHRUN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQRSHRUN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHRUN--SQRSHRUN---Signed-saturating-rounded-shift-right-unsigned-narrow--immediate--"
    )
    this["sqrshrun2"] = OpCodeDoc(
        "SQRSHRUN2",
        """Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This
instruction reads each signed integer value in the vector of the source
SIMD&FP register, right shifts each value by an immediate value, saturates the
result to an unsigned integer value that is half the original width, places
the final result into a vector, and writes the vector to the destination
SIMD&FP register. The results are rounded. For truncated results, see SQSHRUN.

The `SQRSHRUN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQRSHRUN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHRUN--SQRSHRUN---Signed-saturating-rounded-shift-right-unsigned-narrow--immediate--"
    )
    this["sqrshrunb"] = OpCodeDoc(
        "SQRSHRUNB",
        """Shift each signed integer value in the source vector elements right by an
immediate value, and place the rounded results in the even-numbered half-width
destination elements, while setting the odd-numbered elements to zero. Each
result element is saturated to the half-width N-bit element's unsigned integer
range 0 to (2N)-1. The immediate shift amount is an unsigned value in the
range 1 to number of bits per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHRUNB---"
    )
    this["sqrshrunt"] = OpCodeDoc(
        "SQRSHRUNT",
        """Shift each signed integer value in the source vector elements right by an
immediate value, and place the rounded results in the odd-numbered half-width
destination elements, leaving the even-numbered elements unchanged. Each
result element is saturated to the half-width N-bit element's unsigned integer
range 0 to (2N)-1. The immediate shift amount is an unsigned value in the
range 1 to number of bits per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQRSHRUNT---"
    )
    this["sqshl"] = OpCodeDoc(
        "SQSHL",
        """Signed saturating Shift Left (immediate). This instruction reads each vector
element in the source SIMD&FP register, shifts each result by an immediate
value, places the final result in a vector, and writes the vector to the
destination SIMD&FP register. The results are truncated. For rounded results,
see UQRSHL.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHL--immediate---Signed-saturating-shift-left--immediate--"
    )
    this["sqshl"] = OpCodeDoc(
        "SQSHL",
        """Signed saturating Shift Left (register). This instruction takes each element
in the vector of the first source SIMD&FP register, shifts each element by a
value from the least significant byte of the corresponding element of the
second source SIMD&FP register, places the results in a vector, and writes the
vector to the destination SIMD&FP register.

If the shift value is positive, the operation is a left shift. Otherwise, it
is a right shift. The results are truncated. For rounded results, see SQRSHL.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHL--register---Signed-saturating-shift-left--register--"
    )
    this["sqshl"] = OpCodeDoc(
        "SQSHL",
        """Shift left by immediate each active signed element of the source vector, and
destructively place the results in the corresponding elements of the source
vector. Each result element is saturated to the N-bit element's signed integer
range -2(N-1)  to (2(N-1) )-1. The immediate shift amount is an unsigned value
in the range 0 to number of bits per element minus 1. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHL--immediate----"
    )
    this["sqshlr"] = OpCodeDoc(
        "SQSHLR",
        """Shift active signed elements of the second source vector by corresponding
elements of the first source vector and destructively place the results in the
corresponding elements of the first source vector. A positive shift amount
performs a left shift, otherwise a right shift by the negated shift amount is
performed. Each result element is saturated to the N-bit element's signed
integer range -2(N-1)  to (2(N-1) )-1. Inactive elements in the destination
vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHLR---"
    )
    this["sqshlu"] = OpCodeDoc(
        "SQSHLU",
        """Signed saturating Shift Left Unsigned (immediate). This instruction reads each
signed integer value in the vector of the source SIMD&FP register, shifts each
value by an immediate value, saturates the shifted result to an unsigned
integer value, places the result in a vector, and writes the vector to the
destination SIMD&FP register. The results are truncated. For rounded results,
see UQRSHL.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHLU--Signed-saturating-shift-left-unsigned--immediate--"
    )
    this["sqshrn"] = OpCodeDoc(
        "SQSHRN",
        """Signed saturating Shift Right Narrow (immediate). This instruction reads each
vector element in the source SIMD&FP register, right shifts and truncates each
result by an immediate value, saturates each shifted result to a value that is
half the original width, puts the final result into a vector, and writes the
vector to the lower or upper half of the destination SIMD&FP register. All the
values in this instruction are signed integer values. The destination vector
elements are half as long as the source vector elements. For rounded results,
see SQRSHRN.

The `SQSHRN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQSHRN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHRN--SQSHRN---Signed-saturating-shift-right-narrow--immediate--"
    )
    this["sqshrn2"] = OpCodeDoc(
        "SQSHRN2",
        """Signed saturating Shift Right Narrow (immediate). This instruction reads each
vector element in the source SIMD&FP register, right shifts and truncates each
result by an immediate value, saturates each shifted result to a value that is
half the original width, puts the final result into a vector, and writes the
vector to the lower or upper half of the destination SIMD&FP register. All the
values in this instruction are signed integer values. The destination vector
elements are half as long as the source vector elements. For rounded results,
see SQRSHRN.

The `SQSHRN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQSHRN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHRN--SQSHRN---Signed-saturating-shift-right-narrow--immediate--"
    )
    this["sqshrnb"] = OpCodeDoc(
        "SQSHRNB",
        """Shift each signed integer value in the source vector elements right by an
immediate value, and place the truncated results in the even-numbered half-
width destination elements, while setting the odd-numbered elements to zero.
Each result element is saturated to the half-width N-bit element's signed
integer range -2(N-1)  to (2(N-1) )-1. The immediate shift amount is an
unsigned value in the range 1 to number of bits per element. This instruction
is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHRNB---"
    )
    this["sqshrnt"] = OpCodeDoc(
        "SQSHRNT",
        """Shift each signed integer value in the source vector elements right by an
immediate value, and place the truncated results in the odd-numbered half-
width destination elements, leaving the even-numbered elements unchanged. Each
result element is saturated to the half-width N-bit element's signed integer
range -2(N-1)  to (2(N-1) )-1. The immediate shift amount is an unsigned value
in the range 1 to number of bits per element. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHRNT---"
    )
    this["sqshrun"] = OpCodeDoc(
        "SQSHRUN",
        """Signed saturating Shift Right Unsigned Narrow (immediate). This instruction
reads each signed integer value in the vector of the source SIMD&FP register,
right shifts each value by an immediate value, saturates the result to an
unsigned integer value that is half the original width, places the final
result into a vector, and writes the vector to the destination SIMD&FP
register. The results are truncated. For rounded results, see SQRSHRUN.

The `SQSHRUN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQSHRUN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHRUN--SQSHRUN---Signed-saturating-shift-right-unsigned-narrow--immediate--"
    )
    this["sqshrun2"] = OpCodeDoc(
        "SQSHRUN2",
        """Signed saturating Shift Right Unsigned Narrow (immediate). This instruction
reads each signed integer value in the vector of the source SIMD&FP register,
right shifts each value by an immediate value, saturates the result to an
unsigned integer value that is half the original width, places the final
result into a vector, and writes the vector to the destination SIMD&FP
register. The results are truncated. For rounded results, see SQRSHRUN.

The `SQSHRUN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQSHRUN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHRUN--SQSHRUN---Signed-saturating-shift-right-unsigned-narrow--immediate--"
    )
    this["sqshrunb"] = OpCodeDoc(
        "SQSHRUNB",
        """Shift each signed integer value in the source vector elements right by an
immediate value, and place the truncated results in the even-numbered half-
width destination elements, while setting the odd-numbered elements to zero.
Each result element is saturated to the half-width N-bit element's unsigned
integer range 0 to (2N)-1. The immediate shift amount is an unsigned value in
the range 1 to number of bits per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHRUNB---"
    )
    this["sqshrunt"] = OpCodeDoc(
        "SQSHRUNT",
        """Shift each signed integer value in the source vector elements right by an
immediate value, and place the truncated results in the odd-numbered half-
width destination elements, leaving the even-numbered elements unchanged. Each
result element is saturated to the half-width N-bit element's unsigned integer
range 0 to (2N)-1. The immediate shift amount is an unsigned value in the
range 1 to number of bits per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSHRUNT---"
    )
    this["sqsub"] = OpCodeDoc(
        "SQSUB",
        """Signed saturating Subtract. This instruction subtracts the element values of
the second source SIMD&FP register from the corresponding element values of
the first source SIMD&FP register, places the results into a vector, and
writes the vector to the destination SIMD&FP register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSUB--Signed-saturating-subtract-"
    )
    this["sqsub"] = OpCodeDoc(
        "SQSUB",
        """Signed saturating subtract of an unsigned immediate from each element of the
source vector, and destructively place the results in the corresponding
elements of the source vector. Each result element is saturated to the N-bit
element's signed integer range -2(N-1)  to (2(N-1) )-1. This instruction is
unpredicated.

The immediate is an unsigned value in the range 0 to 255, and for element
widths of 16 bits or higher it may also be a positive multiple of 256 in the
range 256 to 65280.

The immediate is encoded in 8 bits with an optional left shift by 8. The
preferred disassembly when the shift option is specified is "#<uimm8>, LSL
#8". However an assembler and disassembler may also allow use of the shifted
16-bit value unless the immediate is 0 and the shift amount is 8, which must
be unambiguously described as "#0, LSL #8".

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSUB--immediate----"
    )
    this["sqsubr"] = OpCodeDoc(
        "SQSUBR",
        """Subtract active signed elements of the first source vector from corresponding
signed elements of the second source vector and destructively place the
results in the corresponding elements of the first source vector. Each result
element is saturated to the N-bit element's signed integer range -2(N-1)  to
(2(N-1) )-1. Inactive elements in the destination vector register remain
unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQSUBR---"
    )
    this["sqxtn"] = OpCodeDoc(
        "SQXTN",
        """Signed saturating extract Narrow. This instruction reads each vector element
from the source SIMD&FP register, saturates the value to half the original
width, places the result into a vector, and writes the vector to the lower or
upper half of the destination SIMD&FP register. The destination vector
elements are half as long as the source vector elements. All the values in
this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQXTN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `SQXTN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQXTN--SQXTN---Signed-saturating-extract-narrow-"
    )
    this["sqxtn2"] = OpCodeDoc(
        "SQXTN2",
        """Signed saturating extract Narrow. This instruction reads each vector element
from the source SIMD&FP register, saturates the value to half the original
width, places the result into a vector, and writes the vector to the lower or
upper half of the destination SIMD&FP register. The destination vector
elements are half as long as the source vector elements. All the values in
this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQXTN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `SQXTN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQXTN--SQXTN---Signed-saturating-extract-narrow-"
    )
    this["sqxtnb"] = OpCodeDoc(
        "SQXTNB",
        """Saturate the signed integer value in each source element to half the original
source element width, and place the results in the even-numbered half-width
destination elements, while setting the odd-numbered elements to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQXTNB---"
    )
    this["sqxtnt"] = OpCodeDoc(
        "SQXTNT",
        """Saturate the signed integer value in each source element to half the original
source element width, and place the results in the odd-numbered half-width
destination elements, leaving the even-numbered elements unchanged.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQXTNT---"
    )
    this["sqxtun"] = OpCodeDoc(
        "SQXTUN",
        """Signed saturating extract Unsigned Narrow. This instruction reads each signed
integer value in the vector of the source SIMD&FP register, saturates the
value to an unsigned integer value that is half the original width, places the
result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register. The destination vector elements are half as long
as the source vector elements.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQXTUN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQXTUN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQXTUN--SQXTUN---Signed-saturating-extract-unsigned-narrow-"
    )
    this["sqxtun2"] = OpCodeDoc(
        "SQXTUN2",
        """Signed saturating extract Unsigned Narrow. This instruction reads each signed
integer value in the vector of the source SIMD&FP register, saturates the
value to an unsigned integer value that is half the original width, places the
result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register. The destination vector elements are half as long
as the source vector elements.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `SQXTUN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `SQXTUN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQXTUN--SQXTUN---Signed-saturating-extract-unsigned-narrow-"
    )
    this["sqxtunb"] = OpCodeDoc(
        "SQXTUNB",
        """Saturate the signed integer value in each source element to an unsigned
integer value that is half the original source element width, and place the
results in the even-numbered half-width destination elements, while setting
the odd-numbered elements to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQXTUNB---"
    )
    this["sqxtunt"] = OpCodeDoc(
        "SQXTUNT",
        """Saturate the signed integer value in each source element to an unsigned
integer value that is half the original source element width, and place the
results in the odd-numbered half-width destination elements, leaving the even-
numbered elements unchanged.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SQXTUNT---"
    )
    this["srhadd"] = OpCodeDoc(
        "SRHADD",
        """Signed Rounding Halving Add. This instruction adds corresponding signed
integer values from the two source SIMD&FP registers, shifts each result right
one bit, places the results into a vector, and writes the vector to the
destination SIMD&FP register.

The results are rounded. For truncated results, see SHADD.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SRHADD--Signed-rounding-halving-add-"
    )
    this["sri"] = OpCodeDoc(
        "SRI",
        """Shift Right and Insert (immediate). This instruction reads each vector element
in the source SIMD&FP register, right shifts each vector element by an
immediate value, and inserts the result into the corresponding vector element
in the destination SIMD&FP register such that the new zero bits created by the
shift are not inserted but retain their existing value. Bits shifted out of
the right of each vector element of the source register are lost.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SRI--Shift-right-and-insert--immediate--"
    )
    this["srshl"] = OpCodeDoc(
        "SRSHL",
        """Signed Rounding Shift Left (register). This instruction takes each signed
integer value in the vector of the first source SIMD&FP register, shifts it by
a value from the least significant byte of the corresponding element of the
second source SIMD&FP register, places the results in a vector, and writes the
vector to the destination SIMD&FP register.

If the shift value is positive, the operation is a left shift. If the shift
value is negative, it is a rounding right shift. For a truncating shift, see
SSHL.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SRSHL--Signed-rounding-shift-left--register--"
    )
    this["srshlr"] = OpCodeDoc(
        "SRSHLR",
        """Shift active signed elements of the second source vector by corresponding
elements of the first source vector and destructively place the rounded
results in the corresponding elements of the first source vector. A positive
shift amount performs a left shift, otherwise a right shift by the negated
shift amount is performed. Inactive elements in the destination vector
register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SRSHLR---"
    )
    this["srshr"] = OpCodeDoc(
        "SRSHR",
        """Signed Rounding Shift Right (immediate). This instruction reads each vector
element in the source SIMD&FP register, right shifts each result by an
immediate value, places the final result into a vector, and writes the vector
to the destination SIMD&FP register. All the values in this instruction are
signed integer values. The results are rounded. For truncated results, see
SSHR.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SRSHR--Signed-rounding-shift-right--immediate--"
    )
    this["srsra"] = OpCodeDoc(
        "SRSRA",
        """Signed Rounding Shift Right and Accumulate (immediate). This instruction reads
each vector element in the source SIMD&FP register, right shifts each result
by an immediate value, and accumulates the final results with the vector
elements of the destination SIMD&FP register. All the values in this
instruction are signed integer values. The results are rounded. For truncated
results, see SSRA.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SRSRA--Signed-rounding-shift-right-and-accumulate--immediate--"
    )
    this["ssbb"] = OpCodeDoc(
        "SSBB",
        """Speculative Store Bypass Barrier is a memory barrier that prevents speculative
loads from bypassing earlier stores to the same virtual address under certain
conditions. For more information and details of the semantics, see Speculative
Store Bypass Barrier (SSBB).

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSBB--Speculative-store-bypass-barrier-"
    )
    this["sshl"] = OpCodeDoc(
        "SSHL",
        """Signed Shift Left (register). This instruction takes each signed integer value
in the vector of the first source SIMD&FP register, shifts each value by a
value from the least significant byte of the corresponding element of the
second source SIMD&FP register, places the results in a vector, and writes the
vector to the destination SIMD&FP register.

If the shift value is positive, the operation is a left shift. If the shift
value is negative, it is a truncating right shift. For a rounding shift, see
SRSHL.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSHL--Signed-shift-left--register--"
    )
    this["sshll"] = OpCodeDoc(
        "SSHLL",
        """Signed Shift Left Long (immediate). This instruction reads each vector element
from the source SIMD&FP register, left shifts each vector element by the
specified shift amount, places the result into a vector, and writes the vector
to the destination SIMD&FP register. The destination vector elements are twice
as long as the source vector elements. All the values in this instruction are
signed integer values.

The `SSHLL` instruction extracts vector elements from the lower half of the
source register. The `SSHLL2` instruction extracts vector elements from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSHLL--SSHLL---Signed-shift-left-long--immediate--"
    )
    this["sshll2"] = OpCodeDoc(
        "SSHLL2",
        """Signed Shift Left Long (immediate). This instruction reads each vector element
from the source SIMD&FP register, left shifts each vector element by the
specified shift amount, places the result into a vector, and writes the vector
to the destination SIMD&FP register. The destination vector elements are twice
as long as the source vector elements. All the values in this instruction are
signed integer values.

The `SSHLL` instruction extracts vector elements from the lower half of the
source register. The `SSHLL2` instruction extracts vector elements from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSHLL--SSHLL---Signed-shift-left-long--immediate--"
    )
    this["sshllb"] = OpCodeDoc(
        "SSHLLB",
        """Shift left by immediate each even-numbered signed element of the source
vector, and place the results in the overlapping double-width elements of the
destination vector. The immediate shift amount is an unsigned value in the
range 0 to number of bits per element minus 1. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSHLLB---"
    )
    this["sshllt"] = OpCodeDoc(
        "SSHLLT",
        """Shift left by immediate each odd-numbered signed element of the source vector,
and place the results in the overlapping double-width elements of the
destination vector. The immediate shift amount is an unsigned value in the
range 0 to number of bits per element minus 1. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSHLLT---"
    )
    this["sshr"] = OpCodeDoc(
        "SSHR",
        """Signed Shift Right (immediate). This instruction reads each vector element in
the source SIMD&FP register, right shifts each result by an immediate value,
places the final result into a vector, and writes the vector to the
destination SIMD&FP register. All the values in this instruction are signed
integer values. The results are truncated. For rounded results, see SRSHR.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSHR--Signed-shift-right--immediate--"
    )
    this["ssra"] = OpCodeDoc(
        "SSRA",
        """Signed Shift Right and Accumulate (immediate). This instruction reads each
vector element in the source SIMD&FP register, right shifts each result by an
immediate value, and accumulates the final results with the vector elements of
the destination SIMD&FP register. All the values in this instruction are
signed integer values. The results are truncated. For rounded results, see
SRSRA.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSRA--Signed-shift-right-and-accumulate--immediate--"
    )
    this["ssubl"] = OpCodeDoc(
        "SSUBL",
        """Signed Subtract Long. This instruction subtracts each vector element in the
lower or upper half of the second source SIMD&FP register from the
corresponding vector element of the first source SIMD&FP register, places the
results into a vector, and writes the vector to the destination SIMD&FP
register. All the values in this instruction are signed integer values. The
destination vector elements are twice as long as the source vector elements.

The `SSUBL` instruction extracts each source vector from the lower half of
each source register. The `SSUBL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBL--SSUBL---Signed-subtract-long-"
    )
    this["ssubl2"] = OpCodeDoc(
        "SSUBL2",
        """Signed Subtract Long. This instruction subtracts each vector element in the
lower or upper half of the second source SIMD&FP register from the
corresponding vector element of the first source SIMD&FP register, places the
results into a vector, and writes the vector to the destination SIMD&FP
register. All the values in this instruction are signed integer values. The
destination vector elements are twice as long as the source vector elements.

The `SSUBL` instruction extracts each source vector from the lower half of
each source register. The `SSUBL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBL--SSUBL---Signed-subtract-long-"
    )
    this["ssublb"] = OpCodeDoc(
        "SSUBLB",
        """Subtract the even-numbered signed elements of the second source vector from
the corresponding signed elements of the first source vector, and place the
results in the overlapping double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBLB---"
    )
    this["ssublbt"] = OpCodeDoc(
        "SSUBLBT",
        """Subtract the odd-numbered signed elements of the second source vector from the
even-numbered signed elements of the first source vector, and place the
results in the overlapping double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBLBT---"
    )
    this["ssublt"] = OpCodeDoc(
        "SSUBLT",
        """Subtract the odd-numbered signed elements of the second source vector from the
corresponding signed elements of the first source vector, and place the
results in the overlapping double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBLT---"
    )
    this["ssubltb"] = OpCodeDoc(
        "SSUBLTB",
        """Subtract the even-numbered signed elements of the second source vector from
the odd-numbered signed elements of the first source vector, and place the
results in the overlapping double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBLTB---"
    )
    this["ssubw"] = OpCodeDoc(
        "SSUBW",
        """Signed Subtract Wide. This instruction subtracts each vector element in the
lower or upper half of the second source SIMD&FP register from the
corresponding vector element in the first source SIMD&FP register, places the
result in a vector, and writes the vector to the SIMD&FP destination register.
All the values in this instruction are signed integer values.

The `SSUBW` instruction extracts the second source vector from the lower half
of the second source register. The `SSUBW2` instruction extracts the second
source vector from the upper half of the second source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBW--SSUBW---Signed-subtract-wide-"
    )
    this["ssubw2"] = OpCodeDoc(
        "SSUBW2",
        """Signed Subtract Wide. This instruction subtracts each vector element in the
lower or upper half of the second source SIMD&FP register from the
corresponding vector element in the first source SIMD&FP register, places the
result in a vector, and writes the vector to the SIMD&FP destination register.
All the values in this instruction are signed integer values.

The `SSUBW` instruction extracts the second source vector from the lower half
of the second source register. The `SSUBW2` instruction extracts the second
source vector from the upper half of the second source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBW--SSUBW---Signed-subtract-wide-"
    )
    this["ssubwb"] = OpCodeDoc(
        "SSUBWB",
        """Subtract the even-numbered signed elements of the second source vector from
the overlapping double-width elements of the first source vector and place the
results in the corresponding double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBWB---"
    )
    this["ssubwt"] = OpCodeDoc(
        "SSUBWT",
        """Subtract the even-numbered signed elements of the second source vector from
the overlapping double-width elements of the first source vector and place the
results in the corresponding double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SSUBWT---"
    )
    this["st1"] = OpCodeDoc(
        "ST1",
        """Store multiple single-element structures from one, two, three, or four
registers. This instruction stores elements to memory from one, two, three, or
four SIMD&FP registers, without interleaving. Every element of each register
is stored.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST---multiple-structures---Store-multiple-single-element-structures-from-one--two--three--or-four-registers-"
    )
    this["st1b"] = OpCodeDoc(
        "ST1B",
        """Contiguous store of bytes from elements of two or four consecutive vector
registers to the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-B--scalar-plus-immediate--consecutive-registers----"
    )
    this["st1d"] = OpCodeDoc(
        "ST1D",
        """Contiguous store of doublewords from elements of two or four consecutive
vector registers to the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-D--scalar-plus-immediate--consecutive-registers----"
    )
    this["st1h"] = OpCodeDoc(
        "ST1H",
        """Contiguous store of halfwords from elements of two or four consecutive vector
registers to the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-H--scalar-plus-immediate--consecutive-registers----"
    )
    this["st1q"] = OpCodeDoc(
        "ST1Q",
        """Scatter store of quadwords from the active elements of a vector register to
the memory addresses generated by a vector base plus a 64-bit unscaled scalar
register offset. Inactive elements are not written to memory.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-Q---"
    )
    this["st1w"] = OpCodeDoc(
        "ST1W",
        """Contiguous store of words from elements of two or four consecutive vector
registers to the memory address generated by a 64-bit scalar base and
immediate index which is multiplied by the vector's in-memory size,
irrespective of predication, and added to the base address.

Inactive elements are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-W--scalar-plus-immediate--consecutive-registers----"
    )
    this["st2"] = OpCodeDoc(
        "ST2",
        """Store multiple 2-element structures from two registers. This instruction
stores multiple 2-element structures from two SIMD&FP registers to memory,
with interleaving. Every element of each register is stored.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST---multiple-structures---Store-multiple---element-structures-from-two-registers-"
    )
    this["st2b"] = OpCodeDoc(
        "ST2B",
        """Contiguous store two-byte structures, each from the same element number in two
vector registers to the memory address generated by a 64-bit scalar base and
an immediate index which is a multiple of 2 in the range -16 to 14 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive bytes in memory which
make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-B--scalar-plus-immediate----"
    )
    this["st2d"] = OpCodeDoc(
        "ST2D",
        """Contiguous store two-doubleword structures, each from the same element number
in two vector registers to the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 2 in the range -16 to 14
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive doublewords in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-D--scalar-plus-immediate----"
    )
    this["st2g"] = OpCodeDoc(
        "ST2G",
        """Store Allocation Tags stores an Allocation Tag to two Tag granules of memory.
The address used for the store is calculated from the base register and an
immediate signed offset scaled by the Tag granule. The Allocation Tag is
calculated from the Logical Address Tag in the source register.

This instruction generates an Unchecked access.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-G--Store-allocation-tags-"
    )
    this["st2h"] = OpCodeDoc(
        "ST2H",
        """Contiguous store two-halfword structures, each from the same element number in
two vector registers to the memory address generated by a 64-bit scalar base
and an immediate index which is a multiple of 2 in the range -16 to 14 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive halfwords in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-H--scalar-plus-immediate----"
    )
    this["st2q"] = OpCodeDoc(
        "ST2Q",
        """Contiguous store two-quadword structures, each from the same element number in
two vector registers to the memory address generated by a 64-bit scalar base
and an immediate index which is a multiple of 2 in the range -16 to 14 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive quadwords in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-Q--scalar-plus-immediate----"
    )
    this["st2w"] = OpCodeDoc(
        "ST2W",
        """Contiguous store two-word structures, each from the same element number in two
vector registers to the memory address generated by a 64-bit scalar base and
an immediate index which is a multiple of 2 in the range -16 to 14 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the two
vector registers, or equivalently to the two consecutive words in memory which
make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-W--scalar-plus-immediate----"
    )
    this["st3"] = OpCodeDoc(
        "ST3",
        """Store multiple 3-element structures from three registers. This instruction
stores multiple 3-element structures to memory from three SIMD&FP registers,
with interleaving. Every element of each register is stored.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST---multiple-structures---Store-multiple---element-structures-from-three-registers-"
    )
    this["st3b"] = OpCodeDoc(
        "ST3B",
        """Contiguous store three-byte structures, each from the same element number in
three vector registers to the memory address generated by a 64-bit scalar base
and an immediate index which is a multiple of 3 in the range -24 to 21 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive bytes in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-B--scalar-plus-immediate----"
    )
    this["st3d"] = OpCodeDoc(
        "ST3D",
        """Contiguous store three-doubleword structures, each from the same element
number in three vector registers to the memory address generated by a 64-bit
scalar base and an immediate index which is a multiple of 3 in the range -24
to 21 that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive doublewords in
memory which make up each structure. Inactive structures are not written to
memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-D--scalar-plus-immediate----"
    )
    this["st3h"] = OpCodeDoc(
        "ST3H",
        """Contiguous store three-halfword structures, each from the same element number
in three vector registers to the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 3 in the range -24 to 21
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive halfwords in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-H--scalar-plus-immediate----"
    )
    this["st3q"] = OpCodeDoc(
        "ST3Q",
        """Contiguous store three-quadword structures, each from the same element number
in three vector registers to the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 3 in the range -24 to 21
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive quadwords in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-Q--scalar-plus-immediate----"
    )
    this["st3w"] = OpCodeDoc(
        "ST3W",
        """Contiguous store three-word structures, each from the same element number in
three vector registers to the memory address generated by a 64-bit scalar base
and an immediate index which is a multiple of 3 in the range -24 to 21 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the three
vector registers, or equivalently to the three consecutive words in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-W--scalar-plus-immediate----"
    )
    this["st4"] = OpCodeDoc(
        "ST4",
        """Store multiple 4-element structures from four registers. This instruction
stores multiple 4-element structures to memory from four SIMD&FP registers,
with interleaving. Every element of each register is stored.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST---multiple-structures---Store-multiple---element-structures-from-four-registers-"
    )
    this["st4b"] = OpCodeDoc(
        "ST4B",
        """Contiguous store four-byte structures, each from the same element number in
four vector registers to the memory address generated by a 64-bit scalar base
and an immediate index which is a multiple of 4 in the range -32 to 28 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive bytes in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-B--scalar-plus-immediate----"
    )
    this["st4d"] = OpCodeDoc(
        "ST4D",
        """Contiguous store four-doubleword structures, each from the same element number
in four vector registers to the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 4 in the range -32 to 28
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive doublewords in
memory which make up each structure. Inactive structures are not written to
memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-D--scalar-plus-immediate----"
    )
    this["st4h"] = OpCodeDoc(
        "ST4H",
        """Contiguous store four-halfword structures, each from the same element number
in four vector registers to the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 4 in the range -32 to 28
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive halfwords in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-H--scalar-plus-immediate----"
    )
    this["st4q"] = OpCodeDoc(
        "ST4Q",
        """Contiguous store four-quadword structures, each from the same element number
in four vector registers to the memory address generated by a 64-bit scalar
base and an immediate index which is a multiple of 4 in the range -32 to 28
that is multiplied by the vector's in-memory size, irrespective of
predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive quadwords in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-Q--scalar-plus-immediate----"
    )
    this["st4w"] = OpCodeDoc(
        "ST4W",
        """Contiguous store four-word structures, each from the same element number in
four vector registers to the memory address generated by a 64-bit scalar base
and an immediate index which is a multiple of 4 in the range -32 to 28 that is
multiplied by the vector's in-memory size, irrespective of predication,

Each predicate element applies to the same element number in each of the four
vector registers, or equivalently to the four consecutive words in memory
which make up each structure. Inactive structures are not written to memory.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST-W--scalar-plus-immediate----"
    )
    this["st64b"] = OpCodeDoc(
        "ST64B",
        """Single-copy Atomic 64-byte Store without Return stores eight 64-bit
doublewords from consecutive registers, Xt to X(t+7), to a memory location.
The data that is stored is atomic and is required to be 64-byte-aligned.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST--B--Single-copy-atomic----byte-store-without-return-"
    )
    this["st64bv"] = OpCodeDoc(
        "ST64BV",
        """Single-copy Atomic 64-byte Store with Return stores eight 64-bit doublewords
from consecutive registers, Xt to X(t+7), to a memory location, and writes the
status result of the store to a register. The data that is stored is atomic
and is required to be 64-byte aligned.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST--BV--Single-copy-atomic----byte-store-with-return-"
    )
    this["st64bv0"] = OpCodeDoc(
        "ST64BV0",
        """Single-copy Atomic 64-byte EL0 Store with Return stores eight 64-bit
doublewords from consecutive registers, Xt to X(t+7), to a memory location,
with the bottom 32 bits taken from ACCDATA_EL1, and writes the status result
of the store to a register. The data that is stored is atomic and is required
to be 64-byte aligned.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ST--BV---Single-copy-atomic----byte-el--store-with-return-"
    )
    this["stadd"] = OpCodeDoc(
        "STADD",
        """Atomic add on word or doubleword in memory, without return, atomically loads a
32-bit word or 64-bit doubleword from memory, adds the value held in a
register to it, and stores the result back to memory.

  * `STADD` does not have release semantics.
  * `STADDL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STADD--STADDL--Atomic-add-on-word-or-doubleword-in-memory--without-return-"
    )
    this["staddl"] = OpCodeDoc(
        "STADDL",
        """Atomic add on word or doubleword in memory, without return, atomically loads a
32-bit word or 64-bit doubleword from memory, adds the value held in a
register to it, and stores the result back to memory.

  * `STADD` does not have release semantics.
  * `STADDL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STADD--STADDL--Atomic-add-on-word-or-doubleword-in-memory--without-return-"
    )
    this["staddb"] = OpCodeDoc(
        "STADDB",
        """Atomic add on byte in memory, without return, atomically loads an 8-bit byte
from memory, adds the value held in a register to it, and stores the result
back to memory.

  * `STADDB` does not have release semantics.
  * `STADDLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STADDB--STADDLB--Atomic-add-on-byte-in-memory--without-return-"
    )
    this["staddlb"] = OpCodeDoc(
        "STADDLB",
        """Atomic add on byte in memory, without return, atomically loads an 8-bit byte
from memory, adds the value held in a register to it, and stores the result
back to memory.

  * `STADDB` does not have release semantics.
  * `STADDLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STADDB--STADDLB--Atomic-add-on-byte-in-memory--without-return-"
    )
    this["staddh"] = OpCodeDoc(
        "STADDH",
        """Atomic add on halfword in memory, without return, atomically loads a 16-bit
halfword from memory, adds the value held in a register to it, and stores the
result back to memory.

  * `STADDH` does not have release semantics.
  * `STADDLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STADDH--STADDLH--Atomic-add-on-halfword-in-memory--without-return-"
    )
    this["staddlh"] = OpCodeDoc(
        "STADDLH",
        """Atomic add on halfword in memory, without return, atomically loads a 16-bit
halfword from memory, adds the value held in a register to it, and stores the
result back to memory.

  * `STADDH` does not have release semantics.
  * `STADDLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STADDH--STADDLH--Atomic-add-on-halfword-in-memory--without-return-"
    )
    this["stclr"] = OpCodeDoc(
        "STCLR",
        """Atomic bit clear on word or doubleword in memory, without return, atomically
loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND
with the complement of the value held in a register on it, and stores the
result back to memory.

  * `STCLR` does not have release semantics.
  * `STCLRL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STCLR--STCLRL--Atomic-bit-clear-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stclrl"] = OpCodeDoc(
        "STCLRL",
        """Atomic bit clear on word or doubleword in memory, without return, atomically
loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND
with the complement of the value held in a register on it, and stores the
result back to memory.

  * `STCLR` does not have release semantics.
  * `STCLRL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STCLR--STCLRL--Atomic-bit-clear-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stclrb"] = OpCodeDoc(
        "STCLRB",
        """Atomic bit clear on byte in memory, without return, atomically loads an 8-bit
byte from memory, performs a bitwise AND with the complement of the value held
in a register on it, and stores the result back to memory.

  * `STCLRB` does not have release semantics.
  * `STCLRLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STCLRB--STCLRLB--Atomic-bit-clear-on-byte-in-memory--without-return-"
    )
    this["stclrlb"] = OpCodeDoc(
        "STCLRLB",
        """Atomic bit clear on byte in memory, without return, atomically loads an 8-bit
byte from memory, performs a bitwise AND with the complement of the value held
in a register on it, and stores the result back to memory.

  * `STCLRB` does not have release semantics.
  * `STCLRLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STCLRB--STCLRLB--Atomic-bit-clear-on-byte-in-memory--without-return-"
    )
    this["stclrh"] = OpCodeDoc(
        "STCLRH",
        """Atomic bit clear on halfword in memory, without return, atomically loads a
16-bit halfword from memory, performs a bitwise AND with the complement of the
value held in a register on it, and stores the result back to memory.

  * `STCLRH` does not have release semantics.
  * `STCLRLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STCLRH--STCLRLH--Atomic-bit-clear-on-halfword-in-memory--without-return-"
    )
    this["stclrlh"] = OpCodeDoc(
        "STCLRLH",
        """Atomic bit clear on halfword in memory, without return, atomically loads a
16-bit halfword from memory, performs a bitwise AND with the complement of the
value held in a register on it, and stores the result back to memory.

  * `STCLRH` does not have release semantics.
  * `STCLRLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STCLRH--STCLRLH--Atomic-bit-clear-on-halfword-in-memory--without-return-"
    )
    this["steor"] = OpCodeDoc(
        "STEOR",
        """Atomic Exclusive-OR on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, performs an
exclusive-OR with the value held in a register on it, and stores the result
back to memory.

  * `STEOR` does not have release semantics.
  * `STEORL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STEOR--STEORL--Atomic-exclusive-or-on-word-or-doubleword-in-memory--without-return-"
    )
    this["steorl"] = OpCodeDoc(
        "STEORL",
        """Atomic Exclusive-OR on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, performs an
exclusive-OR with the value held in a register on it, and stores the result
back to memory.

  * `STEOR` does not have release semantics.
  * `STEORL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STEOR--STEORL--Atomic-exclusive-or-on-word-or-doubleword-in-memory--without-return-"
    )
    this["steorb"] = OpCodeDoc(
        "STEORB",
        """Atomic Exclusive-OR on byte in memory, without return, atomically loads an
8-bit byte from memory, performs an exclusive-OR with the value held in a
register on it, and stores the result back to memory.

  * `STEORB` does not have release semantics.
  * `STEORLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STEORB--STEORLB--Atomic-exclusive-or-on-byte-in-memory--without-return-"
    )
    this["steorlb"] = OpCodeDoc(
        "STEORLB",
        """Atomic Exclusive-OR on byte in memory, without return, atomically loads an
8-bit byte from memory, performs an exclusive-OR with the value held in a
register on it, and stores the result back to memory.

  * `STEORB` does not have release semantics.
  * `STEORLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STEORB--STEORLB--Atomic-exclusive-or-on-byte-in-memory--without-return-"
    )
    this["steorh"] = OpCodeDoc(
        "STEORH",
        """Atomic Exclusive-OR on halfword in memory, without return, atomically loads a
16-bit halfword from memory, performs an exclusive-OR with the value held in a
register on it, and stores the result back to memory.

  * `STEORH` does not have release semantics.
  * `STEORLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STEORH--STEORLH--Atomic-exclusive-or-on-halfword-in-memory--without-return-"
    )
    this["steorlh"] = OpCodeDoc(
        "STEORLH",
        """Atomic Exclusive-OR on halfword in memory, without return, atomically loads a
16-bit halfword from memory, performs an exclusive-OR with the value held in a
register on it, and stores the result back to memory.

  * `STEORH` does not have release semantics.
  * `STEORLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STEORH--STEORLH--Atomic-exclusive-or-on-halfword-in-memory--without-return-"
    )
    this["stg"] = OpCodeDoc(
        "STG",
        """Store Allocation Tag stores an Allocation Tag to memory. The address used for
the store is calculated from the base register and an immediate signed offset
scaled by the Tag granule. The Allocation Tag is calculated from the Logical
Address Tag in the source register.

This instruction generates an Unchecked access.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STG--Store-allocation-tag-"
    )
    this["stgm"] = OpCodeDoc(
        "STGM",
        """Store Tag Multiple writes a naturally aligned block of N Allocation Tags,
where the size of N is identified in GMID_EL1.BS, and the Allocation Tag
written to address A is taken from the source register at 4*A<7:4>+3:4*A<7:4>.

This instruction is undefined at EL0.

This instruction generates an Unchecked access.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STGM--Store-tag-multiple-"
    )
    this["stgp"] = OpCodeDoc(
        "STGP",
        """Store Allocation Tag and Pair of registers stores an Allocation Tag and two
64-bit doublewords to memory, from two registers. The address used for the
store is calculated from the base register and an immediate signed offset
scaled by the Tag granule. The Allocation Tag is calculated from the Logical
Address Tag in the base register.

This instruction generates an Unchecked access.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STGP--Store-allocation-tag-and-pair-of-registers-"
    )
    this["stilp"] = OpCodeDoc(
        "STILP",
        """Store-Release ordered Pair of registers calculates an address from a base
register value and an optional offset, and stores two 32-bit words or two
64-bit doublewords to the calculated address, from two registers. For
information on single-copy atomicity and alignment requirements, see
Requirements for single-copy atomicity and Alignment of data accesses. The
instruction also has memory ordering semantics, as described in Load-Acquire,
Load-AcquirePC, and Store-Release, with the additional requirement that:

  * When using the pre-index addressing mode, the Memory effects associated with Xt2/Wt2 are Ordered-before the Memory effects associated with Xt1/Wt1.
  * For all other addressing modes, the Memory effects associated with Xt1/Wt1 are Ordered-before the Memory effects associated with Xt2/Wt2.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STILP--Store-release-ordered-pair-of-registers-"
    )
    this["stl1"] = OpCodeDoc(
        "STL1",
        """Store-Release a single-element structure from one lane of one register. This
instruction stores the specified element of a SIMD&FP register to memory.

The instruction also has memory ordering semantics, as described in Load-
Acquire, Load-AcquirePC, and Store-Release. For information about memory
accesses, see Load/Store addressing modes.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STL---SIMD-FP---Store-release-a-single-element-structure-from-one-lane-of-one-register-"
    )
    this["stllr"] = OpCodeDoc(
        "STLLR",
        """Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a
memory location, from a register. The instruction also has memory ordering
semantics as described in Load LOAcquire, Store LORelease. For information
about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLLR--Store-lorelease-register-"
    )
    this["stllrb"] = OpCodeDoc(
        "STLLRB",
        """Store LORelease Register Byte stores a byte from a 32-bit register to a memory
location. The instruction also has memory ordering semantics as described in
Load LOAcquire, Store LORelease. For information about memory accesses, see
Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLLRB--Store-lorelease-register-byte-"
    )
    this["stllrh"] = OpCodeDoc(
        "STLLRH",
        """Store LORelease Register Halfword stores a halfword from a 32-bit register to
a memory location. The instruction also has memory ordering semantics as
described in Load LOAcquire, Store LORelease. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLLRH--Store-lorelease-register-halfword-"
    )
    this["stlr"] = OpCodeDoc(
        "STLR",
        """Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory
location, from a register. The instruction also has memory ordering semantics
as described in Load-Acquire, Store-Release. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLR--Store-release-register-"
    )
    this["stlrb"] = OpCodeDoc(
        "STLRB",
        """Store-Release Register Byte stores a byte from a 32-bit register to a memory
location. The instruction also has memory ordering semantics as described in
Load-Acquire, Store-Release. For information about memory accesses, see
Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLRB--Store-release-register-byte-"
    )
    this["stlrh"] = OpCodeDoc(
        "STLRH",
        """Store-Release Register Halfword stores a halfword from a 32-bit register to a
memory location. The instruction also has memory ordering semantics as
described in Load-Acquire, Store-Release. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLRH--Store-release-register-halfword-"
    )
    this["stlur"] = OpCodeDoc(
        "STLUR",
        """Store-Release SIMD&FP Register (unscaled offset). This instruction stores a
single SIMD&FP register to memory. The address that is used for the store is
calculated from a base register value and an optional immediate offset.

The instruction has memory ordering semantics, as described in Load-Acquire,
Load-AcquirePC, and Store-Release.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLUR--SIMD-FP---Store-release-simd-fp-register--unscaled-offset--"
    )
    this["stlurb"] = OpCodeDoc(
        "STLURB",
        """Store-Release Register Byte (unscaled) calculates an address from a base
register value and an immediate offset, and stores a byte to the calculated
address, from a 32-bit register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLURB--Store-release-register-byte--unscaled--"
    )
    this["stlurh"] = OpCodeDoc(
        "STLURH",
        """Store-Release Register Halfword (unscaled) calculates an address from a base
register value and an immediate offset, and stores a halfword to the
calculated address, from a 32-bit register.

The instruction has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLURH--Store-release-register-halfword--unscaled--"
    )
    this["stlxp"] = OpCodeDoc(
        "STLXP",
        """Store-Release Exclusive Pair of registers stores two 32-bit words or two
64-bit doublewords to a memory location if the PE has exclusive access to the
memory address, from two registers, and returns a status value of 0 if the
store was successful, or of 1 if no store was performed. See Synchronization
and semaphores. For information on single-copy atomicity and alignment
requirements, see Requirements for single-copy atomicity and Alignment of data
accesses. If a 64-bit pair Store-Exclusive succeeds, it causes a single-copy
atomic update of the 128-bit memory location being updated. The instruction
also has memory ordering semantics, as described in Load-Acquire, Store-
Release. For information about memory accesses, see Load/Store addressing
modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLXP--Store-release-exclusive-pair-of-registers-"
    )
    this["stlxr"] = OpCodeDoc(
        "STLXR",
        """Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword
to memory if the PE has exclusive access to the memory address, from two
registers, and returns a status value of 0 if the store was successful, or of
1 if no store was performed. See Synchronization and semaphores. The memory
access is atomic. The instruction also has memory ordering semantics as
described in Load-Acquire, Store-Release. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLXR--Store-release-exclusive-register-"
    )
    this["stlxrb"] = OpCodeDoc(
        "STLXRB",
        """Store-Release Exclusive Register Byte stores a byte from a 32-bit register to
memory if the PE has exclusive access to the memory address, and returns a
status value of 0 if the store was successful, or of 1 if no store was
performed. See Synchronization and semaphores. The memory access is atomic.
The instruction also has memory ordering semantics as described in Load-
Acquire, Store-Release. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLXRB--Store-release-exclusive-register-byte-"
    )
    this["stlxrh"] = OpCodeDoc(
        "STLXRH",
        """Store-Release Exclusive Register Halfword stores a halfword from a 32-bit
register to memory if the PE has exclusive access to the memory address, and
returns a status value of 0 if the store was successful, or of 1 if no store
was performed. See Synchronization and semaphores. The memory access is
atomic. The instruction also has memory ordering semantics as described in
Load-Acquire, Store-Release. For information about memory accesses, see
Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STLXRH--Store-release-exclusive-register-halfword-"
    )
    this["stnp"] = OpCodeDoc(
        "STNP",
        """Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction
stores a pair of SIMD&FP registers to memory, issuing a hint to the memory
system that the access is non-temporal. The address used for the store is
calculated from an address from a base register value and an immediate offset.
For information about non-temporal pair instructions, see Load/Store SIMD and
Floating-point Non-temporal pair.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STNP--SIMD-FP---Store-pair-of-simd-fp-registers--with-non-temporal-hint-"
    )
    this["stnt1b"] = OpCodeDoc(
        "STNT1B",
        """Contiguous store non-temporal of bytes from elements of two or four
consecutive vector registers to the memory address generated by a 64-bit
scalar base and immediate index which is multiplied by the vector's in-memory
size, irrespective of predication, and added to the base address.

Inactive elements are not written to memory.

A non-temporal store is a hint to the system that this data is unlikely to be
referenced again soon.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STNT-B--scalar-plus-immediate--consecutive-registers----"
    )
    this["stnt1d"] = OpCodeDoc(
        "STNT1D",
        """Contiguous store non-temporal of doublewords from elements of two or four
consecutive vector registers to the memory address generated by a 64-bit
scalar base and immediate index which is multiplied by the vector's in-memory
size, irrespective of predication, and added to the base address.

Inactive elements are not written to memory.

A non-temporal store is a hint to the system that this data is unlikely to be
referenced again soon.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STNT-D--scalar-plus-immediate--consecutive-registers----"
    )
    this["stnt1h"] = OpCodeDoc(
        "STNT1H",
        """Contiguous store non-temporal of halfwords from elements of two or four
consecutive vector registers to the memory address generated by a 64-bit
scalar base and immediate index which is multiplied by the vector's in-memory
size, irrespective of predication, and added to the base address.

Inactive elements are not written to memory.

A non-temporal store is a hint to the system that this data is unlikely to be
referenced again soon.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STNT-H--scalar-plus-immediate--consecutive-registers----"
    )
    this["stnt1w"] = OpCodeDoc(
        "STNT1W",
        """Contiguous store non-temporal of words from elements of two or four
consecutive vector registers to the memory address generated by a 64-bit
scalar base and immediate index which is multiplied by the vector's in-memory
size, irrespective of predication, and added to the base address.

Inactive elements are not written to memory.

A non-temporal store is a hint to the system that this data is unlikely to be
referenced again soon.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STNT-W--scalar-plus-immediate--consecutive-registers----"
    )
    this["stp"] = OpCodeDoc(
        "STP",
        """Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP
registers to memory. The address used for the store is calculated from a base
register value and an immediate offset.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STP--SIMD-FP---Store-pair-of-simd-fp-registers-"
    )
    this["str"] = OpCodeDoc(
        "STR",
        """Store SIMD&FP register (immediate offset). This instruction stores a single
SIMD&FP register to memory. The address that is used for the store is
calculated from a base register value and an immediate offset.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STR--immediate--SIMD-FP---Store-simd-fp-register--immediate-offset--"
    )
    this["str"] = OpCodeDoc(
        "STR",
        """Store Register (immediate) stores a word or a doubleword from a register to
memory. The address that is used for the store is calculated from a base
register and an immediate offset. For information about memory accesses, see
Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STR--immediate---Store-register--immediate--"
    )
    this["str"] = OpCodeDoc(
        "STR",
        """Store Register (register) calculates an address from a base register value and
an offset register value, and stores a 32-bit word or a 64-bit doubleword to
the calculated address, from a register. For information about memory
accesses, see Load/Store addressing modes.

The instruction uses an offset addressing mode, that calculates the address
used for the memory access from a base register value and an offset register
value. The offset can be optionally shifted and extended.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STR--register---Store-register--register--"
    )
    this["strb"] = OpCodeDoc(
        "STRB",
        """Store Register Byte (immediate) stores the least significant byte of a 32-bit
register to memory. The address that is used for the store is calculated from
a base register and an immediate offset. For information about memory
accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STRB--immediate---Store-register-byte--immediate--"
    )
    this["strb"] = OpCodeDoc(
        "STRB",
        """Store Register Byte (register) calculates an address from a base register
value and an offset register value, and stores a byte from a 32-bit register
to the calculated address. For information about memory accesses, see
Load/Store addressing modes.

The instruction uses an offset addressing mode, that calculates the address
used for the memory access from a base register value and an offset register
value. The offset can be optionally shifted and extended.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STRB--register---Store-register-byte--register--"
    )
    this["strh"] = OpCodeDoc(
        "STRH",
        """Store Register Halfword (immediate) stores the least significant halfword of a
32-bit register to memory. The address that is used for the store is
calculated from a base register and an immediate offset. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STRH--immediate---Store-register-halfword--immediate--"
    )
    this["strh"] = OpCodeDoc(
        "STRH",
        """Store Register Halfword (register) calculates an address from a base register
value and an offset register value, and stores a halfword from a 32-bit
register to the calculated address. For information about memory accesses, see
Load/Store addressing modes.

The instruction uses an offset addressing mode, that calculates the address
used for the memory access from a base register value and an offset register
value. The offset can be optionally shifted and extended.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STRH--register---Store-register-halfword--register--"
    )
    this["stset"] = OpCodeDoc(
        "STSET",
        """Atomic bit set on word or doubleword in memory, without return, atomically
loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR
with the value held in a register on it, and stores the result back to memory.

  * `STSET` does not have release semantics.
  * `STSETL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSET--STSETL--Atomic-bit-set-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stsetl"] = OpCodeDoc(
        "STSETL",
        """Atomic bit set on word or doubleword in memory, without return, atomically
loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR
with the value held in a register on it, and stores the result back to memory.

  * `STSET` does not have release semantics.
  * `STSETL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSET--STSETL--Atomic-bit-set-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stsetb"] = OpCodeDoc(
        "STSETB",
        """Atomic bit set on byte in memory, without return, atomically loads an 8-bit
byte from memory, performs a bitwise OR with the value held in a register on
it, and stores the result back to memory.

  * `STSETB` does not have release semantics.
  * `STSETLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSETB--STSETLB--Atomic-bit-set-on-byte-in-memory--without-return-"
    )
    this["stsetlb"] = OpCodeDoc(
        "STSETLB",
        """Atomic bit set on byte in memory, without return, atomically loads an 8-bit
byte from memory, performs a bitwise OR with the value held in a register on
it, and stores the result back to memory.

  * `STSETB` does not have release semantics.
  * `STSETLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSETB--STSETLB--Atomic-bit-set-on-byte-in-memory--without-return-"
    )
    this["stseth"] = OpCodeDoc(
        "STSETH",
        """Atomic bit set on halfword in memory, without return, atomically loads a
16-bit halfword from memory, performs a bitwise OR with the value held in a
register on it, and stores the result back to memory.

  * `STSETH` does not have release semantics.
  * `STSETLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSETH--STSETLH--Atomic-bit-set-on-halfword-in-memory--without-return-"
    )
    this["stsetlh"] = OpCodeDoc(
        "STSETLH",
        """Atomic bit set on halfword in memory, without return, atomically loads a
16-bit halfword from memory, performs a bitwise OR with the value held in a
register on it, and stores the result back to memory.

  * `STSETH` does not have release semantics.
  * `STSETLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSETH--STSETLH--Atomic-bit-set-on-halfword-in-memory--without-return-"
    )
    this["stsmax"] = OpCodeDoc(
        "STSMAX",
        """Atomic signed maximum on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, compares it
against the value held in a register, and stores the larger value back to
memory, treating the values as signed numbers.

  * `STSMAX` does not have release semantics.
  * `STSMAXL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMAX--STSMAXL--Atomic-signed-maximum-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stsmaxl"] = OpCodeDoc(
        "STSMAXL",
        """Atomic signed maximum on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, compares it
against the value held in a register, and stores the larger value back to
memory, treating the values as signed numbers.

  * `STSMAX` does not have release semantics.
  * `STSMAXL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMAX--STSMAXL--Atomic-signed-maximum-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stsmaxb"] = OpCodeDoc(
        "STSMAXB",
        """Atomic signed maximum on byte in memory, without return, atomically loads an
8-bit byte from memory, compares it against the value held in a register, and
stores the larger value back to memory, treating the values as signed numbers.

  * `STSMAXB` does not have release semantics.
  * `STSMAXLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMAXB--STSMAXLB--Atomic-signed-maximum-on-byte-in-memory--without-return-"
    )
    this["stsmaxlb"] = OpCodeDoc(
        "STSMAXLB",
        """Atomic signed maximum on byte in memory, without return, atomically loads an
8-bit byte from memory, compares it against the value held in a register, and
stores the larger value back to memory, treating the values as signed numbers.

  * `STSMAXB` does not have release semantics.
  * `STSMAXLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMAXB--STSMAXLB--Atomic-signed-maximum-on-byte-in-memory--without-return-"
    )
    this["stsmaxh"] = OpCodeDoc(
        "STSMAXH",
        """Atomic signed maximum on halfword in memory, without return, atomically loads
a 16-bit halfword from memory, compares it against the value held in a
register, and stores the larger value back to memory, treating the values as
signed numbers.

  * `STSMAXH` does not have release semantics.
  * `STSMAXLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMAXH--STSMAXLH--Atomic-signed-maximum-on-halfword-in-memory--without-return-"
    )
    this["stsmaxlh"] = OpCodeDoc(
        "STSMAXLH",
        """Atomic signed maximum on halfword in memory, without return, atomically loads
a 16-bit halfword from memory, compares it against the value held in a
register, and stores the larger value back to memory, treating the values as
signed numbers.

  * `STSMAXH` does not have release semantics.
  * `STSMAXLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMAXH--STSMAXLH--Atomic-signed-maximum-on-halfword-in-memory--without-return-"
    )
    this["stsmin"] = OpCodeDoc(
        "STSMIN",
        """Atomic signed minimum on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, compares it
against the value held in a register, and stores the smaller value back to
memory, treating the values as signed numbers.

  * `STSMIN` does not have release semantics.
  * `STSMINL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMIN--STSMINL--Atomic-signed-minimum-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stsminl"] = OpCodeDoc(
        "STSMINL",
        """Atomic signed minimum on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, compares it
against the value held in a register, and stores the smaller value back to
memory, treating the values as signed numbers.

  * `STSMIN` does not have release semantics.
  * `STSMINL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMIN--STSMINL--Atomic-signed-minimum-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stsminb"] = OpCodeDoc(
        "STSMINB",
        """Atomic signed minimum on byte in memory, without return, atomically loads an
8-bit byte from memory, compares it against the value held in a register, and
stores the smaller value back to memory, treating the values as signed
numbers.

  * `STSMINB` does not have release semantics.
  * `STSMINLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMINB--STSMINLB--Atomic-signed-minimum-on-byte-in-memory--without-return-"
    )
    this["stsminlb"] = OpCodeDoc(
        "STSMINLB",
        """Atomic signed minimum on byte in memory, without return, atomically loads an
8-bit byte from memory, compares it against the value held in a register, and
stores the smaller value back to memory, treating the values as signed
numbers.

  * `STSMINB` does not have release semantics.
  * `STSMINLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMINB--STSMINLB--Atomic-signed-minimum-on-byte-in-memory--without-return-"
    )
    this["stsminh"] = OpCodeDoc(
        "STSMINH",
        """Atomic signed minimum on halfword in memory, without return, atomically loads
a 16-bit halfword from memory, compares it against the value held in a
register, and stores the smaller value back to memory, treating the values as
signed numbers.

  * `STSMINH` does not have release semantics.
  * `STSMINLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMINH--STSMINLH--Atomic-signed-minimum-on-halfword-in-memory--without-return-"
    )
    this["stsminlh"] = OpCodeDoc(
        "STSMINLH",
        """Atomic signed minimum on halfword in memory, without return, atomically loads
a 16-bit halfword from memory, compares it against the value held in a
register, and stores the smaller value back to memory, treating the values as
signed numbers.

  * `STSMINH` does not have release semantics.
  * `STSMINLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STSMINH--STSMINLH--Atomic-signed-minimum-on-halfword-in-memory--without-return-"
    )
    this["sttr"] = OpCodeDoc(
        "STTR",
        """Store Register (unprivileged) stores a word or doubleword from a register to
memory. The address that is used for the store is calculated from a base
register and an immediate offset.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STTR--Store-register--unprivileged--"
    )
    this["sttrb"] = OpCodeDoc(
        "STTRB",
        """Store Register Byte (unprivileged) stores a byte from a 32-bit register to
memory. The address that is used for the store is calculated from a base
register and an immediate offset.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STTRB--Store-register-byte--unprivileged--"
    )
    this["sttrh"] = OpCodeDoc(
        "STTRH",
        """Store Register Halfword (unprivileged) stores a halfword from a 32-bit
register to memory. The address that is used for the store is calculated from
a base register and an immediate offset.

Memory accesses made by the instruction behave as if the instruction was
executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:

  * The instruction is executed at EL1.
  * The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the
Exception level at which the instruction is executed. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STTRH--Store-register-halfword--unprivileged--"
    )
    this["stumax"] = OpCodeDoc(
        "STUMAX",
        """Atomic unsigned maximum on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, compares it
against the value held in a register, and stores the larger value back to
memory, treating the values as unsigned numbers.

  * `STUMAX` does not have release semantics.
  * `STUMAXL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMAX--STUMAXL--Atomic-unsigned-maximum-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stumaxl"] = OpCodeDoc(
        "STUMAXL",
        """Atomic unsigned maximum on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, compares it
against the value held in a register, and stores the larger value back to
memory, treating the values as unsigned numbers.

  * `STUMAX` does not have release semantics.
  * `STUMAXL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMAX--STUMAXL--Atomic-unsigned-maximum-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stumaxb"] = OpCodeDoc(
        "STUMAXB",
        """Atomic unsigned maximum on byte in memory, without return, atomically loads an
8-bit byte from memory, compares it against the value held in a register, and
stores the larger value back to memory, treating the values as unsigned
numbers.

  * `STUMAXB` does not have release semantics.
  * `STUMAXLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMAXB--STUMAXLB--Atomic-unsigned-maximum-on-byte-in-memory--without-return-"
    )
    this["stumaxlb"] = OpCodeDoc(
        "STUMAXLB",
        """Atomic unsigned maximum on byte in memory, without return, atomically loads an
8-bit byte from memory, compares it against the value held in a register, and
stores the larger value back to memory, treating the values as unsigned
numbers.

  * `STUMAXB` does not have release semantics.
  * `STUMAXLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMAXB--STUMAXLB--Atomic-unsigned-maximum-on-byte-in-memory--without-return-"
    )
    this["stumaxh"] = OpCodeDoc(
        "STUMAXH",
        """Atomic unsigned maximum on halfword in memory, without return, atomically
loads a 16-bit halfword from memory, compares it against the value held in a
register, and stores the larger value back to memory, treating the values as
unsigned numbers.

  * `STUMAXH` does not have release semantics.
  * `STUMAXLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMAXH--STUMAXLH--Atomic-unsigned-maximum-on-halfword-in-memory--without-return-"
    )
    this["stumaxlh"] = OpCodeDoc(
        "STUMAXLH",
        """Atomic unsigned maximum on halfword in memory, without return, atomically
loads a 16-bit halfword from memory, compares it against the value held in a
register, and stores the larger value back to memory, treating the values as
unsigned numbers.

  * `STUMAXH` does not have release semantics.
  * `STUMAXLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMAXH--STUMAXLH--Atomic-unsigned-maximum-on-halfword-in-memory--without-return-"
    )
    this["stumin"] = OpCodeDoc(
        "STUMIN",
        """Atomic unsigned minimum on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, compares it
against the value held in a register, and stores the smaller value back to
memory, treating the values as unsigned numbers.

  * `STUMIN` does not have release semantics.
  * `STUMINL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMIN--STUMINL--Atomic-unsigned-minimum-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stuminl"] = OpCodeDoc(
        "STUMINL",
        """Atomic unsigned minimum on word or doubleword in memory, without return,
atomically loads a 32-bit word or 64-bit doubleword from memory, compares it
against the value held in a register, and stores the smaller value back to
memory, treating the values as unsigned numbers.

  * `STUMIN` does not have release semantics.
  * `STUMINL` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMIN--STUMINL--Atomic-unsigned-minimum-on-word-or-doubleword-in-memory--without-return-"
    )
    this["stuminb"] = OpCodeDoc(
        "STUMINB",
        """Atomic unsigned minimum on byte in memory, without return, atomically loads an
8-bit byte from memory, compares it against the value held in a register, and
stores the smaller value back to memory, treating the values as unsigned
numbers.

  * `STUMINB` does not have release semantics.
  * `STUMINLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMINB--STUMINLB--Atomic-unsigned-minimum-on-byte-in-memory--without-return-"
    )
    this["stuminlb"] = OpCodeDoc(
        "STUMINLB",
        """Atomic unsigned minimum on byte in memory, without return, atomically loads an
8-bit byte from memory, compares it against the value held in a register, and
stores the smaller value back to memory, treating the values as unsigned
numbers.

  * `STUMINB` does not have release semantics.
  * `STUMINLB` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMINB--STUMINLB--Atomic-unsigned-minimum-on-byte-in-memory--without-return-"
    )
    this["stuminh"] = OpCodeDoc(
        "STUMINH",
        """Atomic unsigned minimum on halfword in memory, without return, atomically
loads a 16-bit halfword from memory, compares it against the value held in a
register, and stores the smaller value back to memory, treating the values as
unsigned numbers.

  * `STUMINH` does not have release semantics.
  * `STUMINLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMINH--STUMINLH--Atomic-unsigned-minimum-on-halfword-in-memory--without-return-"
    )
    this["stuminlh"] = OpCodeDoc(
        "STUMINLH",
        """Atomic unsigned minimum on halfword in memory, without return, atomically
loads a 16-bit halfword from memory, compares it against the value held in a
register, and stores the smaller value back to memory, treating the values as
unsigned numbers.

  * `STUMINH` does not have release semantics.
  * `STUMINLH` stores to memory with release semantics, as described in Load-Acquire, Store-Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUMINH--STUMINLH--Atomic-unsigned-minimum-on-halfword-in-memory--without-return-"
    )
    this["stur"] = OpCodeDoc(
        "STUR",
        """Store SIMD&FP register (unscaled offset). This instruction stores a single
SIMD&FP register to memory. The address that is used for the store is
calculated from a base register value and an optional immediate offset.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STUR--SIMD-FP---Store-simd-fp-register--unscaled-offset--"
    )
    this["sturb"] = OpCodeDoc(
        "STURB",
        """Store Register Byte (unscaled) calculates an address from a base register
value and an immediate offset, and stores a byte to the calculated address,
from a 32-bit register. For information about memory accesses, see Load/Store
addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STURB--Store-register-byte--unscaled--"
    )
    this["sturh"] = OpCodeDoc(
        "STURH",
        """Store Register Halfword (unscaled) calculates an address from a base register
value and an immediate offset, and stores a halfword to the calculated
address, from a 32-bit register. For information about memory accesses, see
Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STURH--Store-register-halfword--unscaled--"
    )
    this["stxp"] = OpCodeDoc(
        "STXP",
        """Store Exclusive Pair of registers stores two 32-bit words or two 64-bit
doublewords from two registers to a memory location if the PE has exclusive
access to the memory address, and returns a status value of 0 if the store was
successful, or of 1 if no store was performed. See Synchronization and
semaphores. For information on single-copy atomicity and alignment
requirements, see Requirements for single-copy atomicity and Alignment of data
accesses. If a 64-bit pair Store-Exclusive succeeds, it causes a single-copy
atomic update of the 128-bit memory location being updated. For information
about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STXP--Store-exclusive-pair-of-registers-"
    )
    this["stxr"] = OpCodeDoc(
        "STXR",
        """Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a
register to memory if the PE has exclusive access to the memory address, and
returns a status value of 0 if the store was successful, or of 1 if no store
was performed. See Synchronization and semaphores. For information about
memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STXR--Store-exclusive-register-"
    )
    this["stxrb"] = OpCodeDoc(
        "STXRB",
        """Store Exclusive Register Byte stores a byte from a register to memory if the
PE has exclusive access to the memory address, and returns a status value of 0
if the store was successful, or of 1 if no store was performed. See
Synchronization and semaphores. The memory access is atomic.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STXRB--Store-exclusive-register-byte-"
    )
    this["stxrh"] = OpCodeDoc(
        "STXRH",
        """Store Exclusive Register Halfword stores a halfword from a register to memory
if the PE has exclusive access to the memory address, and returns a status
value of 0 if the store was successful, or of 1 if no store was performed. See
Synchronization and semaphores. The memory access is atomic.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STXRH--Store-exclusive-register-halfword-"
    )
    this["stz2g"] = OpCodeDoc(
        "STZ2G",
        """Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of
memory, zeroing the associated data locations. The address used for the store
is calculated from the base register and an immediate signed offset scaled by
the Tag granule. The Allocation Tag is calculated from the Logical Address Tag
in the source register.

This instruction generates an Unchecked access.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STZ-G--Store-allocation-tags--zeroing-"
    )
    this["stzg"] = OpCodeDoc(
        "STZG",
        """Store Allocation Tag, Zeroing stores an Allocation Tag to memory, zeroing the
associated data location. The address used for the store is calculated from
the base register and an immediate signed offset scaled by the Tag granule.
The Allocation Tag is calculated from the Logical Address Tag in the source
register.

This instruction generates an Unchecked access.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STZG--Store-allocation-tag--zeroing-"
    )
    this["stzgm"] = OpCodeDoc(
        "STZGM",
        """Store Tag and Zero Multiple writes a naturally aligned block of N Allocation
Tags and stores zero to the associated data locations, where the size of N is
identified in DCZID_EL0.BS, and the Allocation Tag is taken from the source
register bits<3:0>.

This instruction is undefined at EL0.

This instruction generates an Unchecked access.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/STZGM--Store-tag-and-zero-multiple-"
    )
    this["sub"] = OpCodeDoc(
        "SUB",
        """Subtract (extended register) subtracts a sign or zero-extended register value,
followed by an optional left shift amount, from a register value, and writes
the result to the destination register. The argument that is extended from the
<Rm> register can be a byte, halfword, word, or doubleword.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUB--extended-register---Subtract--extended-register--"
    )
    this["sub"] = OpCodeDoc(
        "SUB",
        """Subtract (immediate) subtracts an optionally-shifted immediate value from a
register value, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUB--immediate---Subtract--immediate--"
    )
    this["sub"] = OpCodeDoc(
        "SUB",
        """Subtract an unsigned immediate from each element of the source vector, and
destructively place the results in the corresponding elements of the source
vector. This instruction is unpredicated.

The immediate is an unsigned value in the range 0 to 255, and for element
widths of 16 bits or higher it may also be a positive multiple of 256 in the
range 256 to 65280.

The immediate is encoded in 8 bits with an optional left shift by 8. The
preferred disassembly when the shift option is specified is "#<uimm8>, LSL
#8". However an assembler and disassembler may also allow use of the shifted
16-bit value unless the immediate is 0 and the shift amount is 8, which must
be unambiguously described as "#0, LSL #8".

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUB--immediate----"
    )
    this["subg"] = OpCodeDoc(
        "SUBG",
        """Subtract with Tag subtracts an immediate value scaled by the Tag granule from
the address in the source register, modifies the Logical Address Tag of the
address using an immediate value, and writes the result to the destination
register. Tags specified in GCR_EL1.Exclude are excluded from the possible
outputs when modifying the Logical Address Tag.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBG--Subtract-with-tag-"
    )
    this["subhn"] = OpCodeDoc(
        "SUBHN",
        """Subtract returning High Narrow. This instruction subtracts each vector element
in the second source SIMD&FP register from the corresponding vector element in
the first source SIMD&FP register, places the most significant half of the
result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register. All the values in this instruction are signed
integer values.

The results are truncated. For rounded results, see RSUBHN.

The `SUBHN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `SUBHN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBHN--SUBHN---Subtract-returning-high-narrow-"
    )
    this["subhn2"] = OpCodeDoc(
        "SUBHN2",
        """Subtract returning High Narrow. This instruction subtracts each vector element
in the second source SIMD&FP register from the corresponding vector element in
the first source SIMD&FP register, places the most significant half of the
result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register. All the values in this instruction are signed
integer values.

The results are truncated. For rounded results, see RSUBHN.

The `SUBHN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `SUBHN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBHN--SUBHN---Subtract-returning-high-narrow-"
    )
    this["subhnb"] = OpCodeDoc(
        "SUBHNB",
        """Subtract each vector element of the second source vector from the
corresponding vector element in the first source vector, and place the most
significant half of the result in the even-numbered half-width destination
elements, while setting the odd-numbered elements to zero. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBHNB---"
    )
    this["subhnt"] = OpCodeDoc(
        "SUBHNT",
        """Subtract each vector element of the second source vector from the
corresponding vector element in the first source vector, and place the most
significant half of the result in the odd-numbered half-width destination
elements, leaving the even-numbered elements unchanged. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBHNT---"
    )
    this["subp"] = OpCodeDoc(
        "SUBP",
        """Subtract Pointer subtracts the 56-bit address held in the second source
register from the 56-bit address held in the first source register, sign-
extends the result to 64-bits, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBP--Subtract-pointer-"
    )
    this["subps"] = OpCodeDoc(
        "SUBPS",
        """Subtract Pointer, setting Flags subtracts the 56-bit address held in the
second source register from the 56-bit address held in the first source
register, sign-extends the result to 64-bits, and writes the result to the
destination register. It updates the condition flags based on the result of
the subtraction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBPS--Subtract-pointer--setting-flags-"
    )
    this["subr"] = OpCodeDoc(
        "SUBR",
        """Reversed subtract active elements of the first source vector from
corresponding elements of the second source vector and destructively place the
results in the corresponding elements of the first source vector. Inactive
elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBR--vectors----"
    )
    this["subr"] = OpCodeDoc(
        "SUBR",
        """Reversed subtract from an unsigned immediate each element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. This instruction is unpredicated.

The immediate is an unsigned value in the range 0 to 255, and for element
widths of 16 bits or higher it may also be a positive multiple of 256 in the
range 256 to 65280.

The immediate is encoded in 8 bits with an optional left shift by 8. The
preferred disassembly when the shift option is specified is "#<uimm8>, LSL
#8". However an assembler and disassembler may also allow use of the shifted
16-bit value unless the immediate is 0 and the shift amount is 8, which must
be unambiguously described as "#0, LSL #8".

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBR--immediate----"
    )
    this["subs"] = OpCodeDoc(
        "SUBS",
        """Subtract (extended register), setting flags, subtracts a sign or zero-extended
register value, followed by an optional left shift amount, from a register
value, and writes the result to the destination register. The argument that is
extended from the <Rm> register can be a byte, halfword, word, or doubleword.
It updates the condition flags based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBS--extended-register---Subtract--extended-register---setting-flags-"
    )
    this["subs"] = OpCodeDoc(
        "SUBS",
        """Subtract (immediate), setting flags, subtracts an optionally-shifted immediate
value from a register value, and writes the result to the destination
register. It updates the condition flags based on the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUBS--immediate---Subtract--immediate---setting-flags-"
    )
    this["sudot"] = OpCodeDoc(
        "SUDOT",
        """Dot product index form with signed and unsigned integers. This instruction
performs the dot product of the four signed 8-bit integer values in each
32-bit element of the first source register with the four unsigned 8-bit
integer values in an indexed 32-bit element of the second source register,
accumulating the result into the corresponding 32-bit element of the
destination vector.

From Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is
mandatory for implementations that include Advanced SIMD to support it.
ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUDOT--by-element---Dot-product-with-signed-and-unsigned-integers--vector--by-element--"
    )
    this["sumlall"] = OpCodeDoc(
        "SUMLALL",
        """This signed by unsigned integer multiply-add long-long instruction multiplies
each signed 8-bit element in the one, two, or four first source vectors with
each unsigned 8-bit indexed element of the second source vector, widens each
product to 32-bits and destructively adds these values to the corresponding
32-bit elements of the ZA quad-vector groups.

The elements within the second source vector are specified using an immediate
element index which selects the same element position within each 128-bit
vector segment. The element index range is from 0 to one less than the number
of elements per 128-bit segment, encoded in 4 bits. The lowest of the four
consecutive vector numbers forming the quad-vector group within all of, each
half of, or each quarter of the ZA array are selected by the sum of the vector
select register and immediate offset, modulo all, half, or quarter the number
of ZA array vectors.

The vector group symbol, VGx2 or VGx4, indicates that the ZA operand consists
of two or four ZA quad-vector groups respectively. The vector group symbol is
preferred for disassembly, but optional in assembler source code.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUMLALL--multiple-and-indexed-vector----"
    )
    this["sumopa"] = OpCodeDoc(
        "SUMOPA",
        """The 8-bit integer variant works with a 32-bit element ZA tile.

The 16-bit integer variant works with a 64-bit element ZA tile.

The signed by unsigned integer sum of outer products and accumulate
instructions multiply the sub-matrix in the first source vector by the sub-
matrix in the second source vector. In case of the 8-bit integer variant, the
first source holds SVLS4 sub-matrix of signed 8-bit integer values, and the
second source holds 4SVLS sub-matrix of unsigned 8-bit integer values. In
case of the 16-bit integer variant, the first source holds SVLD4 sub-matrix
of signed 16-bit integer values, and the second source holds 4SVLD sub-matrix
of unsigned 16-bit integer values.

Each source vector is independently predicated by a corresponding governing
predicate. When an 8-bit source element in case of 8-bit integer variant or a
16-bit source element in case of 16-bit integer variant is Inactive, it is
treated as having the value 0.

The resulting SVLSSVLS widened 32-bit integer or SVLDSVLD widened 64-bit
integer sum of outer products is then destructively added to the 32-bit
integer or 64-bit integer destination tile, respectively for 8-bit integer and
16-bit integer instruction variants. This is equivalent to performing a 4-way
dot product and accumulate to each of the destination tile elements.

In case of the 8-bit integer variant, each 32-bit container of the first
source vector holds 4 consecutive column elements of each row of a SVLS4 sub-
matrix, and each 32-bit container of the second source vector holds 4
consecutive row elements of each column of a 4SVLS sub-matrix. In case of the
16-bit integer variant, each 64-bit container of the first source vector holds
4 consecutive column elements of each row of a SVLD4 sub-matrix, and each
64-bit container of the second source vector holds 4 consecutive row elements
of each column of a 4SVLD sub-matrix.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 16-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUMOPA---"
    )
    this["sumops"] = OpCodeDoc(
        "SUMOPS",
        """The 8-bit integer variant works with a 32-bit element ZA tile.

The 16-bit integer variant works with a 64-bit element ZA tile.

The signed by unsigned integer sum of outer products and subtract instructions
multiply the sub-matrix in the first source vector by the sub-matrix in the
second source vector. In case of the 8-bit integer variant, the first source
holds SVLS4 sub-matrix of signed 8-bit integer values, and the second source
holds 4SVLS sub-matrix of unsigned 8-bit integer values. In case of the
16-bit integer variant, the first source holds SVLD4 sub-matrix of signed
16-bit integer values, and the second source holds 4SVLD sub-matrix of
unsigned 16-bit integer values.

Each source vector is independently predicated by a corresponding governing
predicate. When an 8-bit source element in case of 8-bit integer variant or a
16-bit source element in case of 16-bit integer variant is Inactive, it is
treated as having the value 0.

The resulting SVLSSVLS widened 32-bit integer or SVLDSVLD widened 64-bit
integer sum of outer products is then destructively subtracted from the 32-bit
integer or 64-bit integer destination tile, respectively for 8-bit integer and
16-bit integer instruction variants. This is equivalent to performing a 4-way
dot product and subtract from each of the destination tile elements.

In case of the 8-bit integer variant, each 32-bit container of the first
source vector holds 4 consecutive column elements of each row of a SVLS4 sub-
matrix, and each 32-bit container of the second source vector holds 4
consecutive row elements of each column of a 4SVLS sub-matrix. In case of the
16-bit integer variant, each 64-bit container of the first source vector holds
4 consecutive column elements of each row of a SVLD4 sub-matrix, and each
64-bit container of the second source vector holds 4 consecutive row elements
of each column of a 4SVLD sub-matrix.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 16-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUMOPS---"
    )
    this["sunpk"] = OpCodeDoc(
        "SUNPK",
        """Unpack elements from one or two source vectors and then sign-extend them to
place in elements of twice their size within the two or four destination
vectors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUNPK---"
    )
    this["sunpkhi"] = OpCodeDoc(
        "SUNPKHI",
        """Unpack elements from the lowest or highest half of the source vector and then
sign-extend them to place in elements of twice their size within the
destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUNPKHI--SUNPKLO---"
    )
    this["sunpklo"] = OpCodeDoc(
        "SUNPKLO",
        """Unpack elements from the lowest or highest half of the source vector and then
sign-extend them to place in elements of twice their size within the
destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUNPKHI--SUNPKLO---"
    )
    this["suqadd"] = OpCodeDoc(
        "SUQADD",
        """Signed saturating Accumulate of Unsigned value. This instruction adds the
unsigned integer values of the vector elements in the source SIMD&FP register
to corresponding signed integer values of the vector elements in the
destination SIMD&FP register, and writes the resulting signed integer values
to the destination SIMD&FP register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUQADD--Signed-saturating-accumulate-of-unsigned-value-"
    )
    this["suvdot"] = OpCodeDoc(
        "SUVDOT",
        """The signed by unsigned integer vertical dot product instruction computes the
vertical dot product of the corresponding signed 8-bit elements from the four
first source vectors and four unsigned 8-bit integer values in the
corresponding indexed 32-bit element of the second source vector. The widened
dot product result is destructively added to the corresponding 32-bit element
of the ZA single-vector groups.

The groups within the second source vector are specified using an immediate
element index which selects the same group position within each 128-bit vector
segment. The index range is from 0 to 3, encoded in 2 bits.

The vector numbers forming the single-vector group within each quarter of the
ZA array are selected by the sum of the vector select register and immediate
offset, modulo quarter the number of ZA array vectors.

The vector group symbol VGx4 indicates that the ZA operand consists of four ZA
single-vector groups. The vector group symbol is preferred for disassembly,
but optional in assembler source code.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SUVDOT---"
    )
    this["svc"] = OpCodeDoc(
        "SVC",
        """Supervisor Call causes an exception to be taken to EL1.

On executing an `SVC` instruction, the PE records the exception as a
Supervisor Call exception in ESR_ELx, using the EC value 0x15, and the value
of the immediate argument.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SVC--Supervisor-call-"
    )
    this["svdot"] = OpCodeDoc(
        "SVDOT",
        """The signed integer vertical dot product instruction computes the vertical dot
product of the corresponding two signed 16-bit integer values held in the two
first source vectors and two signed 16-bit integer values in the corresponding
indexed 32-bit element of the second source vector. The widened dot product
results are destructively added to the corresponding 32-bit element of the ZA
single-vector groups.

The groups within the second source vector are specified using an immediate
element index which selects the same group position within each 128-bit vector
segment. The index range is from 0 to 3, encoded in 2 bits.

The vector numbers forming the single-vector group within each half of the ZA
array are selected by the sum of the vector select register and immediate
offset, modulo half the number of ZA array vectors.

The vector group symbol VGx2 indicates that the ZA operand consists of two ZA
single-vector groups. The vector group symbol is preferred for disassembly,
but optional in assembler source code.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SVDOT----way----"
    )
    this["swp"] = OpCodeDoc(
        "SWP",
        """Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit
doubleword from a memory location, and stores the value held in a register
back to the same memory location. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `SWPA` and `SWPAL` load from memory with acquire semantics.
  * `SWPL` and `SWPAL` store to memory with release semantics.
  * `SWP` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWP--SWPA--SWPAL--SWPL--Swap-word-or-doubleword-in-memory-"
    )
    this["swpa"] = OpCodeDoc(
        "SWPA",
        """Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit
doubleword from a memory location, and stores the value held in a register
back to the same memory location. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `SWPA` and `SWPAL` load from memory with acquire semantics.
  * `SWPL` and `SWPAL` store to memory with release semantics.
  * `SWP` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWP--SWPA--SWPAL--SWPL--Swap-word-or-doubleword-in-memory-"
    )
    this["swpal"] = OpCodeDoc(
        "SWPAL",
        """Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit
doubleword from a memory location, and stores the value held in a register
back to the same memory location. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `SWPA` and `SWPAL` load from memory with acquire semantics.
  * `SWPL` and `SWPAL` store to memory with release semantics.
  * `SWP` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWP--SWPA--SWPAL--SWPL--Swap-word-or-doubleword-in-memory-"
    )
    this["swpl"] = OpCodeDoc(
        "SWPL",
        """Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit
doubleword from a memory location, and stores the value held in a register
back to the same memory location. The value initially loaded from memory is
returned in the destination register.

  * If the destination register is not one of `WZR` or `XZR`, `SWPA` and `SWPAL` load from memory with acquire semantics.
  * `SWPL` and `SWPAL` store to memory with release semantics.
  * `SWP` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWP--SWPA--SWPAL--SWPL--Swap-word-or-doubleword-in-memory-"
    )
    this["swpab"] = OpCodeDoc(
        "SWPAB",
        """Swap byte in memory atomically loads an 8-bit byte from a memory location, and
stores the value held in a register back to the same memory location. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `SWPAB` and `SWPALB` load from memory with acquire semantics.
  * `SWPLB` and `SWPALB` store to memory with release semantics.
  * `SWPB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPB--SWPAB--SWPALB--SWPLB--Swap-byte-in-memory-"
    )
    this["swpalb"] = OpCodeDoc(
        "SWPALB",
        """Swap byte in memory atomically loads an 8-bit byte from a memory location, and
stores the value held in a register back to the same memory location. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `SWPAB` and `SWPALB` load from memory with acquire semantics.
  * `SWPLB` and `SWPALB` store to memory with release semantics.
  * `SWPB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPB--SWPAB--SWPALB--SWPLB--Swap-byte-in-memory-"
    )
    this["swpb"] = OpCodeDoc(
        "SWPB",
        """Swap byte in memory atomically loads an 8-bit byte from a memory location, and
stores the value held in a register back to the same memory location. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `SWPAB` and `SWPALB` load from memory with acquire semantics.
  * `SWPLB` and `SWPALB` store to memory with release semantics.
  * `SWPB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPB--SWPAB--SWPALB--SWPLB--Swap-byte-in-memory-"
    )
    this["swplb"] = OpCodeDoc(
        "SWPLB",
        """Swap byte in memory atomically loads an 8-bit byte from a memory location, and
stores the value held in a register back to the same memory location. The
value initially loaded from memory is returned in the destination register.

  * If the destination register is not `WZR`, `SWPAB` and `SWPALB` load from memory with acquire semantics.
  * `SWPLB` and `SWPALB` store to memory with release semantics.
  * `SWPB` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPB--SWPAB--SWPALB--SWPLB--Swap-byte-in-memory-"
    )
    this["swpah"] = OpCodeDoc(
        "SWPAH",
        """Swap halfword in memory atomically loads a 16-bit halfword from a memory
location, and stores the value held in a register back to the same memory
location. The value initially loaded from memory is returned in the
destination register.

  * If the destination register is not `WZR`, `SWPAH` and `SWPALH` load from memory with acquire semantics.
  * `SWPLH` and `SWPALH` store to memory with release semantics.
  * `SWPH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPH--SWPAH--SWPALH--SWPLH--Swap-halfword-in-memory-"
    )
    this["swpalh"] = OpCodeDoc(
        "SWPALH",
        """Swap halfword in memory atomically loads a 16-bit halfword from a memory
location, and stores the value held in a register back to the same memory
location. The value initially loaded from memory is returned in the
destination register.

  * If the destination register is not `WZR`, `SWPAH` and `SWPALH` load from memory with acquire semantics.
  * `SWPLH` and `SWPALH` store to memory with release semantics.
  * `SWPH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPH--SWPAH--SWPALH--SWPLH--Swap-halfword-in-memory-"
    )
    this["swph"] = OpCodeDoc(
        "SWPH",
        """Swap halfword in memory atomically loads a 16-bit halfword from a memory
location, and stores the value held in a register back to the same memory
location. The value initially loaded from memory is returned in the
destination register.

  * If the destination register is not `WZR`, `SWPAH` and `SWPALH` load from memory with acquire semantics.
  * `SWPLH` and `SWPALH` store to memory with release semantics.
  * `SWPH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPH--SWPAH--SWPALH--SWPLH--Swap-halfword-in-memory-"
    )
    this["swplh"] = OpCodeDoc(
        "SWPLH",
        """Swap halfword in memory atomically loads a 16-bit halfword from a memory
location, and stores the value held in a register back to the same memory
location. The value initially loaded from memory is returned in the
destination register.

  * If the destination register is not `WZR`, `SWPAH` and `SWPALH` load from memory with acquire semantics.
  * `SWPLH` and `SWPALH` store to memory with release semantics.
  * `SWPH` has neither acquire nor release semantics.

For more information about memory ordering semantics, see Load-Acquire, Store-
Release.

For information about memory accesses, see Load/Store addressing modes.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPH--SWPAH--SWPALH--SWPLH--Swap-halfword-in-memory-"
    )
    this["swpp"] = OpCodeDoc(
        "SWPP",
        """Swap quadword in memory atomically loads a 128-bit quadword from a memory
location, and stores the value held in a pair of registers back to the same
memory location. The value initially loaded from memory is returned in the
same pair of registers.

  * `SWPPA` and `SWPPAL` load from memory with acquire semantics.
  * `SWPPL` and `SWPPAL` store to memory with release semantics.
  * `SWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPP--SWPPA--SWPPAL--SWPPL--Swap-quadword-in-memory-"
    )
    this["swppa"] = OpCodeDoc(
        "SWPPA",
        """Swap quadword in memory atomically loads a 128-bit quadword from a memory
location, and stores the value held in a pair of registers back to the same
memory location. The value initially loaded from memory is returned in the
same pair of registers.

  * `SWPPA` and `SWPPAL` load from memory with acquire semantics.
  * `SWPPL` and `SWPPAL` store to memory with release semantics.
  * `SWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPP--SWPPA--SWPPAL--SWPPL--Swap-quadword-in-memory-"
    )
    this["swppal"] = OpCodeDoc(
        "SWPPAL",
        """Swap quadword in memory atomically loads a 128-bit quadword from a memory
location, and stores the value held in a pair of registers back to the same
memory location. The value initially loaded from memory is returned in the
same pair of registers.

  * `SWPPA` and `SWPPAL` load from memory with acquire semantics.
  * `SWPPL` and `SWPPAL` store to memory with release semantics.
  * `SWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPP--SWPPA--SWPPAL--SWPPL--Swap-quadword-in-memory-"
    )
    this["swppl"] = OpCodeDoc(
        "SWPPL",
        """Swap quadword in memory atomically loads a 128-bit quadword from a memory
location, and stores the value held in a pair of registers back to the same
memory location. The value initially loaded from memory is returned in the
same pair of registers.

  * `SWPPA` and `SWPPAL` load from memory with acquire semantics.
  * `SWPPL` and `SWPPAL` store to memory with release semantics.
  * `SWPP` has neither acquire nor release semantics.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SWPP--SWPPA--SWPPAL--SWPPL--Swap-quadword-in-memory-"
    )
    this["sxtb"] = OpCodeDoc(
        "SXTB",
        """Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to
the size of the register, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SXTB--Signed-extend-byte-"
    )
    this["sxth"] = OpCodeDoc(
        "SXTH",
        """Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of
the register, and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SXTH--Sign-extend-halfword-"
    )
    this["sxtl"] = OpCodeDoc(
        "SXTL",
        """Signed extend Long. This instruction duplicates each vector element in the
lower or upper half of the source SIMD&FP register into a vector, and writes
the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the source vector elements. All the values in
this instruction are signed integer values.

The `SXTL` instruction extracts the source vector from the lower half of the
source register. The `SXTL2` instruction extracts the source vector from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SXTL--SXTL---Signed-extend-long-"
    )
    this["sxtl2"] = OpCodeDoc(
        "SXTL2",
        """Signed extend Long. This instruction duplicates each vector element in the
lower or upper half of the source SIMD&FP register into a vector, and writes
the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the source vector elements. All the values in
this instruction are signed integer values.

The `SXTL` instruction extracts the source vector from the lower half of the
source register. The `SXTL2` instruction extracts the source vector from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SXTL--SXTL---Signed-extend-long-"
    )
    this["sxtw"] = OpCodeDoc(
        "SXTW",
        """Sign Extend Word sign-extends a word to the size of the register, and writes
the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SXTW--Sign-extend-word-"
    )
    this["sys"] = OpCodeDoc(
        "SYS",
        """System instruction. For more information, see Op0 equals 0b01, cache
maintenance, TLB maintenance, and address translation instructions for the
encodings of System instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SYS--System-instruction-"
    )
    this["sysl"] = OpCodeDoc(
        "SYSL",
        """System instruction with result. For more information, see Op0 equals 0b01,
cache maintenance, TLB maintenance, and address translation instructions for
the encodings of System instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SYSL--System-instruction-with-result-"
    )
    this["sysp"] = OpCodeDoc(
        "SYSP",
        """128-bit System instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/SYSP------bit-system-instruction-"
    )
    this["tbl"] = OpCodeDoc(
        "TBL",
        """Table vector Lookup. This instruction reads each value from the vector
elements in the index source SIMD&FP register, uses each result as an index to
perform a lookup in a table of bytes that is described by one to four source
table SIMD&FP registers, places the lookup result in a vector, and writes the
vector to the destination SIMD&FP register. If an index is out of range for
the table, the result for that lookup is 0. If more than one source register
is used to describe the table, the first source register describes the lowest
bytes of the table.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TBL--Table-vector-lookup-"
    )
    this["tblq"] = OpCodeDoc(
        "TBLQ",
        """For each 128-bit destination vector segment, reads each element of the
corresponding second source (index) vector segment and uses its value to
select an indexed element from the corresponding first source (table) vector
segment. The indexed table element is placed in the element of the destination
vector that corresponds to the index vector element. If an index value is
greater than or equal to the number of elements in a 128-bit vector segment
then it places zero in the corresponding destination vector element. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TBLQ---"
    )
    this["tbnz"] = OpCodeDoc(
        "TBNZ",
        """Test bit and Branch if Nonzero compares the value of a bit in a general-
purpose register with zero, and conditionally branches to a label at a PC-
relative offset if the comparison is not equal. It provides a hint that this
is not a subroutine call or return. This instruction does not affect condition
flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TBNZ--Test-bit-and-branch-if-nonzero-"
    )
    this["tbx"] = OpCodeDoc(
        "TBX",
        """Table vector lookup extension. This instruction reads each value from the
vector elements in the index source SIMD&FP register, uses each result as an
index to perform a lookup in a table of bytes that is described by one to four
source table SIMD&FP registers, places the lookup result in a vector, and
writes the vector to the destination SIMD&FP register. If an index is out of
range for the table, the existing value in the vector element of the
destination register is left unchanged. If more than one source register is
used to describe the table, the first source register describes the lowest
bytes of the table.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TBX--Table-vector-lookup-extension-"
    )
    this["tbxq"] = OpCodeDoc(
        "TBXQ",
        """For each 128-bit destination vector segment, reads each element of the
corresponding second source (index) vector segment and uses its value to
select an indexed element from the corresponding first source (table) vector
segment. The indexed table element is placed in the element of the destination
vector that corresponds to the index vector element. If an index value is
greater than or equal to the number of elements in a 128-bit vector segment
then the corresponding destination vector element is left unchanged. This
instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TBXQ---"
    )
    this["tbz"] = OpCodeDoc(
        "TBZ",
        """Test bit and Branch if Zero compares the value of a test bit with zero, and
conditionally branches to a label at a PC-relative offset if the comparison is
equal. It provides a hint that this is not a subroutine call or return. This
instruction does not affect condition flags.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TBZ--Test-bit-and-branch-if-zero-"
    )
    this["tcancel"] = OpCodeDoc(
        "TCANCEL",
        """This instruction exits Transactional state and discards all state
modifications that were performed transactionally. Execution continues at the
instruction that follows the TSTART instruction of the outer transaction. The
destination register of the TSTART instruction of the outer transaction is
written with the immediate operand of TCANCEL.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TCANCEL--Cancel-current-transaction-"
    )
    this["tcommit"] = OpCodeDoc(
        "TCOMMIT",
        """This instruction commits the current transaction. If the current transaction
is an outer transaction, then Transactional state is exited, and all state
modifications performed transactionally are committed to the architectural
state. TCOMMIT takes no inputs and returns no value.

Execution of TCOMMIT is UNDEFINED in Non-transactional state.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TCOMMIT--Commit-current-transaction-"
    )
    this["tlbi"] = OpCodeDoc(
        "TLBI",
        """TLB Invalidate operation. For more information, see op0==0b01, cache
maintenance, TLB maintenance, and address translation instructions.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TLBI--Tlb-invalidate-operation-"
    )
    this["tlbip"] = OpCodeDoc(
        "TLBIP",
        """TLB Invalidate Pair operation.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TLBIP--Tlb-invalidate-pair-operation-"
    )
    this["trcit"] = OpCodeDoc(
        "TRCIT",
        """Trace Instrumentation generates an instrumentation trace packet that contains
the value of the provided register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TRCIT--Trace-instrumentation-"
    )
    this["trn1"] = OpCodeDoc(
        "TRN1",
        """Transpose vectors (primary). This instruction reads corresponding even-
numbered vector elements from the two source SIMD&FP registers, starting at
zero, places each result into consecutive elements of a vector, and writes the
vector to the destination SIMD&FP register. Vector elements from the first
source register are placed into even-numbered elements of the destination
vector, starting at zero, while vector elements from the second source
register are placed into odd-numbered elements of the destination vector.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TRN---Transpose-vectors--primary--"
    )
    this["trn2"] = OpCodeDoc(
        "TRN2",
        """Transpose vectors (secondary). This instruction reads corresponding odd-
numbered vector elements from the two source SIMD&FP registers, places each
result into consecutive elements of a vector, and writes the vector to the
destination SIMD&FP register. Vector elements from the first source register
are placed into even-numbered elements of the destination vector, starting at
zero, while vector elements from the second source register are placed into
odd-numbered elements of the destination vector.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TRN---Transpose-vectors--secondary--"
    )
    this["tsbcsync"] = OpCodeDoc(
        "TSBCSYNC",
        """Trace Synchronization Barrier. This instruction is a barrier that synchronizes
the trace operations of instructions, see Trace Synchronization Buffer (TSB
CSYNC).

If FEAT_TRF is not implemented, this instruction executes as a `NOP`.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TSB-CSYNC--Trace-synchronization-barrier-"
    )
    this["tst"] = OpCodeDoc(
        "TST",
        """Test (shifted register) performs a bitwise AND operation on a register value
and an optionally-shifted register value. It updates the condition flags based
on the result, and discards the result.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TST--shifted-register---Test--shifted-register--"
    )
    this["tstart"] = OpCodeDoc(
        "TSTART",
        """This instruction starts a new transaction. If the transaction started
successfully, the destination register is set to zero. If the transaction
failed or was canceled, then all state modifications that were performed
transactionally are discarded and the destination register is written with a
nonzero value that encodes the cause of the failure.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TSTART--Start-transaction-"
    )
    this["ttest"] = OpCodeDoc(
        "TTEST",
        """This instruction writes the depth of the transaction to the destination
register, or the value 0 otherwise.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/TTEST--Test-transaction-state-"
    )
    this["uaba"] = OpCodeDoc(
        "UABA",
        """Unsigned Absolute difference and Accumulate. This instruction subtracts the
elements of the vector of the second source SIMD&FP register from the
corresponding elements of the first source SIMD&FP register, and accumulates
the absolute values of the results into the elements of the vector of the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABA--Unsigned-absolute-difference-and-accumulate-"
    )
    this["uabal"] = OpCodeDoc(
        "UABAL",
        """Unsigned Absolute difference and Accumulate Long. This instruction subtracts
the vector elements in the lower or upper half of the second source SIMD&FP
register from the corresponding vector elements of the first source SIMD&FP
register, and accumulates the absolute values of the results into the vector
elements of the destination SIMD&FP register. The destination vector elements
are twice as long as the source vector elements. All the values in this
instruction are unsigned integer values.

The `UABAL` instruction extracts each source vector from the lower half of
each source register. The `UABAL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABAL--UABAL---Unsigned-absolute-difference-and-accumulate-long-"
    )
    this["uabal2"] = OpCodeDoc(
        "UABAL2",
        """Unsigned Absolute difference and Accumulate Long. This instruction subtracts
the vector elements in the lower or upper half of the second source SIMD&FP
register from the corresponding vector elements of the first source SIMD&FP
register, and accumulates the absolute values of the results into the vector
elements of the destination SIMD&FP register. The destination vector elements
are twice as long as the source vector elements. All the values in this
instruction are unsigned integer values.

The `UABAL` instruction extracts each source vector from the lower half of
each source register. The `UABAL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABAL--UABAL---Unsigned-absolute-difference-and-accumulate-long-"
    )
    this["uabalb"] = OpCodeDoc(
        "UABALB",
        """Compute the absolute difference between even-numbered unsigned elements of the
second source vector and corresponding elements of the first source vector,
and destructively add to the overlapping double-width elements of the addend
vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABALB---"
    )
    this["uabalt"] = OpCodeDoc(
        "UABALT",
        """Compute the absolute difference between odd-numbered unsigned elements of the
second source vector and corresponding elements of the first source vector,
and destructively add to the overlapping double-width elements of the addend
vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABALT---"
    )
    this["uabd"] = OpCodeDoc(
        "UABD",
        """Unsigned Absolute Difference (vector). This instruction subtracts the elements
of the vector of the second source SIMD&FP register from the corresponding
elements of the first source SIMD&FP register, places the absolute values of
the results into a vector, and writes the vector to the destination SIMD&FP
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABD--Unsigned-absolute-difference--vector--"
    )
    this["uabdl"] = OpCodeDoc(
        "UABDL",
        """Unsigned Absolute Difference Long. This instruction subtracts the vector
elements in the lower or upper half of the second source SIMD&FP register from
the corresponding vector elements of the first source SIMD&FP register, places
the absolute value of the result into a vector, and writes the vector to the
destination SIMD&FP register. The destination vector elements are twice as
long as the source vector elements. All the values in this instruction are
unsigned integer values.

The `UABDL` instruction extracts each source vector from the lower half of
each source register. The `UABDL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABDL--UABDL---Unsigned-absolute-difference-long-"
    )
    this["uabdl2"] = OpCodeDoc(
        "UABDL2",
        """Unsigned Absolute Difference Long. This instruction subtracts the vector
elements in the lower or upper half of the second source SIMD&FP register from
the corresponding vector elements of the first source SIMD&FP register, places
the absolute value of the result into a vector, and writes the vector to the
destination SIMD&FP register. The destination vector elements are twice as
long as the source vector elements. All the values in this instruction are
unsigned integer values.

The `UABDL` instruction extracts each source vector from the lower half of
each source register. The `UABDL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABDL--UABDL---Unsigned-absolute-difference-long-"
    )
    this["uabdlb"] = OpCodeDoc(
        "UABDLB",
        """Compute the absolute difference between the even-numbered unsigned integer
values in elements of the second source vector and the corresponding elements
of the first source vector, and place the results in the overlapping double-
width elements of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABDLB---"
    )
    this["uabdlt"] = OpCodeDoc(
        "UABDLT",
        """Compute the absolute difference between the odd-numbered unsigned integer
values in elements of the second source vector and corresponding elements of
the first source vector, and place the results in the overlapping double-width
elements of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UABDLT---"
    )
    this["uadalp"] = OpCodeDoc(
        "UADALP",
        """Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of
adjacent unsigned integer values from the vector in the source SIMD&FP
register and accumulates the results with the vector elements of the
destination SIMD&FP register. The destination vector elements are twice as
long as the source vector elements.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADALP--Unsigned-add-and-accumulate-long-pairwise-"
    )
    this["uaddl"] = OpCodeDoc(
        "UADDL",
        """Unsigned Add Long (vector). This instruction adds each vector element in the
lower or upper half of the first source SIMD&FP register to the corresponding
vector element of the second source SIMD&FP register, places the result into a
vector, and writes the vector to the destination SIMD&FP register. The
destination vector elements are twice as long as the source vector elements.
All the values in this instruction are unsigned integer values.

The `UADDL` instruction extracts each source vector from the lower half of
each source register. The `UADDL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDL--UADDL---Unsigned-add-long--vector--"
    )
    this["uaddl2"] = OpCodeDoc(
        "UADDL2",
        """Unsigned Add Long (vector). This instruction adds each vector element in the
lower or upper half of the first source SIMD&FP register to the corresponding
vector element of the second source SIMD&FP register, places the result into a
vector, and writes the vector to the destination SIMD&FP register. The
destination vector elements are twice as long as the source vector elements.
All the values in this instruction are unsigned integer values.

The `UADDL` instruction extracts each source vector from the lower half of
each source register. The `UADDL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDL--UADDL---Unsigned-add-long--vector--"
    )
    this["uaddlb"] = OpCodeDoc(
        "UADDLB",
        """Add the corresponding even-numbered unsigned elements of the first and second
source vectors, and place the results in the overlapping double-width elements
of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDLB---"
    )
    this["uaddlp"] = OpCodeDoc(
        "UADDLP",
        """Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned
integer values from the vector in the source SIMD&FP register, places the
result into a vector, and writes the vector to the destination SIMD&FP
register. The destination vector elements are twice as long as the source
vector elements.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDLP--Unsigned-add-long-pairwise-"
    )
    this["uaddlt"] = OpCodeDoc(
        "UADDLT",
        """Add the corresponding odd-numbered unsigned elements of the first and second
source vectors, and place the results in the overlapping double-width elements
of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDLT---"
    )
    this["uaddlv"] = OpCodeDoc(
        "UADDLV",
        """Unsigned sum Long across Vector. This instruction adds every vector element in
the source SIMD&FP register together, and writes the scalar result to the
destination SIMD&FP register. The destination scalar is twice as long as the
source vector elements. All the values in this instruction are unsigned
integer values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDLV--Unsigned-sum-long-across-vector-"
    )
    this["uaddv"] = OpCodeDoc(
        "UADDV",
        """Unsigned add horizontally across all lanes of a vector, and place the result
in the SIMD&FP scalar destination register. Narrow elements are first zero-
extended to 64 bits. Inactive elements in the source vector are treated as
zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDV---"
    )
    this["uaddw"] = OpCodeDoc(
        "UADDW",
        """Unsigned Add Wide. This instruction adds the vector elements of the first
source SIMD&FP register to the corresponding vector elements in the lower or
upper half of the second source SIMD&FP register, places the result in a
vector, and writes the vector to the SIMD&FP destination register. The vector
elements of the destination register and the first source register are twice
as long as the vector elements of the second source register. All the values
in this instruction are unsigned integer values.

The `UADDW` instruction extracts vector elements from the lower half of the
second source register. The `UADDW2` instruction extracts vector elements from
the upper half of the second source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDW--UADDW---Unsigned-add-wide-"
    )
    this["uaddw2"] = OpCodeDoc(
        "UADDW2",
        """Unsigned Add Wide. This instruction adds the vector elements of the first
source SIMD&FP register to the corresponding vector elements in the lower or
upper half of the second source SIMD&FP register, places the result in a
vector, and writes the vector to the SIMD&FP destination register. The vector
elements of the destination register and the first source register are twice
as long as the vector elements of the second source register. All the values
in this instruction are unsigned integer values.

The `UADDW` instruction extracts vector elements from the lower half of the
second source register. The `UADDW2` instruction extracts vector elements from
the upper half of the second source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDW--UADDW---Unsigned-add-wide-"
    )
    this["uaddwb"] = OpCodeDoc(
        "UADDWB",
        """Add the even-numbered unsigned elements of the second source vector to the
overlapping double-width elements of the first source vector and place the
results in the corresponding double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDWB---"
    )
    this["uaddwt"] = OpCodeDoc(
        "UADDWT",
        """Add the odd-numbered unsigned elements of the second source vector to the
overlapping double-width elements of the first source vector and place the
results in the corresponding double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UADDWT---"
    )
    this["ubfiz"] = OpCodeDoc(
        "UBFIZ",
        """Unsigned Bitfield Insert in Zeros copies a bitfield of <width> bits from the
least significant bits of the source register to bit position <lsb> of the
destination register, setting the destination bits above and below the
bitfield to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UBFIZ--Unsigned-bitfield-insert-in-zero-"
    )
    this["ubfm"] = OpCodeDoc(
        "UBFM",
        """Unsigned Bitfield Move is usually accessed via one of its aliases, which are
always preferred for disassembly.

If <imms> is greater than or equal to <immr>, this copies a bitfield of
(<imms>-<immr>+1) bits starting from bit position <immr> in the source
register to the least significant bits of the destination register.

If <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from
the least significant bits of the source register to bit position
(regsize-<immr>) of the destination register, where regsize is the destination
register size of 32 or 64 bits.

In both cases the destination bits below and above the bitfield are set to
zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UBFM--Unsigned-bitfield-move-"
    )
    this["ubfx"] = OpCodeDoc(
        "UBFX",
        """Unsigned Bitfield Extract copies a bitfield of <width> bits starting from bit
position <lsb> in the source register to the least significant bits of the
destination register, and sets destination bits above the bitfield to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UBFX--Unsigned-bitfield-extract-"
    )
    this["uclamp"] = OpCodeDoc(
        "UCLAMP",
        """Clamp each unsigned element in the two or four destination vectors to between
the unsigned minimum value in the corresponding element of the first source
vector and the unsigned maximum value in the corresponding element of the
second source vector and destructively place the clamped results in the
corresponding elements of the two or four destination vectors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UCLAMP---"
    )
    this["ucvtf"] = OpCodeDoc(
        "UCVTF",
        """Unsigned fixed-point Convert to Floating-point (vector). This instruction
converts each element in a vector from fixed-point to floating-point using the
rounding mode that is specified by the FPCR, and writes the result to the
SIMD&FP destination register.

A floating-point exception can be generated by this instruction. Depending on
the settings in FPCR, the exception results in either a flag being set in
FPSR, or a synchronous exception being generated. For more information, see
Floating-point exception traps.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the Security state and Exception level in which the instruction is
executed, an attempt to execute the instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UCVTF--vector--fixed-point---Unsigned-fixed-point-convert-to-floating-point--vector--"
    )
    this["udf"] = OpCodeDoc(
        "UDF",
        """Permanently Undefined generates an Undefined Instruction exception (ESR_ELx.EC
= 0b000000). The encodings for UDF used in this section are defined as
permanently undefined.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UDF--Permanently-undefined-"
    )
    this["udiv"] = OpCodeDoc(
        "UDIV",
        """Unsigned Divide divides an unsigned integer register value by another unsigned
integer register value, and writes the result to the destination register. The
condition flags are not affected.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UDIV--Unsigned-divide-"
    )
    this["udivr"] = OpCodeDoc(
        "UDIVR",
        """Unsigned reversed divide active elements of the second source vector by
corresponding elements of the first source vector and destructively place the
quotient in the corresponding elements of the first source vector. Inactive
elements in the destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UDIVR---"
    )
    this["udot"] = OpCodeDoc(
        "UDOT",
        """Dot Product unsigned arithmetic (vector, by element). This instruction
performs the dot product of the four 8-bit elements in each 32-bit element of
the first source register with the four 8-bit elements of an indexed 32-bit
element in the second source register, accumulating the result into the
corresponding 32-bit element of the destination register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

In Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is
mandatory for all implementations to support it.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UDOT--by-element---Dot-product-unsigned-arithmetic--vector--by-element--"
    )
    this["uhadd"] = OpCodeDoc(
        "UHADD",
        """Unsigned Halving Add. This instruction adds corresponding unsigned integer
values from the two source SIMD&FP registers, shifts each result right one
bit, places the results into a vector, and writes the vector to the
destination SIMD&FP register.

The results are truncated. For rounded results, see URHADD.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UHADD--Unsigned-halving-add-"
    )
    this["uhsub"] = OpCodeDoc(
        "UHSUB",
        """Unsigned Halving Subtract. This instruction subtracts the vector elements in
the second source SIMD&FP register from the corresponding vector elements in
the first source SIMD&FP register, shifts each result right one bit, places
each result into a vector, and writes the vector to the destination SIMD&FP
register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UHSUB--Unsigned-halving-subtract-"
    )
    this["uhsubr"] = OpCodeDoc(
        "UHSUBR",
        """Subtract active unsigned elements of the first source vector from
corresponding unsigned elements of the second source vector, shift right one
bit, and destructively place the results in the corresponding elements of the
first source vector. Inactive elements in the destination vector register
remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UHSUBR---"
    )
    this["umaddl"] = OpCodeDoc(
        "UMADDL",
        """Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a
64-bit register value, and writes the result to the 64-bit destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMADDL--Unsigned-multiply-add-long-"
    )
    this["umax"] = OpCodeDoc(
        "UMAX",
        """Unsigned Maximum (vector). This instruction compares corresponding elements in
the vectors in the two source SIMD&FP registers, places the larger of each
pair of unsigned integer values into a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMAX--Unsigned-maximum--vector--"
    )
    this["umax"] = OpCodeDoc(
        "UMAX",
        """Unsigned Maximum (immediate) determines the unsigned maximum of the source
register value and immediate, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMAX--immediate---Unsigned-maximum--immediate--"
    )
    this["umax"] = OpCodeDoc(
        "UMAX",
        """Unsigned Maximum (register) determines the unsigned maximum of the two source
register values and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMAX--register---Unsigned-maximum--register--"
    )
    this["umax"] = OpCodeDoc(
        "UMAX",
        """Determine the unsigned maximum of an immediate and each element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. The immediate is an unsigned 8-bit value in the range 0 to
255, inclusive. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMAX--immediate----"
    )
    this["umaxp"] = OpCodeDoc(
        "UMAXP",
        """Unsigned Maximum Pairwise. This instruction creates a vector by concatenating
the vector elements of the first source SIMD&FP register after the vector
elements of the second source SIMD&FP register, reads each pair of adjacent
vector elements in the two source SIMD&FP registers, writes the largest of
each pair of unsigned integer values into a vector, and writes the vector to
the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMAXP--Unsigned-maximum-pairwise-"
    )
    this["umaxqv"] = OpCodeDoc(
        "UMAXQV",
        """Unsigned maximum of the same element numbers from each 128-bit source vector
segment, placing each result into the corresponding element number of the
128-bit SIMD&FP destination register. Inactive elements in the source vector
are treated as zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMAXQV---"
    )
    this["umaxv"] = OpCodeDoc(
        "UMAXV",
        """Unsigned Maximum across Vector. This instruction compares all the vector
elements in the source SIMD&FP register, and writes the largest of the values
as a scalar to the destination SIMD&FP register. All the values in this
instruction are unsigned integer values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMAXV--Unsigned-maximum-across-vector-"
    )
    this["umin"] = OpCodeDoc(
        "UMIN",
        """Unsigned Minimum (vector). This instruction compares corresponding vector
elements in the two source SIMD&FP registers, places the smaller of each of
the two unsigned integer values into a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMIN--Unsigned-minimum--vector--"
    )
    this["umin"] = OpCodeDoc(
        "UMIN",
        """Unsigned Minimum (immediate) determines the unsigned minimum of the source
register value and immediate, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMIN--immediate---Unsigned-minimum--immediate--"
    )
    this["umin"] = OpCodeDoc(
        "UMIN",
        """Unsigned Minimum (register) determines the unsigned minimum of the two source
register values and writes the result to the destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMIN--register---Unsigned-minimum--register--"
    )
    this["umin"] = OpCodeDoc(
        "UMIN",
        """Determine the unsigned minimum of an immediate and each element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. The immediate is an unsigned 8-bit value in the range 0 to
255, inclusive. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMIN--immediate----"
    )
    this["uminp"] = OpCodeDoc(
        "UMINP",
        """Unsigned Minimum Pairwise. This instruction creates a vector by concatenating
the vector elements of the first source SIMD&FP register after the vector
elements of the second source SIMD&FP register, reads each pair of adjacent
vector elements in the two source SIMD&FP registers, writes the smallest of
each pair of unsigned integer values into a vector, and writes the vector to
the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMINP--Unsigned-minimum-pairwise-"
    )
    this["uminqv"] = OpCodeDoc(
        "UMINQV",
        """Unsigned minimum of the same element numbers from each 128-bit source vector
segment, placing each result into the corresponding element number of the
128-bit SIMD&FP destination register. Inactive elements in the source vector
are treated as the maximum unsigned integer for the element size.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMINQV---"
    )
    this["uminv"] = OpCodeDoc(
        "UMINV",
        """Unsigned Minimum across Vector. This instruction compares all the vector
elements in the source SIMD&FP register, and writes the smallest of the values
as a scalar to the destination SIMD&FP register. All the values in this
instruction are unsigned integer values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMINV--Unsigned-minimum-across-vector-"
    )
    this["umlal"] = OpCodeDoc(
        "UMLAL",
        """Unsigned Multiply-Add Long (vector, by element). This instruction multiplies
each vector element in the lower or upper half of the first source SIMD&FP
register by the specified vector element of the second source SIMD&FP register
and accumulates the results with the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the
elements that are multiplied.

The `UMLAL` instruction extracts vector elements from the lower half of the
first source register. The `UMLAL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLAL--UMLAL---by-element---Unsigned-multiply-add-long--vector--by-element--"
    )
    this["umlal2"] = OpCodeDoc(
        "UMLAL2",
        """Unsigned Multiply-Add Long (vector, by element). This instruction multiplies
each vector element in the lower or upper half of the first source SIMD&FP
register by the specified vector element of the second source SIMD&FP register
and accumulates the results with the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the
elements that are multiplied.

The `UMLAL` instruction extracts vector elements from the lower half of the
first source register. The `UMLAL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLAL--UMLAL---by-element---Unsigned-multiply-add-long--vector--by-element--"
    )
    this["umlalb"] = OpCodeDoc(
        "UMLALB",
        """Multiply the corresponding even-numbered unsigned elements of the first and
second source vectors and destructively add to the overlapping double-width
elements of the addend vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLALB--vectors----"
    )
    this["umlall"] = OpCodeDoc(
        "UMLALL",
        """This unsigned integer multiply-add long-long instruction multiplies each
unsigned 8-bit or 16-bit element in the one, two, or four first source vectors
with each unsigned 8-bit or 16-bit indexed element of second source vector,
widens each product to 32-bits or 64-bits and destructively adds these values
to the corresponding 32-bit or 64-bit elements of the ZA quad-vector groups.

The elements within the second source vector are specified using an immediate
element index which selects the same element position within each 128-bit
vector segment. The index range is from 0 to one less than the number of
elements per 128-bit segment, encoded in 3 to 4 bits depending on the size of
the element. The lowest of the four consecutive vector numbers forming the
quad-vector group within all of, each half of, or each quarter of the ZA array
are selected by the sum of the vector select register and immediate offset,
modulo all, half, or quarter the number of ZA array vectors.

The vector group symbol, VGx2 or VGx4, indicates that the ZA operand consists
of two or four ZA quad-vector groups respectively. The vector group symbol is
preferred for disassembly, but optional in assembler source code.

This instruction is unpredicated.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 16-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLALL--multiple-and-indexed-vector----"
    )
    this["umlalt"] = OpCodeDoc(
        "UMLALT",
        """Multiply the corresponding odd-numbered unsigned elements of the first and
second source vectors and destructively add to the overlapping double-width
elements of the addend vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLALT--vectors----"
    )
    this["umlsl"] = OpCodeDoc(
        "UMLSL",
        """Unsigned Multiply-Subtract Long (vector, by element). This instruction
multiplies each vector element in the lower or upper half of the first source
SIMD&FP register by the specified vector element of the second source SIMD&FP
register and subtracts the results from the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the
elements that are multiplied.

The `UMLSL` instruction extracts vector elements from the lower half of the
first source register. The `UMLSL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLSL--UMLSL---by-element---Unsigned-multiply-subtract-long--vector--by-element--"
    )
    this["umlsl2"] = OpCodeDoc(
        "UMLSL2",
        """Unsigned Multiply-Subtract Long (vector, by element). This instruction
multiplies each vector element in the lower or upper half of the first source
SIMD&FP register by the specified vector element of the second source SIMD&FP
register and subtracts the results from the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the
elements that are multiplied.

The `UMLSL` instruction extracts vector elements from the lower half of the
first source register. The `UMLSL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLSL--UMLSL---by-element---Unsigned-multiply-subtract-long--vector--by-element--"
    )
    this["umlslb"] = OpCodeDoc(
        "UMLSLB",
        """Multiply the corresponding even-numbered unsigned elements of the first and
second source vectors and destructively subtract from the overlapping double-
width elements of the addend vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLSLB--vectors----"
    )
    this["umlsll"] = OpCodeDoc(
        "UMLSLL",
        """This unsigned integer multiply-subtract long-long instruction multiplies each
unsigned 8-bit or 16-bit element in the one, two, or four first source vectors
with each unsigned 8-bit or 16-bit indexed element of second source vector,
widens each product to 32-bits or 64-bits and destructively subtracts these
values from the corresponding 32-bit or 64-bit elements of the ZA quad-vector
groups.

The elements within the second source vector are specified using an immediate
element index which selects the same element position within each 128-bit
vector segment. The index range is from 0 to one less than the number of
elements per 128-bit segment, encoded in 3 to 4 bits depending on the size of
the element. The lowest of the four consecutive vector numbers forming the
quad-vector group within all of, each half of, or each quarter of the ZA array
are selected by the sum of the vector select register and immediate offset,
modulo all, half, or quarter the number of ZA array vectors.

The vector group symbol, VGx2 or VGx4, indicates that the ZA operand consists
of two or four ZA quad-vector groups respectively. The vector group symbol is
preferred for disassembly, but optional in assembler source code.

This instruction is unpredicated.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 16-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLSLL--multiple-and-indexed-vector----"
    )
    this["umlslt"] = OpCodeDoc(
        "UMLSLT",
        """Multiply the corresponding odd-numbered unsigned elements of the first and
second source vectors and destructively subtract from the overlapping double-
width elements of the addend vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMLSLT--vectors----"
    )
    this["ummla"] = OpCodeDoc(
        "UMMLA",
        """Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies
the 2x8 matrix of unsigned 8-bit integer values in the first source vector by
the 8x2 matrix of unsigned 8-bit integer values in the second source vector.
The resulting 2x2 32-bit integer matrix product is destructively added to the
32-bit integer matrix accumulator in the destination vector. This is
equivalent to performing an 8-way dot product per destination element.

From Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is
mandatory for implementations that include Advanced SIMD to support it.
ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMMLA--vector---Unsigned---bit-integer-matrix-multiply-accumulate--vector--"
    )
    this["umnegl"] = OpCodeDoc(
        "UMNEGL",
        """Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates
the product, and writes the result to the 64-bit destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMNEGL--Unsigned-multiply-negate-long-"
    )
    this["umopa"] = OpCodeDoc(
        "UMOPA",
        """This instruction works with a 32-bit element ZA tile.

The unsigned integer sum of outer products and accumulate instructions
multiply the sub-matrix in the first source vector by the sub-matrix in the
second source vector. The first source holds SVLS2 sub-matrix of unsigned
16-bit integer values, and the second source holds 2SVLS sub-matrix of
unsigned 16-bit integer values.

Each source vector is independently predicated by a corresponding governing
predicate. When a 16-bit source element is inactive, it is treated as having
the value 0.

The resulting SVLSSVLS widened 32-bit integer sum of outer products is then
destructively added to the 32-bit integer destination tile. This is equivalent
to performing a 2-way dot product and accumulate to each of the destination
tile elements.

Each 32-bit container of the first source vector holds 2 consecutive column
elements of each row of a SVLS2 sub-matrix, and each 32-bit container of the
second source vector holds 2 consecutive row elements of each column of a
2SVLS sub-matrix.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMOPA----way----"
    )
    this["umops"] = OpCodeDoc(
        "UMOPS",
        """This instruction works with a 32-bit element ZA tile.

The unsigned integer sum of outer products and subtract instructions multiply
the sub-matrix in the first source vector by the sub-matrix in the second
source vector. The first source holds SVLS2 sub-matrix of unsigned 16-bit
integer values, and the second source holds 2SVLS sub-matrix of unsigned
16-bit integer values.

Each source vector is independently predicated by a corresponding governing
predicate. When a 16-bit source element is inactive, it is treated as having
the value 0.

The resulting SVLSSVLS widened 32-bit integer sum of outer products is then
destructively subtracted from the 32-bit integer destination tile. This is
equivalent to performing a 2-way dot product and subtract from each of the
destination tile elements.

Each 32-bit container of the first source vector holds 2 consecutive column
elements of each row of a SVLS2 sub-matrix, and each 32-bit container of the
second source vector holds 2 consecutive row elements of each column of a
2SVLS sub-matrix.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMOPS----way----"
    )
    this["umov"] = OpCodeDoc(
        "UMOV",
        """Unsigned Move vector element to general-purpose register. This instruction
reads the unsigned integer from the source SIMD&FP register, zero-extends it
to form a 32-bit or 64-bit value, and writes the result to the destination
general-purpose register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMOV--Unsigned-move-vector-element-to-general-purpose-register-"
    )
    this["umsubl"] = OpCodeDoc(
        "UMSUBL",
        """Unsigned Multiply-Subtract Long multiplies two 32-bit register values,
subtracts the product from a 64-bit register value, and writes the result to
the 64-bit destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMSUBL--Unsigned-multiply-subtract-long-"
    )
    this["umulh"] = OpCodeDoc(
        "UMULH",
        """Unsigned Multiply High multiplies two 64-bit register values, and writes
bits[127:64] of the 128-bit result to the 64-bit destination register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMULH--Unsigned-multiply-high-"
    )
    this["umull"] = OpCodeDoc(
        "UMULL",
        """Unsigned Multiply Long (vector, by element). This instruction multiplies each
vector element in the lower or upper half of the first source SIMD&FP register
by the specified vector element of the second source SIMD&FP register, places
the results in a vector, and writes the vector to the destination SIMD&FP
register. The destination vector elements are twice as long as the elements
that are multiplied.

The `UMULL` instruction extracts vector elements from the lower half of the
first source register. The `UMULL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMULL--UMULL---by-element---Unsigned-multiply-long--vector--by-element--"
    )
    this["umull2"] = OpCodeDoc(
        "UMULL2",
        """Unsigned Multiply Long (vector, by element). This instruction multiplies each
vector element in the lower or upper half of the first source SIMD&FP register
by the specified vector element of the second source SIMD&FP register, places
the results in a vector, and writes the vector to the destination SIMD&FP
register. The destination vector elements are twice as long as the elements
that are multiplied.

The `UMULL` instruction extracts vector elements from the lower half of the
first source register. The `UMULL2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMULL--UMULL---by-element---Unsigned-multiply-long--vector--by-element--"
    )
    this["umullb"] = OpCodeDoc(
        "UMULLB",
        """Multiply the corresponding even-numbered unsigned elements of the first and
second source vectors, and place the results in the overlapping double-width
elements of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMULLB--vectors----"
    )
    this["umullt"] = OpCodeDoc(
        "UMULLT",
        """Multiply the corresponding odd-numbered unsigned elements of the first and
second source vectors, and place the results in the overlapping double-width
elements of the destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UMULLT--vectors----"
    )
    this["uqadd"] = OpCodeDoc(
        "UQADD",
        """Unsigned saturating Add. This instruction adds the values of corresponding
elements of the two source SIMD&FP registers, places the results into a
vector, and writes the vector to the destination SIMD&FP register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQADD--Unsigned-saturating-add-"
    )
    this["uqadd"] = OpCodeDoc(
        "UQADD",
        """Unsigned saturating add of an unsigned immediate to each element of the source
vector, and destructively place the results in the corresponding elements of
the source vector. Each result element is saturated to the N-bit element's
unsigned integer range 0 to (2N)-1. This instruction is unpredicated.

The immediate is an unsigned value in the range 0 to 255, and for element
widths of 16 bits or higher it may also be a positive multiple of 256 in the
range 256 to 65280.

The immediate is encoded in 8 bits with an optional left shift by 8. The
preferred disassembly when the shift option is specified is "#<uimm8>, LSL
#8". However an assembler and disassembler may also allow use of the shifted
16-bit value unless the immediate is 0 and the shift amount is 8, which must
be unambiguously described as "#0, LSL #8".

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQADD--immediate----"
    )
    this["uqcvt"] = OpCodeDoc(
        "UQCVT",
        """Saturate the unsigned integer value in each element of the two source vectors
to half the original source element width, and place the results in the half-
width destination elements.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQCVT--two-registers----"
    )
    this["uqcvtn"] = OpCodeDoc(
        "UQCVTN",
        """Saturate the unsigned integer value in each element of the group of two source
vectors to half the original source element width, and place the two-way
interleaved results in the half-width destination elements.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQCVTN---"
    )
    this["uqdecb"] = OpCodeDoc(
        "UQDECB",
        """Determines the number of active 8-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination. The result is
saturated to the general-purpose register's unsigned integer range.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQDECB---"
    )
    this["uqdecd"] = OpCodeDoc(
        "UQDECD",
        """Determines the number of active 64-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination. The result is
saturated to the general-purpose register's unsigned integer range.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQDECD--scalar----"
    )
    this["uqdech"] = OpCodeDoc(
        "UQDECH",
        """Determines the number of active 16-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination. The result is
saturated to the general-purpose register's unsigned integer range.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQDECH--scalar----"
    )
    this["uqdecp"] = OpCodeDoc(
        "UQDECP",
        """Counts the number of true elements in the source predicate and then uses the
result to decrement the scalar destination. The result is saturated to the
general-purpose register's unsigned integer range.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQDECP--scalar----"
    )
    this["uqdecw"] = OpCodeDoc(
        "UQDECW",
        """Determines the number of active 32-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to decrement the scalar destination. The result is
saturated to the general-purpose register's unsigned integer range.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQDECW--scalar----"
    )
    this["uqincb"] = OpCodeDoc(
        "UQINCB",
        """Determines the number of active 8-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination. The result is
saturated to the general-purpose register's unsigned integer range.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQINCB---"
    )
    this["uqincd"] = OpCodeDoc(
        "UQINCD",
        """Determines the number of active 64-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination. The result is
saturated to the general-purpose register's unsigned integer range.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQINCD--scalar----"
    )
    this["uqinch"] = OpCodeDoc(
        "UQINCH",
        """Determines the number of active 16-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination. The result is
saturated to the general-purpose register's unsigned integer range.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQINCH--scalar----"
    )
    this["uqincp"] = OpCodeDoc(
        "UQINCP",
        """Counts the number of true elements in the source predicate and then uses the
result to increment the scalar destination. The result is saturated to the
general-purpose register's unsigned integer range.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQINCP--scalar----"
    )
    this["uqincw"] = OpCodeDoc(
        "UQINCW",
        """Determines the number of active 32-bit elements implied by the named predicate
constraint, multiplies that by an immediate in the range 1 to 16 inclusive,
and then uses the result to increment the scalar destination. The result is
saturated to the general-purpose register's unsigned integer range.

The named predicate constraint limits the number of active elements in a
single predicate to:

  * A fixed number (`VL1` to `VL256`) 
  * The largest power of two (`POW2`) 
  * The largest multiple of three or four (`MUL3` or `MUL4`) 
  * All available, implicitly a multiple of two (`ALL`). 

Unspecified or out of range constraint encodings generate an empty predicate
or zero element count rather than Undefined Instruction exception.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQINCW--scalar----"
    )
    this["uqrshl"] = OpCodeDoc(
        "UQRSHL",
        """Unsigned saturating Rounding Shift Left (register). This instruction takes
each vector element of the first source SIMD&FP register, shifts the vector
element by a value from the least significant byte of the corresponding vector
element of the second source SIMD&FP register, places the results into a
vector, and writes the vector to the destination SIMD&FP register.

If the shift value is positive, the operation is a left shift. Otherwise, it
is a right shift. The results are rounded. For truncated results, see UQSHL.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQRSHL--Unsigned-saturating-rounding-shift-left--register--"
    )
    this["uqrshlr"] = OpCodeDoc(
        "UQRSHLR",
        """Shift active unsigned elements of the second source vector by corresponding
elements of the first source vector and destructively place the rounded
results in the corresponding elements of the first source vector. A positive
shift amount performs a left shift, otherwise a right shift by the negated
shift amount is performed. Each result element is saturated to the N-bit
element's unsigned integer range 0 to (2N)-1. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQRSHLR---"
    )
    this["uqrshr"] = OpCodeDoc(
        "UQRSHR",
        """Shift right by an immediate value, the unsigned integer value in each element
of the two source vectors and place the rounded results in the half-width
destination elements. Each result element is saturated to the half-width N-bit
element's unsigned integer range 0 to (2N)-1. The immediate shift amount is an
unsigned value in the range 1 to 16.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQRSHR--two-registers----"
    )
    this["uqrshrn"] = OpCodeDoc(
        "UQRSHRN",
        """Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction
reads each vector element in the source SIMD&FP register, right shifts each
result by an immediate value, puts the final result into a vector, and writes
the vector to the lower or upper half of the destination SIMD&FP register. All
the values in this instruction are unsigned integer values. The results are
rounded. For truncated results, see UQSHRN.

The `UQRSHRN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `UQRSHRN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQRSHRN--UQRSHRN---Unsigned-saturating-rounded-shift-right-narrow--immediate--"
    )
    this["uqrshrn2"] = OpCodeDoc(
        "UQRSHRN2",
        """Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction
reads each vector element in the source SIMD&FP register, right shifts each
result by an immediate value, puts the final result into a vector, and writes
the vector to the lower or upper half of the destination SIMD&FP register. All
the values in this instruction are unsigned integer values. The results are
rounded. For truncated results, see UQSHRN.

The `UQRSHRN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `UQRSHRN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQRSHRN--UQRSHRN---Unsigned-saturating-rounded-shift-right-narrow--immediate--"
    )
    this["uqrshrnb"] = OpCodeDoc(
        "UQRSHRNB",
        """Shift each unsigned integer value in the source vector elements right by an
immediate value, and place the rounded results in the even-numbered half-width
destination elements, while setting the odd-numbered elements to zero. Each
result element is saturated to the half-width N-bit element's unsigned integer
range 0 to (2N)-1. The immediate shift amount is an unsigned value in the
range 1 to number of bits per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQRSHRNB---"
    )
    this["uqrshrnt"] = OpCodeDoc(
        "UQRSHRNT",
        """Shift each unsigned integer value in the source vector elements by an
immediate value, and place the rounded results in the odd-numbered half-width
destination elements, leaving the even-numbered elements unchanged. Each
result element is saturated to the half-width N-bit element's unsigned integer
range 0 to (2N)-1. The immediate shift amount is an unsigned value in the
range 1 to number of bits per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQRSHRNT---"
    )
    this["uqshl"] = OpCodeDoc(
        "UQSHL",
        """Unsigned saturating Shift Left (immediate). This instruction takes each vector
element in the source SIMD&FP register, shifts it by an immediate value,
places the results in a vector, and writes the vector to the destination
SIMD&FP register. The results are truncated. For rounded results, see UQRSHL.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSHL--immediate---Unsigned-saturating-shift-left--immediate--"
    )
    this["uqshl"] = OpCodeDoc(
        "UQSHL",
        """Unsigned saturating Shift Left (register). This instruction takes each element
in the vector of the first source SIMD&FP register, shifts the element by a
value from the least significant byte of the corresponding element of the
second source SIMD&FP register, places the results in a vector, and writes the
vector to the destination SIMD&FP register.

If the shift value is positive, the operation is a left shift. Otherwise, it
is a right shift. The results are truncated. For rounded results, see UQRSHL.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSHL--register---Unsigned-saturating-shift-left--register--"
    )
    this["uqshl"] = OpCodeDoc(
        "UQSHL",
        """Shift left by immediate each active unsigned element of the source vector, and
destructively place the results in the corresponding elements of the source
vector. Each result element is saturated to the N-bit element's unsigned
integer range 0 to (2N)-1. The immediate shift amount is an unsigned value in
the range 0 to number of bits per element minus 1. Inactive elements in the
destination vector register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSHL--immediate----"
    )
    this["uqshlr"] = OpCodeDoc(
        "UQSHLR",
        """Shift active unsigned elements of the second source vector by corresponding
elements of the first source vector and destructively place the results in the
corresponding elements of the first source vector. A positive shift amount
performs a left shift, otherwise a right shift by the negated shift amount is
performed. Each result element is saturated to the N-bit element's unsigned
integer range 0 to (2N)-1. Inactive elements in the destination vector
register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSHLR---"
    )
    this["uqshrn"] = OpCodeDoc(
        "UQSHRN",
        """Unsigned saturating Shift Right Narrow (immediate). This instruction reads
each vector element in the source SIMD&FP register, right shifts each result
by an immediate value, saturates each shifted result to a value that is half
the original width, puts the final result into a vector, and writes the vector
to the lower or upper half of the destination SIMD&FP register. All the values
in this instruction are unsigned integer values. The results are truncated.
For rounded results, see UQRSHRN.

The `UQSHRN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `UQSHRN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSHRN--UQSHRN---Unsigned-saturating-shift-right-narrow--immediate--"
    )
    this["uqshrn2"] = OpCodeDoc(
        "UQSHRN2",
        """Unsigned saturating Shift Right Narrow (immediate). This instruction reads
each vector element in the source SIMD&FP register, right shifts each result
by an immediate value, saturates each shifted result to a value that is half
the original width, puts the final result into a vector, and writes the vector
to the lower or upper half of the destination SIMD&FP register. All the values
in this instruction are unsigned integer values. The results are truncated.
For rounded results, see UQRSHRN.

The `UQSHRN` instruction writes the vector to the lower half of the
destination register and clears the upper half, while the `UQSHRN2`
instruction writes the vector to the upper half of the destination register
without affecting the other bits of the register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSHRN--UQSHRN---Unsigned-saturating-shift-right-narrow--immediate--"
    )
    this["uqshrnb"] = OpCodeDoc(
        "UQSHRNB",
        """Shift each unsigned integer value in the source vector elements right by an
immediate value, and place the truncated results in the even-numbered half-
width destination elements, while setting the odd-numbered elements to zero.
Each result element is saturated to the half-width N-bit element's unsigned
integer range 0 to (2N)-1. The immediate shift amount is an unsigned value in
the range 1 to number of bits per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSHRNB---"
    )
    this["uqshrnt"] = OpCodeDoc(
        "UQSHRNT",
        """Shift each unsigned integer value in the source vector elements right by an
immediate value, and place the truncated results in the odd-numbered half-
width destination elements, leaving the even-numbered elements unchanged. Each
result element is saturated to the half-width N-bit element's unsigned integer
range 0 to (2N)-1. The immediate shift amount is an unsigned value in the
range 1 to number of bits per element. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSHRNT---"
    )
    this["uqsub"] = OpCodeDoc(
        "UQSUB",
        """Unsigned saturating Subtract. This instruction subtracts the element values of
the second source SIMD&FP register from the corresponding element values of
the first source SIMD&FP register, places the results into a vector, and
writes the vector to the destination SIMD&FP register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSUB--Unsigned-saturating-subtract-"
    )
    this["uqsub"] = OpCodeDoc(
        "UQSUB",
        """Unsigned saturating subtract an unsigned immediate from each element of the
source vector, and destructively place the results in the corresponding
elements of the source vector. Each result element is saturated to the N-bit
element's unsigned integer range 0 to (2N)-1. This instruction is
unpredicated.

The immediate is an unsigned value in the range 0 to 255, and for element
widths of 16 bits or higher it may also be a positive multiple of 256 in the
range 256 to 65280.

The immediate is encoded in 8 bits with an optional left shift by 8. The
preferred disassembly when the shift option is specified is "#<uimm8>, LSL
#8". However an assembler and disassembler may also allow use of the shifted
16-bit value unless the immediate is 0 and the shift amount is 8, which must
be unambiguously described as "#0, LSL #8".

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSUB--immediate----"
    )
    this["uqsubr"] = OpCodeDoc(
        "UQSUBR",
        """Subtract active unsigned elements of the first source vector from
corresponding unsigned elements of the second source vector and destructively
place the results in the corresponding elements of the first source vector.
Each result element is saturated to the N-bit element's unsigned integer range
0 to (2N)-1. Inactive elements in the destination vector register remain
unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQSUBR---"
    )
    this["uqxtn"] = OpCodeDoc(
        "UQXTN",
        """Unsigned saturating extract Narrow. This instruction reads each vector element
from the source SIMD&FP register, saturates each value to half the original
width, places the result into a vector, and writes the vector to the
destination SIMD&FP register. All the values in this instruction are unsigned
integer values.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `UQXTN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `UQXTN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQXTN--UQXTN---Unsigned-saturating-extract-narrow-"
    )
    this["uqxtn2"] = OpCodeDoc(
        "UQXTN2",
        """Unsigned saturating extract Narrow. This instruction reads each vector element
from the source SIMD&FP register, saturates each value to half the original
width, places the result into a vector, and writes the vector to the
destination SIMD&FP register. All the values in this instruction are unsigned
integer values.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The `UQXTN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `UQXTN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQXTN--UQXTN---Unsigned-saturating-extract-narrow-"
    )
    this["uqxtnb"] = OpCodeDoc(
        "UQXTNB",
        """Saturate the unsigned integer value in each source element to half the
original source element width, and place the results in the even-numbered
half-width destination elements, while setting the odd-numbered elements to
zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQXTNB---"
    )
    this["uqxtnt"] = OpCodeDoc(
        "UQXTNT",
        """Saturate the unsigned integer value in each source element to half the
original source element width, and place the results in the odd-numbered half-
width destination elements, leaving the even-numbered elements unchanged.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UQXTNT---"
    )
    this["urecpe"] = OpCodeDoc(
        "URECPE",
        """Unsigned Reciprocal Estimate. This instruction reads each vector element from
the source SIMD&FP register, calculates an approximate inverse for the
unsigned integer value, places the result into a vector, and writes the vector
to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/URECPE--Unsigned-reciprocal-estimate-"
    )
    this["urhadd"] = OpCodeDoc(
        "URHADD",
        """Unsigned Rounding Halving Add. This instruction adds corresponding unsigned
integer values from the two source SIMD&FP registers, shifts each result right
one bit, places the results into a vector, and writes the vector to the
destination SIMD&FP register.

The results are rounded. For truncated results, see UHADD.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/URHADD--Unsigned-rounding-halving-add-"
    )
    this["urshl"] = OpCodeDoc(
        "URSHL",
        """Unsigned Rounding Shift Left (register). This instruction takes each element
in the vector of the first source SIMD&FP register, shifts the vector element
by a value from the least significant byte of the corresponding element of the
second source SIMD&FP register, places the results in a vector, and writes the
vector to the destination SIMD&FP register.

If the shift value is positive, the operation is a left shift. If the shift
value is negative, it is a rounding right shift.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/URSHL--Unsigned-rounding-shift-left--register--"
    )
    this["urshlr"] = OpCodeDoc(
        "URSHLR",
        """Shift active unsigned elements of the second source vector by corresponding
elements of the first source vector and destructively place the rounded
results in the corresponding elements of the first source vector. A positive
shift amount performs a left shift, otherwise a right shift by the negated
shift amount is performed. Inactive elements in the destination vector
register remain unmodified.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/URSHLR---"
    )
    this["urshr"] = OpCodeDoc(
        "URSHR",
        """Unsigned Rounding Shift Right (immediate). This instruction reads each vector
element in the source SIMD&FP register, right shifts each result by an
immediate value, writes the final result to a vector, and writes the vector to
the destination SIMD&FP register. All the values in this instruction are
unsigned integer values. The results are rounded. For truncated results, see
USHR.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/URSHR--Unsigned-rounding-shift-right--immediate--"
    )
    this["ursqrte"] = OpCodeDoc(
        "URSQRTE",
        """Unsigned Reciprocal Square Root Estimate. This instruction reads each vector
element from the source SIMD&FP register, calculates an approximate inverse
square root for each value, places the result into a vector, and writes the
vector to the destination SIMD&FP register. All the values in this instruction
are unsigned integer values.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/URSQRTE--Unsigned-reciprocal-square-root-estimate-"
    )
    this["ursra"] = OpCodeDoc(
        "URSRA",
        """Unsigned Rounding Shift Right and Accumulate (immediate). This instruction
reads each vector element in the source SIMD&FP register, right shifts each
result by an immediate value, and accumulates the final results with the
vector elements of the destination SIMD&FP register. All the values in this
instruction are unsigned integer values. The results are rounded. For
truncated results, see USRA.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/URSRA--Unsigned-rounding-shift-right-and-accumulate--immediate--"
    )
    this["usdot"] = OpCodeDoc(
        "USDOT",
        """Dot Product index form with unsigned and signed integers. This instruction
performs the dot product of the four unsigned 8-bit integer values in each
32-bit element of the first source register with the four signed 8-bit integer
values in an indexed 32-bit element of the second source register,
accumulating the result into the corresponding 32-bit element of the
destination register.

From Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is
mandatory for implementations that include Advanced SIMD to support it.
ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USDOT--by-element---Dot-product-with-unsigned-and-signed-integers--vector--by-element--"
    )
    this["ushl"] = OpCodeDoc(
        "USHL",
        """Unsigned Shift Left (register). This instruction takes each element in the
vector of the first source SIMD&FP register, shifts each element by a value
from the least significant byte of the corresponding element of the second
source SIMD&FP register, places the results in a vector, and writes the vector
to the destination SIMD&FP register.

If the shift value is positive, the operation is a left shift. If the shift
value is negative, it is a truncating right shift. For a rounding shift, see
URSHL.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USHL--Unsigned-shift-left--register--"
    )
    this["ushll"] = OpCodeDoc(
        "USHLL",
        """Unsigned Shift Left Long (immediate). This instruction reads each vector
element in the lower or upper half of the source SIMD&FP register, shifts the
unsigned integer value left by the specified number of bits, places the result
into a vector, and writes the vector to the destination SIMD&FP register. The
destination vector elements are twice as long as the source vector elements.

The `USHLL` instruction extracts vector elements from the lower half of the
source register. The `USHLL2` instruction extracts vector elements from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USHLL--USHLL---Unsigned-shift-left-long--immediate--"
    )
    this["ushll2"] = OpCodeDoc(
        "USHLL2",
        """Unsigned Shift Left Long (immediate). This instruction reads each vector
element in the lower or upper half of the source SIMD&FP register, shifts the
unsigned integer value left by the specified number of bits, places the result
into a vector, and writes the vector to the destination SIMD&FP register. The
destination vector elements are twice as long as the source vector elements.

The `USHLL` instruction extracts vector elements from the lower half of the
source register. The `USHLL2` instruction extracts vector elements from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USHLL--USHLL---Unsigned-shift-left-long--immediate--"
    )
    this["ushllb"] = OpCodeDoc(
        "USHLLB",
        """Shift left by immediate each even-numbered unsigned element of the source
vector, and place the results in the overlapping double-width elements of the
destination vector. The immediate shift amount is an unsigned value in the
range 0 to number of bits per element minus 1. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USHLLB---"
    )
    this["ushllt"] = OpCodeDoc(
        "USHLLT",
        """Shift left by immediate each odd-numbered unsigned element of the source
vector, and place the results in the overlapping double-width elements of the
destination vector. The immediate shift amount is an unsigned value in the
range 0 to number of bits per element minus 1. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USHLLT---"
    )
    this["ushr"] = OpCodeDoc(
        "USHR",
        """Unsigned Shift Right (immediate). This instruction reads each vector element
in the source SIMD&FP register, right shifts each result by an immediate
value, writes the final result to a vector, and writes the vector to the
destination SIMD&FP register. All the values in this instruction are unsigned
integer values. The results are truncated. For rounded results, see URSHR.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USHR--Unsigned-shift-right--immediate--"
    )
    this["usmlall"] = OpCodeDoc(
        "USMLALL",
        """This unsigned by signed integer multiply-add long-long instruction multiplies
each unsigned 8-bit element in the one, two, or four first source vectors with
each signed 8-bit indexed element of the second source vector, widens each
product to 32-bits and destructively adds these values to the corresponding
32-bit elements of the ZA quad-vector groups.

The elements within the second source vector are specified using an immediate
element index which selects the same element position within each 128-bit
vector segment. The element index range is from 0 to one less than the number
of elements per 128-bit segment, encoded in 4 bits. The lowest of the four
consecutive vector numbers forming the quad-vector group within all of, each
half of, or each quarter of the ZA array are selected by the sum of the vector
select register and immediate offset, modulo all, half, or quarter the number
of ZA array vectors.

The vector group symbol, VGx2 or VGx4, indicates that the ZA operand consists
of two or four ZA quad-vector groups respectively. The vector group symbol is
preferred for disassembly, but optional in assembler source code.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USMLALL--multiple-and-indexed-vector----"
    )
    this["usmmla"] = OpCodeDoc(
        "USMMLA",
        """Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction
multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source
vector by the 8x2 matrix of signed 8-bit integer values in the second source
vector. The resulting 2x2 32-bit integer matrix product is destructively added
to the 32-bit integer matrix accumulator in the destination vector. This is
equivalent to performing an 8-way dot product per destination element.

From Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is
mandatory for implementations that include Advanced SIMD to support it.
ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USMMLA--vector---Unsigned-and-signed---bit-integer-matrix-multiply-accumulate--vector--"
    )
    this["usmopa"] = OpCodeDoc(
        "USMOPA",
        """The 8-bit integer variant works with a 32-bit element ZA tile.

The 16-bit integer variant works with a 64-bit element ZA tile.

The unsigned by signed integer sum of outer products and accumulate
instructions multiply the sub-matrix in the first source vector by the sub-
matrix in the second source vector. In case of the 8-bit integer variant, the
first source holds SVLS4 sub-matrix of unsigned 8-bit integer values, and the
second source holds 4SVLS sub-matrix of signed 8-bit integer values. In case
of the 16-bit integer variant, the first source holds SVLD4 sub-matrix of
unsigned 16-bit integer values, and the second source holds 4SVLD sub-matrix
of signed 16-bit integer values.

Each source vector is independently predicated by a corresponding governing
predicate. When an 8-bit source element in case of 8-bit integer variant or a
16-bit source element in case of 16-bit integer variant is Inactive, it is
treated as having the value 0.

The resulting SVLSSVLS widened 32-bit integer or SVLDSVLD widened 64-bit
integer sum of outer products is then destructively added to the 32-bit
integer or 64-bit integer destination tile, respectively for 8-bit integer and
16-bit integer instruction variants. This is equivalent to performing a 4-way
dot product and accumulate to each of the destination tile elements.

In case of the 8-bit integer variant, each 32-bit container of the first
source vector holds 4 consecutive column elements of each row of a SVLS4 sub-
matrix, and each 32-bit container of the second source vector holds 4
consecutive row elements of each column of a 4SVLS sub-matrix. In case of the
16-bit integer variant, each 64-bit container of the first source vector holds
4 consecutive column elements of each row of a SVLD4 sub-matrix, and each
64-bit container of the second source vector holds 4 consecutive row elements
of each column of a 4SVLD sub-matrix.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 16-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USMOPA---"
    )
    this["usmops"] = OpCodeDoc(
        "USMOPS",
        """The 8-bit integer variant works with a 32-bit element ZA tile.

The 16-bit integer variant works with a 64-bit element ZA tile.

The unsigned by signed integer sum of outer products and subtract instructions
multiply the sub-matrix in the first source vector by the sub-matrix in the
second source vector. In case of the 8-bit integer variant, the first source
holds SVLS4 sub-matrix of unsigned 8-bit integer values, and the second
source holds 4SVLS sub-matrix of signed 8-bit integer values. In case of the
16-bit integer variant, the first source holds SVLD4 sub-matrix of unsigned
16-bit integer values, and the second source holds 4SVLD sub-matrix of signed
16-bit integer values.

Each source vector is independently predicated by a corresponding governing
predicate. When an 8-bit source element in case of 8-bit integer variant or a
16-bit source element in case of 16-bit integer variant is Inactive, it is
treated as having the value 0.

The resulting SVLSSVLS widened 32-bit integer or SVLDSVLD widened 64-bit
integer sum of outer products is then destructively subtracted from the 32-bit
integer or 64-bit integer destination tile, respectively for 8-bit integer and
16-bit integer instruction variants. This is equivalent to performing a 4-way
dot product and subtract from each of the destination tile elements.

In case of the 8-bit integer variant, each 32-bit container of the first
source vector holds 4 consecutive column elements of each row of a SVLS4 sub-
matrix, and each 32-bit container of the second source vector holds 4
consecutive row elements of each column of a 4SVLS sub-matrix. In case of the
16-bit integer variant, each 64-bit container of the first source vector holds
4 consecutive column elements of each row of a SVLD4 sub-matrix, and each
64-bit container of the second source vector holds 4 consecutive row elements
of each column of a 4SVLD sub-matrix.

ID_AA64SMFR0_EL1.I16I64 indicates whether the 16-bit integer variant is
implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USMOPS---"
    )
    this["usqadd"] = OpCodeDoc(
        "USQADD",
        """Unsigned saturating Accumulate of Signed value. This instruction adds the
signed integer values of the vector elements in the source SIMD&FP register to
corresponding unsigned integer values of the vector elements in the
destination SIMD&FP register, and accumulates the resulting unsigned integer
values with the vector elements of the destination SIMD&FP register.

If overflow occurs with any of the results, those results are saturated. If
saturation occurs, the cumulative saturation bit FPSR.QC is set.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USQADD--Unsigned-saturating-accumulate-of-signed-value-"
    )
    this["usra"] = OpCodeDoc(
        "USRA",
        """Unsigned Shift Right and Accumulate (immediate). This instruction reads each
vector element in the source SIMD&FP register, right shifts each result by an
immediate value, and accumulates the final results with the vector elements of
the destination SIMD&FP register. All the values in this instruction are
unsigned integer values. The results are truncated. For rounded results, see
URSRA.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USRA--Unsigned-shift-right-and-accumulate--immediate--"
    )
    this["usubl"] = OpCodeDoc(
        "USUBL",
        """Unsigned Subtract Long. This instruction subtracts each vector element in the
lower or upper half of the second source SIMD&FP register from the
corresponding vector element of the first source SIMD&FP register, places the
result into a vector, and writes the vector to the destination SIMD&FP
register. All the values in this instruction are unsigned integer values. The
destination vector elements are twice as long as the source vector elements.

The `USUBL` instruction extracts each source vector from the lower half of
each source register. The `USUBL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USUBL--USUBL---Unsigned-subtract-long-"
    )
    this["usubl2"] = OpCodeDoc(
        "USUBL2",
        """Unsigned Subtract Long. This instruction subtracts each vector element in the
lower or upper half of the second source SIMD&FP register from the
corresponding vector element of the first source SIMD&FP register, places the
result into a vector, and writes the vector to the destination SIMD&FP
register. All the values in this instruction are unsigned integer values. The
destination vector elements are twice as long as the source vector elements.

The `USUBL` instruction extracts each source vector from the lower half of
each source register. The `USUBL2` instruction extracts each source vector
from the upper half of each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USUBL--USUBL---Unsigned-subtract-long-"
    )
    this["usublb"] = OpCodeDoc(
        "USUBLB",
        """Subtract the even-numbered unsigned elements of the second source vector from
the corresponding unsigned elements of the first source vector, and place the
results in the overlapping double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USUBLB---"
    )
    this["usublt"] = OpCodeDoc(
        "USUBLT",
        """Subtract the odd-numbered unsigned elements of the second source vector from
the corresponding unsigned elements of the first source vector, and place the
results in the overlapping double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USUBLT---"
    )
    this["usubw"] = OpCodeDoc(
        "USUBW",
        """Unsigned Subtract Wide. This instruction subtracts each vector element of the
second source SIMD&FP register from the corresponding vector element in the
lower or upper half of the first source SIMD&FP register, places the result in
a vector, and writes the vector to the SIMD&FP destination register. All the
values in this instruction are unsigned integer values.

The vector elements of the destination register and the first source register
are twice as long as the vector elements of the second source register.

The `USUBW` instruction extracts vector elements from the lower half of the
first source register. The `USUBW2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USUBW--USUBW---Unsigned-subtract-wide-"
    )
    this["usubw2"] = OpCodeDoc(
        "USUBW2",
        """Unsigned Subtract Wide. This instruction subtracts each vector element of the
second source SIMD&FP register from the corresponding vector element in the
lower or upper half of the first source SIMD&FP register, places the result in
a vector, and writes the vector to the SIMD&FP destination register. All the
values in this instruction are unsigned integer values.

The vector elements of the destination register and the first source register
are twice as long as the vector elements of the second source register.

The `USUBW` instruction extracts vector elements from the lower half of the
first source register. The `USUBW2` instruction extracts vector elements from
the upper half of the first source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USUBW--USUBW---Unsigned-subtract-wide-"
    )
    this["usubwb"] = OpCodeDoc(
        "USUBWB",
        """Subtract the even-numbered unsigned elements of the second source vector from
the overlapping double-width elements of the first source vector and place the
results in the corresponding double-width elements of the destination vector.
This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USUBWB---"
    )
    this["usubwt"] = OpCodeDoc(
        "USUBWT",
        """Subtract the odd-numbered unsigned elements of the second source vector from
the overlapping double-width elements of the first source vector and place the
results in the corresponding double-width elements of the destination vector.
This instruction is unpredicated. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USUBWT---"
    )
    this["usvdot"] = OpCodeDoc(
        "USVDOT",
        """The unsigned by signed integer vertical dot product instruction computes the
vertical dot product of corresponding unsigned 8-bit elements from the four
first source vectors and four signed 8-bit integer values in the corresponding
indexed 32-bit element of the second source vector. The widened dot product
result is destructively added to the corresponding 32-bit element of the ZA
single-vector groups.

The groups within the second source vector are specified using an immediate
element index which selects the same group position within each 128-bit vector
segment. The index range is from 0 to 3, encoded in 2 bits.

The vector numbers forming the single-vector group within each quarter of the
ZA array are selected by the sum of the vector select register and immediate
offset, modulo quarter the number of ZA array vectors.

The vector group symbol VGx4 indicates that the ZA operand consists of four ZA
single-vector groups. The vector group symbol is preferred for disassembly,
but optional in assembler source code.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/USVDOT---"
    )
    this["uunpk"] = OpCodeDoc(
        "UUNPK",
        """Unpack elements from one or two source vectors and then zero-extend them to
place in elements of twice their size within the two or four destination
vectors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UUNPK---"
    )
    this["uunpkhi"] = OpCodeDoc(
        "UUNPKHI",
        """Unpack elements from the lowest or highest half of the source vector and then
zero-extend them to place in elements of twice their size within the
destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UUNPKHI--UUNPKLO---"
    )
    this["uunpklo"] = OpCodeDoc(
        "UUNPKLO",
        """Unpack elements from the lowest or highest half of the source vector and then
zero-extend them to place in elements of twice their size within the
destination vector. This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UUNPKHI--UUNPKLO---"
    )
    this["uvdot"] = OpCodeDoc(
        "UVDOT",
        """The unsigned integer vertical dot product instruction computes the vertical
dot product of the corresponding two unsigned 16-bit integer values held in
the two first source vectors and two unsigned 16-bit integer values in the
corresponding indexed 32-bit element of the second source vector. The widened
dot product results are destructively added to the corresponding 32-bit
element of the ZA single-vector groups.

The groups within the second source vector are specified using an immediate
element index which selects the same group position within each 128-bit vector
segment. The index range is from 0 to 3, encoded in 2 bits.

The vector numbers forming the single-vector group within each half of the ZA
array are selected by the sum of the vector select register and immediate
offset, modulo half the number of ZA array vectors.

The vector group symbol VGx2 indicates that the ZA operand consists of two ZA
single-vector groups. The vector group symbol is preferred for disassembly,
but optional in assembler source code.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UVDOT----way----"
    )
    this["uxtb"] = OpCodeDoc(
        "UXTB",
        """Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it
to the size of the register, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UXTB--Unsigned-extend-byte-"
    )
    this["uxth"] = OpCodeDoc(
        "UXTH",
        """Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends
it to the size of the register, and writes the result to the destination
register.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UXTH--Unsigned-extend-halfword-"
    )
    this["uxtl"] = OpCodeDoc(
        "UXTL",
        """Unsigned extend Long. This instruction copies each vector element from the
lower or upper half of the source SIMD&FP register into a vector, and writes
the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the source vector elements.

The `UXTL` instruction extracts vector elements from the lower half of the
source register. The `UXTL2` instruction extracts vector elements from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UXTL--UXTL---Unsigned-extend-long-"
    )
    this["uxtl2"] = OpCodeDoc(
        "UXTL2",
        """Unsigned extend Long. This instruction copies each vector element from the
lower or upper half of the source SIMD&FP register into a vector, and writes
the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the source vector elements.

The `UXTL` instruction extracts vector elements from the lower half of the
source register. The `UXTL2` instruction extracts vector elements from the
upper half of the source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UXTL--UXTL---Unsigned-extend-long-"
    )
    this["uzp1"] = OpCodeDoc(
        "UZP1",
        """Unzip vectors (primary). This instruction reads corresponding even-numbered
vector elements from the two source SIMD&FP registers, starting at zero,
places the result from the first source register into consecutive elements in
the lower half of a vector, and the result from the second source register
into consecutive elements in the upper half of a vector, and writes the vector
to the destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UZP---Unzip-vectors--primary--"
    )
    this["uzp2"] = OpCodeDoc(
        "UZP2",
        """Unzip vectors (secondary). This instruction reads corresponding odd-numbered
vector elements from the two source SIMD&FP registers, places the result from
the first source register into consecutive elements in the lower half of a
vector, and the result from the second source register into consecutive
elements in the upper half of a vector, and writes the vector to the
destination SIMD&FP register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UZP---Unzip-vectors--secondary--"
    )
    this["uzp"] = OpCodeDoc(
        "UZP",
        """Concatenate every fourth element from each of the four source vectors and
place them in the corresponding elements of the four destination vectors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UZP--four-registers----"
    )
    this["uzpq1"] = OpCodeDoc(
        "UZPQ1",
        """Concatenate adjacent even-numbered elements from the corresponding 128-bit
vector segments of the first and second source vectors and place in elements
of the corresponding destination vector segment. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UZPQ----"
    )
    this["uzpq2"] = OpCodeDoc(
        "UZPQ2",
        """Concatenate adjacent odd-numbered elements from the corresponding 128-bit
vector segments of the first and second source vectors and place in elements
of the corresponding destination vector segment. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/UZPQ----"
    )
    this["wfe"] = OpCodeDoc(
        "WFE",
        """Wait For Event is a hint instruction that indicates that the PE can enter a
low-power state and remain there until a wakeup event occurs. Wakeup events
include the event signaled as a result of executing the `SEV` instruction on
any PE in the multiprocessor system. For more information, see Wait For Event
mechanism and Send event.

As described in Wait For Event mechanism and Send event, the execution of a
`WFE` instruction that would otherwise cause entry to a low-power state can be
trapped to a higher Exception level.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WFE--Wait-for-event-"
    )
    this["wfet"] = OpCodeDoc(
        "WFET",
        """Wait For Event with Timeout is a hint instruction that indicates that the PE
can enter a low-power state and remain there until either a local timeout
event or a wakeup event occurs. Wakeup events include the event signaled as a
result of executing the `SEV` instruction on any PE in the multiprocessor
system. For more information, see Wait For Event mechanism and Send event.

As described in Wait For Event mechanism and Send event, the execution of a
`WFET` instruction that would otherwise cause entry to a low-power state can
be trapped to a higher Exception level.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WFET--Wait-for-event-with-timeout-"
    )
    this["wfi"] = OpCodeDoc(
        "WFI",
        """Wait For Interrupt is a hint instruction that indicates that the PE can enter
a low-power state and remain there until a wakeup event occurs. For more
information, see Wait For Interrupt.

As described in Wait For Interrupt, the execution of a `WFI` instruction that
would otherwise cause entry to a low-power state can be trapped to a higher
Exception level.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WFI--Wait-for-interrupt-"
    )
    this["wfit"] = OpCodeDoc(
        "WFIT",
        """Wait For Interrupt with Timeout is a hint instruction that indicates that the
PE can enter a low-power state and remain there until either a local timeout
event or a wakeup event occurs. For more information, see Wait For Interrupt.

As described in Wait For Interrupt, the execution of a `WFIT` instruction that
would otherwise cause entry to a low-power state can be trapped to a higher
Exception level.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WFIT--Wait-for-interrupt-with-timeout-"
    )
    this["whilege"] = OpCodeDoc(
        "WHILEGE",
        """Generate a predicate that starting from the highest numbered element is true
while the decrementing value of the first, signed scalar operand is greater
than or equal to the second scalar operand and false thereafter down to the
lowest numbered element.

If the second scalar operand is equal to the minimum signed integer value then
a condition which includes an equality test can never fail and the result will
be an all-true predicate.

The full width of the scalar operands is significant for the purposes of
comparison, and the full width first operand is decremented by one for each
destination predicate element, irrespective of the predicate result element
size. The first general-purpose source register is not itself updated.

The predicate result is placed in the predicate destination register. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILEGE--predicate----"
    )
    this["whilegt"] = OpCodeDoc(
        "WHILEGT",
        """Generate a predicate that starting from the highest numbered element is true
while the decrementing value of the first, signed scalar operand is greater
than the second scalar operand and false thereafter down to the lowest
numbered element.

The full width of the scalar operands is significant for the purposes of
comparison, and the full width first operand is decremented by one for each
destination predicate element, irrespective of the predicate result element
size. The first general-purpose source register is not itself updated.

The predicate result is placed in the predicate destination register. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILEGT--predicate----"
    )
    this["whilehi"] = OpCodeDoc(
        "WHILEHI",
        """Generate a predicate that starting from the highest numbered element is true
while the decrementing value of the first, unsigned scalar operand is higher
than the second scalar operand and false thereafter down to the lowest
numbered element.

The full width of the scalar operands is significant for the purposes of
comparison, and the full width first operand is decremented by one for each
destination predicate element, irrespective of the predicate result element
size. The first general-purpose source register is not itself updated.

The predicate result is placed in the predicate destination register. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILEHI--predicate----"
    )
    this["whilehs"] = OpCodeDoc(
        "WHILEHS",
        """Generate a predicate that starting from the highest numbered element is true
while the decrementing value of the first, unsigned scalar operand is higher
or same as the second scalar operand and false thereafter down to the lowest
numbered element.

If the second scalar operand is equal to the minimum unsigned integer value
then a condition which includes an equality test can never fail and the result
will be an all-true predicate.

The full width of the scalar operands is significant for the purposes of
comparison, and the full width first operand is decremented by one for each
destination predicate element, irrespective of the predicate result element
size. The first general-purpose source register is not itself updated.

The predicate result is placed in the predicate destination register. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILEHS--predicate----"
    )
    this["whilele"] = OpCodeDoc(
        "WHILELE",
        """Generate a predicate that starting from the lowest numbered element is true
while the incrementing value of the first, signed scalar operand is less than
or equal to the second scalar operand and false thereafter up to the highest
numbered element.

If the second scalar operand is equal to the maximum signed integer value then
a condition which includes an equality test can never fail and the result will
be an all-true predicate.

The full width of the scalar operands is significant for the purposes of
comparison, and the full width first operand is incremented by one for each
destination predicate element, irrespective of the predicate result element
size. The first general-purpose source register is not itself updated.

The predicate result is placed in the predicate destination register. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILELE--predicate----"
    )
    this["whilelo"] = OpCodeDoc(
        "WHILELO",
        """Generate a predicate that starting from the lowest numbered element is true
while the incrementing value of the first, unsigned scalar operand is lower
than the second scalar operand and false thereafter up to the highest numbered
element.

The full width of the scalar operands is significant for the purposes of
comparison, and the full width first operand is incremented by one for each
destination predicate element, irrespective of the predicate result element
size. The first general-purpose source register is not itself updated.

The predicate result is placed in the predicate destination register. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILELO--predicate----"
    )
    this["whilels"] = OpCodeDoc(
        "WHILELS",
        """Generate a predicate that starting from the lowest numbered element is true
while the incrementing value of the first, unsigned scalar operand is lower or
same as the second scalar operand and false thereafter up to the highest
numbered element.

If the second scalar operand is equal to the maximum unsigned integer value
then a condition which includes an equality test can never fail and the result
will be an all-true predicate.

The full width of the scalar operands is significant for the purposes of
comparison, and the full width first operand is incremented by one for each
destination predicate element, irrespective of the predicate result element
size. The first general-purpose source register is not itself updated.

The predicate result is placed in the predicate destination register. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILELS--predicate----"
    )
    this["whilelt"] = OpCodeDoc(
        "WHILELT",
        """Generate a predicate that starting from the lowest numbered element is true
while the incrementing value of the first, signed scalar operand is less than
the second scalar operand and false thereafter up to the highest numbered
element.

The full width of the scalar operands is significant for the purposes of
comparison, and the full width first operand is incremented by one for each
destination predicate element, irrespective of the predicate result element
size. The first general-purpose source register is not itself updated.

The predicate result is placed in the predicate destination register. Sets the
First (N), None (Z), !Last (C) condition flags based on the predicate result,
and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILELT--predicate----"
    )
    this["whilerw"] = OpCodeDoc(
        "WHILERW",
        """This instruction checks two addresses for a conflict or overlap between
address ranges of the form [addr,addr+VL8), where VL is the accessible vector
length in bits, that could result in a loop-carried dependency through memory
due to the use of these addresses by contiguous load and store instructions
within the same iteration of a loop. Generate a predicate whose elements are
true while the addresses cannot conflict within the same iteration, and false
thereafter. Sets the First (N), None (Z), !Last (C) condition flags based on
the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILERW---"
    )
    this["whilewr"] = OpCodeDoc(
        "WHILEWR",
        """This instruction checks two addresses for a conflict or overlap between
address ranges of the form [addr,addr+VL8), where VL is the accessible vector
length in bits, that could result in a loop-carried dependency through memory
due to the use of these addresses by contiguous load and store instructions
within the same iteration of a loop. Generate a predicate whose elements are
true while the addresses cannot conflict within the same iteration, and false
thereafter. Sets the First (N), None (Z), !Last (C) condition flags based on
the predicate result, and the V flag to zero.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WHILEWR---"
    )
    this["wrffr"] = OpCodeDoc(
        "WRFFR",
        """Read the source predicate register and place in the first-fault register
(FFR). This instruction is intended to restore a saved FFR and is not
recommended for general use by applications.

This instruction requires that the source predicate contains a monotonic
predicate value, in which starting from bit 0 there are zero or more `1` bits,
followed only by `0` bits in any remaining bit positions. If the source is not
a monotonic predicate value, then the resulting value in the FFR will be
UNPREDICTABLE. It is not possible to generate a non-monotonic value in FFR
when using `SETFFR` followed by first-fault or non-fault loads.

This instruction is illegal when executed in Streaming SVE mode, unless
FEAT_SME_FA64 is implemented and enabled.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/WRFFR---"
    )
    this["xaflag"] = OpCodeDoc(
        "XAFLAG",
        """Convert floating-point condition flags from external format to Arm format.
This instruction converts the state of the PSTATE.{N,Z,C,V} flags from an
alternative representation required by some software to a form representing
the result of an Arm floating-point scalar compare instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/XAFLAG--Convert-floating-point-condition-flags-from-external-format-to-arm-format-"
    )
    this["xar"] = OpCodeDoc(
        "XAR",
        """Exclusive-OR and Rotate performs a bitwise exclusive-OR of the 128-bit vectors
in the two source SIMD&FP registers, rotates each 64-bit element of the
resulting 128-bit vector right by the value specified by a 6-bit immediate
value, and writes the result to the destination SIMD&FP register.

This instruction is implemented only when FEAT_SHA3 is implemented.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/XAR--Exclusive-or-and-rotate-"
    )
    this["xpacd"] = OpCodeDoc(
        "XPACD",
        """Strip Pointer Authentication Code. This instruction removes the pointer
authentication code from an address. The address is in the specified general-
purpose register for `XPACI` and `XPACD`, and is in LR for `XPACLRI`.

The `XPACD` instruction is used for data addresses, and `XPACI` and `XPACLRI`
are used for instruction addresses.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/XPACD--XPACI--XPACLRI--Strip-pointer-authentication-code-"
    )
    this["xpaci"] = OpCodeDoc(
        "XPACI",
        """Strip Pointer Authentication Code. This instruction removes the pointer
authentication code from an address. The address is in the specified general-
purpose register for `XPACI` and `XPACD`, and is in LR for `XPACLRI`.

The `XPACD` instruction is used for data addresses, and `XPACI` and `XPACLRI`
are used for instruction addresses.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/XPACD--XPACI--XPACLRI--Strip-pointer-authentication-code-"
    )
    this["xpaclri"] = OpCodeDoc(
        "XPACLRI",
        """Strip Pointer Authentication Code. This instruction removes the pointer
authentication code from an address. The address is in the specified general-
purpose register for `XPACI` and `XPACD`, and is in LR for `XPACLRI`.

The `XPACD` instruction is used for data addresses, and `XPACI` and `XPACLRI`
are used for instruction addresses.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/XPACD--XPACI--XPACLRI--Strip-pointer-authentication-code-"
    )
    this["xtn"] = OpCodeDoc(
        "XTN",
        """Extract Narrow. This instruction reads each vector element from the source
SIMD&FP register, narrows each value to half the original width, places the
result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register. The destination vector elements are half as long
as the source vector elements.

The `XTN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `XTN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/XTN--XTN---Extract-narrow-"
    )
    this["xtn2"] = OpCodeDoc(
        "XTN2",
        """Extract Narrow. This instruction reads each vector element from the source
SIMD&FP register, narrows each value to half the original width, places the
result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register. The destination vector elements are half as long
as the source vector elements.

The `XTN` instruction writes the vector to the lower half of the destination
register and clears the upper half, while the `XTN2` instruction writes the
vector to the upper half of the destination register without affecting the
other bits of the register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/XTN--XTN---Extract-narrow-"
    )
    this["yield"] = OpCodeDoc(
        "YIELD",
        """YIELD is a hint instruction. Software with a multithreading capability can use
a `YIELD` instruction to indicate to the PE that it is performing a task, for
example a spin-lock, that could be swapped out to improve overall system
performance. The PE can use this hint to suspend and resume multiple software
threads if it supports the capability.

For more information about the recommended use of this instruction, see The
YIELD instruction.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/YIELD--Yield-"
    )
    this["zero"] = OpCodeDoc(
        "ZERO",
        """The instruction zeroes two or four ZA single-vector groups. The vector numbers
forming the single-vector group within each half of or each quarter of the ZA
array are selected by the sum of the vector select register and immediate
offset, modulo half or quarter the number of ZA array vectors.

The vector group symbol, VGx2 or VGx4, indicates that the ZA operand consists
of two or four ZA single-vector groups respectively.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ZERO--single-vector----"
    )
    this["zip1"] = OpCodeDoc(
        "ZIP1",
        """Zip vectors (primary). This instruction reads adjacent vector elements from
the lower half of two source SIMD&FP registers as pairs, interleaves the pairs
and places them into a vector, and writes the vector to the destination
SIMD&FP register. The first pair from the first source register is placed into
the two lowest vector elements, with subsequent pairs taken alternately from
each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ZIP---Zip-vectors--primary--"
    )
    this["zip2"] = OpCodeDoc(
        "ZIP2",
        """Zip vectors (secondary). This instruction reads adjacent vector elements from
the upper half of two source SIMD&FP registers as pairs, interleaves the pairs
and places them into a vector, and writes the vector to the destination
SIMD&FP register. The first pair from the first source register is placed into
the two lowest vector elements, with subsequent pairs taken alternately from
each source register.

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,
and the current Security state and Exception level, an attempt to execute the
instruction might be trapped.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ZIP---Zip-vectors--secondary--"
    )
    this["zip"] = OpCodeDoc(
        "ZIP",
        """Place the four-way interleaved elements from the four source vectors in the
corresponding elements of the four destination vectors.

This instruction is unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ZIP--four-registers----"
    )
    this["zipq1"] = OpCodeDoc(
        "ZIPQ1",
        """Interleave alternating elements from low halves of the corresponding 128-bit
vector segments of the first and second source vectors and place in elements
of the corresponding destination vector segment. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ZIPQ----"
    )
    this["zipq2"] = OpCodeDoc(
        "ZIPQ2",
        """Interleave alternating elements from high halves of the corresponding 128-bit
vector segments of the first and second source vectors and place in elements
of the corresponding destination vector segment. This instruction is
unpredicated.

""",
        "https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/ZIPQ----"
    )
}
